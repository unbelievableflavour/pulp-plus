// this code is purely here to check for useable code. Not in any way used in the plugin.

var rgbLight = [177,174,168];
var rgbDark = [50,47,39];
var uiLight = '#b1aea8';
var uiDark = '#322f27';
var uiYellow = '#ffb738';
var uiGreen = '#00ff00';
var uiLight50 = 'rgba('+rgbLight.join(',')+',0.5)';
var uiDark50 = 'rgba('+rgbDark.join(',')+',0.5)';
var uiYellow50 = 'rgba(251,198,81,0.5)';

window.name = 'editor';

// prevent default browser back/forward buttons behavior
history.pushState(null,null, document.URL);
window.addEventListener('popstate', function () {
  // bonk!
  history.pushState(null,null, document.URL);
});

var spacerDataURL = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

function stacktrace() {
  print('stacktrace', new Error().stack);
}

// utils
var AP = Array.prototype;
function flatten(arr) {
  return AP.concat.apply([],arr);
}
function invertKeysValues(arr) {
  var obj = {};
  for (var i=0; i<arr.length; i++) {
    obj[arr[i]] = i;
  }
  return obj;
}
function isEmpty(arr) {
  for (var i=0; i<arr.length; i++) {
    if (arr[i]) return false;
  }
  return true;
}

function sortByName(a,b) { return a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}); }
function sortNumeric(a,b) { return a-b; }
function filterUnique(value, index, arr) {
  return arr.indexOf(value) === index;
}

function clamp(num, min,max) {
  return num<min ? min : (num>max ? max : num);
}

// these two utils facilitate minimally sparse arrays,
// preserving pre-existing keys while minimizing gaps
function getFreeIndex(arr) {
  var i = 0;
  for (; i<=arr.length; i++) {
    if (!arr[i]) break;
  }
  return i;
}
function tidyTail(arr) {
  while (!arr[arr.length-1]) {
    arr.pop();
  }
}

function getFallbackIndex(arr, value) {
  var i = arr.indexOf(value);

  // check backwards first
  for (var j=i-1; j>=0; j--) {
    if (arr[j]) return j;
  }

  // then look forwards
  for (var j=i+1; j<arr.length; j++) {
    if (arr[j]) return j; // NOTE: assumes value is being removed
  }

  return -1;
}

var modifiedStartRoom = false;

function indexOfGameId(gameId) {
  for (var i=0; i<games.length; i++) {
    var game = games[i];
    if (game.id==gameId) return i;
  }
  return -1;
}
function indexOfGameName(gameName) {
  for (var i=0; i<games.length; i++) {
    var game = games[i];
    if (game.title==gameName) return i;
  }
  return -1;
}

const tileWidth = 8;
const tileHeight = 8;
const roomTilesWide = 25;
const roomTilesHigh = 15;
const roomWidth = roomTilesWide * tileWidth;
const roomHeight = roomTilesHigh * tileHeight;
function newFrameData(fill) {
  return (new Array(tileWidth*tileHeight)).fill(fill);
}
function newRoomTiles(fill) {
  return (new Array(roomTilesWide*roomTilesHigh)).fill(fill);
}

var FontType = {
  HalfWidth: 0,
  FullWidth: 1,
};
// NOTE: generated by misc/png2data/export.php
var defaultArrowsFrameData = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
var default4x8PipeFrameData = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1],
  [1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1],
  [1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];
var default4x8FontFrameData = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1],[1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
var default8x8PipeFrameData = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1],
  [1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1],
  [1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];
var default8x8FontFrameData = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1],[1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1],[1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,0,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1],[1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// update pipes with arrows data
for (var i=0; i<defaultArrowsFrameData.length; i++) {
  var arrowFrameData = defaultArrowsFrameData[i];
  default4x8PipeFrameData.push(clone(arrowFrameData));
  default8x8PipeFrameData.push(clone(arrowFrameData));
}

var TextSampleType = {
  Alphanum:0,
  Pangram:1,
  Custom:2,
};
var TextSamples = [
  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -,.?!',
  'The quick brown fox jumps over the lazy dog.',
  ''
];

function getByName(type, name) {
  var which = data[type+'s'];
  for (var i=0; i<which.length; i++) {
    var obj = which[i];
    if (!obj) continue;
    if (obj.name==name) return obj.id;
  }
  return -1;
}

function dupeName(type, id) {
  var which = data[type+'s']; // type = room|tile|song|sound
  var obj = which[id];

  var m = obj.name.match(new RegExp('^'+type+' [0-9]+$'));
  if (m) return type+' '+getFreeIndex(which, id);

  function preventCollision(prefix, num) {
    // TODO: is there a better way to do this?
    var candidate = prefix+num;
    for (var i=0; i<which.length; i++) {
      var obj = which[i];
      if (!obj) continue;
      if (obj.name==candidate) {
        num += 1;
        candidate = prefix+num;
        i=-1; // start search over
      }
    }
    return candidate;
  }

  m = obj.name.match(/^(.+)([0-9]+)$/);
  if (m) {
    var prefix = m[1];
    var num = parseInt(m[2]);
    return preventCollision(prefix, num+1);
  }

  return preventCollision(obj.name+' ', 2);
}

// data manip
function getRoomName() {
  return 'room '+getFreeIndex(data.rooms);
}
function dupeRoomName(roomId) {
  return dupeName('room', roomId);
}
function addRoom() {
  var roomId = getFreeIndex(data.rooms);
  var room = {
    id:roomId,
    exits:[],
    name:getRoomName(),
    tiles:newRoomTiles(data.background),
    song:-1,
  };
  data.rooms[roomId] = room;
  return roomId;
}
function dupeRoom(roomId) {
  var room = data.rooms[roomId];

  var dupeId = getFreeIndex(data.rooms);
  var dupe = {
    id:dupeId,
    exits:clone(room.exits),
    name:dupeRoomName(roomId),
    tiles:clone(room.tiles),
    song:room.song,
  };

  // disconnect edge exits since they won't be reciprocal
  for (var i=0; i<dupe.exits.length; i++) {
    var exit = dupe.exits[i];
    if (getExitType(exit)==ExitType.Edge) {
      exit.edge = -1;
      exit.room = -1;
      exit.tx = -1;
      exit.ty = -1;
    }
  }

  if (hasScript(room)) {
    dupe.script = dupeScript(room.script,dupeId);
  }

  data.rooms[dupeId] = dupe;

  return dupeId;
}
function deleteRoom(roomId) {
  var room = data.rooms[roomId];

  // remove paired exits
  for (var i=0; i<room.exits.length; i++) {
    var exit = room.exits[i];
    var exitType = getExitType(exit);
    if (exitType==ExitType.Edge && exit.room!=-1) {
      var pair = getExitAt(exit.tx,exit.ty,exit.room);
      if (pair) {
        var pairExits = data.rooms[exit.room].exits;
        pairExits.splice(pair.id,1);
        for (var j=pair.id; j<pairExits.length; j++) {
          pairExits[j].id = j;
        }
      }
    }
  }

  // remove script
  if (isset(room.script)) {
    deleteScript(room.script);
  }

  data.rooms[roomId] = false;
  tidyTail(data.rooms);
}

function getThingByName(type, name) {
  var things = data[type+'s'];
  for (var i=0; i<things.length; i++) {
    var thing = things[i];
    if (!thing) continue;
    if (thing.name==name) return thing.id;
  }
  return -1;
}

function getCardFallback() {
  var cardRoomId = -1;
  for (var r=0; r<data.rooms.length; r++) {
    var room = data.rooms[r];
    if (!room) continue;
    if (room.name=='card') {
      cardRoomId = room.id;
      break;
    }
  }
  if (cardRoomId==-1) cardRoomId = data.player.room;
  return cardRoomId;
}

function getSongName() {
  return 'song '+getFreeIndex(data.songs);
}
function dupeSongName(songId) {
  return dupeName('song', songId);
}
function addSong() {
  var songId = getFreeIndex(data.songs);
  var song = {
    id:songId,
    name:getSongName(),
    bpm:120,
    loopFrom:0,
    ticks:0,
    notes:[ [],[],[],[],[] ], // by voice, note(0=rest,1-12=C-B),octave(0-8),hold(in 16ths)
    splits:[ [],[],[],[],[] ], // by voice, split(as 4ths)
  };
  data.songs[songId] = song;
  return songId;
}
function dupeSong(songId) {
  var song = data.songs[songId];
  var dupeId = getFreeIndex(data.songs);
  var dupe = {
    id:dupeId,
    name:dupeSongName(songId),
    bpm:song.bpm,
    loopFrom:song.loopFrom,
    ticks:song.ticks,
    notes:clone(song.notes),
    splits:clone(song.splits),
  };
  if (isset(song.voices)) dupe.voices = clone(song.voices);
  data.songs[dupeId] = dupe;

  return dupeId;
}
function deleteSong(songId) {
  // TODO: is any cleanup necessary or can we just null songIds as encountered elsewhere?
  data.songs[songId] = false;
  tidyTail(data.songs);
}

function getSoundName() {
  return 'sound '+getFreeIndex(data.sounds);
}
function dupeSoundName(soundId) {
  return dupeName('sound', soundId);
}
function addSound() {
  var soundId = getFreeIndex(data.sounds);
  var sound = {
    id:soundId,
    name:getSoundName(),
    bpm:120,
    ticks:0,
    type:VoiceType.Sine,
    notes:[], // note(0=rest,1-12=C-B),octave(0-8),hold(in 16ths)
  };
  data.sounds[soundId] = sound;
  return soundId;
}
function dupeSound(soundId) {
  var sound = data.sounds[soundId];
  var dupeId = getFreeIndex(data.sounds);
  var dupe = {
    id:dupeId,
    name:dupeSoundName(soundId),
    bpm:sound.bpm,
    ticks:sound.ticks,
    type:sound.type,
    notes:clone(sound.notes),
  };
  if (isset(sound.envelope)) dupe.envelope = clone(sound.envelope);
  data.sounds[dupeId] = dupe;

  return dupeId;
}
function deleteSound(soundId) {
  // TODO: is any cleanup necessary or can we just null soundIds as encountered elsewhere?
  data.sounds[soundId] = false;
  tidyTail(data.sounds);
}

function makeExitConnection(exit) {
  if (isset(exit.fin)) {
    delete exit.fin;
    delete exit.song;
  }

  if (!isset(exit.room)) {
    exit.room = -1;
    exit.tx = -1;
    exit.ty = -1;
  }

  if (isset(exit.edge) && exit.room!=-1) {
    // delete pair exit
    var pair = getExitAt(exit.tx,exit.ty,exit.room);
    if (pair) {
      var pairExits = data.rooms[exit.room].exits;
      pairExits.splice(pair.id,1);
      for (var j=pair.id; j<pairExits.length; j++) {
        pairExits[j].id = j;
      }
    }
  }
  delete exit.edge;
}
function makeExitEdge(exit) {
  if (isset(exit.fin)) {
    delete exit.fin;
    delete exit.song;
  }

  if (!isset(exit.room)) {
    exit.room = -1;
    exit.tx = -1;
    exit.ty = -1;
  }

  updateExitEdge(exit,true);

  if (exit.room!=-1) {
    var room = data.rooms[exit.room];
    var pair = {
      id: room.exits.length,
      x: exit.tx,
      y: exit.ty,
      edge: getOppositeEdge(exit),
      room: data.editor.activeRoomId,
      tx: exit.x,
      ty: exit.y,
    };
    room.exits[pair.id] = pair;
  }
}
function makeExitEnding(exit) {
  delete exit.room;
  delete exit.edge;
  delete exit.tx;
  delete exit.ty;
  exit.fin = '';
  exit.song = -1;
}

function getOppositeEdge(exit) {
  switch (exit.edge) {
    case ExitEdge.North: return ExitEdge.South;
    case ExitEdge.South: return ExitEdge.North;
    case ExitEdge.East:  return ExitEdge.West;
    case ExitEdge.West:  return ExitEdge.East;
  }
}
function updateExitEdge(exit, forceReorientation) {
  if (exit.room!=-1 && !forceReorientation) return; // can't reorient once linked

  var xr = exit.x / (roomTilesWide-1);
  var yr = exit.y / (roomTilesHigh-1);
  var is_west  = xr < 0.5;
  var is_north = yr < 0.5;

  xr = (is_west ) ? 0.5-xr : xr-0.5;
  yr = (is_north) ? 0.5-yr : yr-0.5;

  var newEdge;
  if (xr>yr) { // further from center along horizontal axis than vertical
    newEdge = is_west ? ExitEdge.West : ExitEdge.East;
  }
  else {
    newEdge = is_north ? ExitEdge.North : ExitEdge.South;
  }
  exit.edge = newEdge;

  var existingExit = getExitAt(exit.x, exit.y, null, exit);
  if (existingExit) {
    if (xr>yr) {
      if (exit.x>0 && !getExitAt(exit.x-1,exit.y,null,exit)) exit.x -= 1;
      else if (exit.x<roomTilesWide-1 && !getExitAt(exit.x+1,exit.y,null,exit)) exit.x += 1;
    }
    else {
      if (exit.y>0 && !getExitAt(exit.x,exit.y-1,null,exit)) exit.y -= 1;
      else if (exit.y<roomTilesHigh-1 && !getExitAt(exit.x,exit.y+1,null,exit)) exit.y += 1;
    }
  }
}

function addFrame() {
  var frameId = getFreeIndex(data.frames);
  var frame = {
    id:frameId,
    data:newFrameData(data.background)
  };
  data.frames[frameId] = frame;

  return frameId;
}
function dupeFrame(frameId) {
  var frame = data.frames[frameId];

  var dupeId = getFreeIndex(data.frames);
  var dupe = {
    id:dupeId,
    data:clone(frame.data)
  };
  data.frames[dupeId] = dupe;

  return dupeId;
}
function deleteFrame(frameId) {
  data.frames[frameId] = false;
  tidyTail(data.frames);
}

function invertFrameData(frameData) {
  for (var i=0; i<frameData.length; i++) {
    var f = frameData[i];
    if (f==2) continue;
    frameData[i] = !f + 0;
  }
}
function flipFrameDataH(frameData) {
  var modData = newFrameData(0);
  for (var i=0; i<frameData.length; i++) {
    var y = Math.floor(i / tileWidth);
    var x = i - (y * tileWidth);
    modData[i] = frameData[(y*tileWidth)+(7-x)];
  }
  AP.splice.apply(frameData, [0, frameData.length].concat(modData));
}
function flipFrameDataV(frameData) {
  var modData = newFrameData(0);
  for (var i=0; i<frameData.length; i++) {
    var y = Math.floor(i / tileWidth);
    var x = i - (y * tileWidth);
    modData[i] = frameData[((7-y)*tileWidth)+x];
  }
  AP.splice.apply(frameData, [0, frameData.length].concat(modData));
}
function rotateFrameData(frameData,cw) {
  var modData = newFrameData(0);
  for (var i=0; i<frameData.length; i++) {
    var y = Math.floor(i / tileWidth);
    var x = i - (y * tileWidth);
    var j = (x*tileWidth)+(tileHeight - y - 1);
    if (cw) modData[j] = frameData[i];
    else modData[i] = frameData[j];
  }
  AP.splice.apply(frameData, [0, frameData.length].concat(modData));
}

// based on https://github.com/hughsk/flood-fill
function floodFillData(data,x,y,fill) {
  var width,height;
  function get(x,y) {
    if (x<0 || x>=width) return fill;
    return data[y*width+x];
  }
  function set(x,y,value) {
    if (x<0 || x>=width) return;
    data[y*width+x] = value;
  }
  if (data.length==tileWidth*tileHeight) { // frameData
    width = tileWidth;
    height = tileHeight;
  }
  else { // roomTiles
    width = roomTilesWide;
    height = roomTilesHigh;
  }

  var empty = get(x,y);
  if (empty==fill) return 0;
  var queueX = [x];
  var queueY = [y];
  var currY, currX;
  var row;
  var area = 0;
  var north;
  var south;
  var n;

  while (queueY.length) {
    currX = queueX.pop();
    currY = queueY.pop();
    row = currX * height;
    if (get(currX, currY)===empty) {
      north = south = currY;

      do {
        north -= 1;
      } while (get(currX, north) === empty && north >= 0);

      do {
        south += 1;
      } while (get(currX, south) === empty && south < height);

      for (n = north + 1; n < south; n += 1) {
        set(currX, n, fill);
        area += 1;
        if (get(currX - 1, n)===empty) {
          queueX.push(currX - 1);
          queueY.push(n);
        }
        if (get(currX + 1, n)===empty) {
          queueX.push(currX + 1);
          queueY.push(n);
        }
      }
    }
  }

  return area;
}
function shiftData(data,dx,dy) {
  var width,height;
  if (data.length==tileWidth*tileHeight) { // frameData
    width = tileWidth;
    height = tileHeight;
  }
  else if (data.length==roomTilesWide*roomTilesHigh) { // roomTiles
    width = roomTilesWide;
    height = roomTilesHigh;
  }
  else {
    print('Unrecognized data dimensions, lenght: '+data.length);
    return;
  }

  var modData = [];
  for (var y=0; y<height; y++) {
    var row = data.slice(y*width, (y+1)*width);
    if (dx>0) {
      AP.splice.apply(row, [0,0].concat(row.splice(-dx)));
    }
    else if (dx<0) {
      AP.splice.apply(row, [row.length,0].concat(row.splice(0,-dx)));
    }
    modData[y] = row;
  }

  if (dy>0) {
    AP.splice.apply(modData, [0,0].concat(modData.splice(-dy)));
  }
  else if (dy<0) {
    AP.splice.apply(modData, [modData.length,0].concat(modData.splice(0,-dy)));
  }

  modData = AP.concat.apply([], modData);

  AP.splice.apply(data, [0, data.length].concat(modData));
}

// search results
var ResultType = {
  Game:0,
  Room:1,
  Tile:2,
  Song:3,
  Sound:4,
  Script:5,
};
var GameMeta = {
  Name:0,
  Author:1,
  Intro:2
};

var EditorMode = {
  Game: 0,
  Font: 1,
  Room: 2,
  Song: 3,
  Sound: 4,
  Script: 5,
};
var TileType = {
  World: 0, // may be solid
  Player: 1, // solid is irrelevant
  Sprite: 2, // always solid
  Item: 3, // never solid
  Exit: 4, // TODO: can this be removed? or is it needed for Layers?
};
var Layer = {
  Exits: 0,
  Player: 1,
  Sprites: 2,
  Items: 3,
  World: 4,
}
var LayerToName = [
  'Exits',
  'Player',
  'Sprites',
  'Items',
  'World',
];
var LayerToTileType = [
  TileType.Exit,
  TileType.Player,
  TileType.Sprite,
  TileType.Item,
  TileType.World,
];
var TileTypeToLayer = [
  4,
  1,
  2,
  3,
  0,
];
var BehaviorType = {
  None:-1,
  Simple: 0,
  Script: 1,
};
// used by data.editor.recentScripts
var ScriptType = {
  Game: 0,
  Room: 1,
  Tile: 2,
};
function hasScript(object) {
  if (!isset(object.script)) return false;
  var script = data.scripts[object.script];
  if (!script) return false;
  return (isset(script.data) && script.data.__srcOrder.length>0);
}
function hasSays(tile) {
  if (isset(tile.says)) {
    if (typeof tile.says==='string') return tile.says.trim().length>0;
    else return tile.says.length>1; // can now be a PulpScript format expression
  }
  return false;
}

function addScript(type,sourceId,scriptData) {
  var scriptId = getFreeIndex(data.scripts);
  var script = {
    type:type,
    id:sourceId,
  };
  if (scriptData) script.data = scriptData;
  data.scripts[scriptId] = script;
  return scriptId;
}
function dupeScript(scriptId,sourceId) {
  var script = data.scripts[scriptId];
  var dupeId = getFreeIndex(data.scripts);
  var dupe = clone(script);
  dupe.id = sourceId;
  data.scripts[dupeId] = dupe;
  return dupeId;
}
function deleteScript(scriptId) {

  var script = data.scripts[scriptId];
  if (script) {
    if (script.type==ScriptType.Game) {
      // delete data.script; NOTE: game script is protected
      return;
    }
    else if (script.type==ScriptType.Room) {
      delete data.rooms[script.id].script;
    }
    else if (script.type==ScriptType.Tile) {
      if (script.id==data.player.id) { // NOTE: player script is protected
        return;
      }
      else {
        delete data.tiles[script.id].script;
      }
    }
    var i = getFallbackIndex(data.editor.recentScripts, scriptId);
    var fallbackId = i>-1 ? data.editor.recentScripts[i] : 0;
    data.scripts[scriptId] = false;
    tidyTail(data.scripts);
    data.editor.activeScriptId = fallbackId;
    removeRecentScript(scriptId);
  }
}
function getScriptSource(script) {
  var source;
  switch (script.type) {
    case ScriptType.Game:
      source = data;
      break;
    case ScriptType.Room:
      source = data.rooms[script.id];
      break;
    case ScriptType.Tile:
      source = data.tiles[script.id];
      break;
  }
  return source;
}

var ExitType = {
  Connection: 0,
  Ending: 1,
  Edge: 2,
};
var ExitEdge = {
  North: 0,
  East: 1,
  South: 2,
  West: 3,
};
function getExitType(exit) {
  if (isset(exit.fin)) return ExitType.Ending;
  else if (isset(exit.edge)) return ExitType.Edge;
  return ExitType.Connection;
}
function isExitConfigured(exit) {
  if (isset(exit.fin) && (Array.isArray(exit.fin) || exit.fin.trim().length>0)) return true;
  else if (isset(exit.edge) && exit.edge>-1 && isset(exit.room) && exit.room>-1 && isset(exit.tx) && exit.tx>-1 && isset(exit.ty) && exit.ty>-1) return true;
  else if (isset(exit.room) && exit.room>-1 && isset(exit.tx) && exit.tx>-1 && isset(exit.ty) && exit.ty>-1) return true;
  return false;
}
function validateTileProperties(tile) {
  switch (tile.type) {
    case TileType.World:
      tile.btype = BehaviorType.None;
      break;
    case TileType.Player:
      tile.solid = false;
      tile.btype = tile.id==data.player.id ? BehaviorType.Script : BehaviorType.None;
      break;
    case TileType.Sprite:
      if (tile.btype==BehaviorType.None) tile.btype = BehaviorType.Simple;
      tile.solid = true;
      break;
    case TileType.Item:
      if (tile.btype==BehaviorType.None) tile.btype = BehaviorType.Simple;
      tile.solid = false;
      break;
  }

  switch (tile.btype) {
    case BehaviorType.None:
      if (isset(tile.says)) delete tile.says;
      if (isset(tile.sound)) delete tile.sound;
      if (isset(tile.script)) deleteScript(tile.script);
      break;
    case BehaviorType.Simple:
      if (isset(tile.script)) deleteScript(tile.script);
      break;
    case BehaviorType.Script:
      if (isset(tile.says)) delete tile.says;
      if (isset(tile.sound)) delete tile.sound;
      break;
  }
}
function addTile(tileType) {
  var tileId = getFreeIndex(data.tiles);
  var frameId = addFrame();
  tileType = tileType || TileType.World;
  var tile = {
    id:tileId,
    type:tileType,
    name:'tile '+tileId,
    solid:false,
    frames:[frameId],
    fps:1,
    btype:BehaviorType.Simple,
  };
  validateTileProperties(tile);
  data.tiles[tileId] = tile;
  return tileId;
}
function dupeTile(tileId) {
  var tile = data.tiles[tileId];

  var dupeId = getFreeIndex(data.tiles);
  var dupe = {
    id:dupeId,
    type:tile.type,
    name:dupeName('tile', tileId),
    solid:tile.solid,
    frames:[],
    fps:tile.fps,
    btype:tile.btype,
  };

  if (tile.btype==BehaviorType.Simple) {
    if (isset(tile.says)) {
      if (typeof tile.says==='string') {
        dupe.says = tile.says;
      }
      else {
        dupe.says = clone(tile.says);
      }
    }
    if (isset(tile.sound)) {
      dupe.sound = tile.sound;
    }
  }
  else if (tile.btype==BehaviorType.Script && isset(tile.script)) {
    dupe.script = dupeScript(tile.script,dupeId);
  }

  for (var i=0; i<tile.frames.length; i++) {
    dupe.frames[i] = dupeFrame(tile.frames[i]);
  }

  data.tiles[dupeId] = dupe;
  return dupeId;
}
function deleteTile(tileId) {
  // remove tile from rooms
  for (var r=0; r<data.rooms.length; r++) {
    var room = data.rooms[r];
    if (!room) continue;
    var tiles = room.tiles
    for (var i=0; i<tiles.length; i++) {
      if (tiles[i]==tileId) tiles[i] = 0;
    }
  }

  // remove tile frames
  var tile = data.tiles[tileId];
  var frames = tile.frames;
  for (var i=0; i<frames.length; i++) {
    deleteFrame(frames[i]);
  }

  // remove script
  if (tile.btype==BehaviorType.Script && isset(tile.script)) {
    deleteScript(tile.script);
  }
  // final remove the tile itself
  data.tiles[tileId] = false;
  tidyTail(data.tiles);
}

// NOTE: generated by php/png2data/export.php
// player, sprite, item
var defaultFrameData = [
  [0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,1,0],[0,0,1,1,1,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,0,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
];

var default8x8Font = {
  type:FontType.FullWidth,
  chars:default8x8FontFrameData,
  pipe:default8x8PipeFrameData,
};
var default4x8Font = {
  type:FontType.HalfWidth,
  chars:default4x8FontFrameData,
  pipe:default4x8PipeFrameData,
};

var elapsed = 0;
var frameTimers = {};
function addFrameTimer(fps) {
  if (fps<0) return; // TODO: don't do this...
  if (frameTimers[fps]) return;

  var duration = 1/fps;
  var frames = Math.floor(elapsed / duration);
  var frameElapsed = elapsed - (frames * duration);
  frameTimers[fps] = {
    frame: frames,
    duration: duration,
    elapsed: frameElapsed
  };
}

var autoPollId;
function scheduleAutoPoll() {
  if (autoPollId) window.clearTimeout(autoPollId);

  var minutes = throttlePolling ? 10 : 1;
  autoPollId = window.setTimeout(function() {
    if (isDirty) saveData(); // also calls pollMeta()
    else pollMeta();
  }, minutes * 60 * 1000);
}
scheduleAutoPoll();

var UnsavedGameKeyName = 'com.panic.pulp.unsavedGame';
var recoveredUnsavedData = false;
function pollMeta(callback) { // callback(localGame, remoteGame)
  scheduleAutoPoll();
  var localGame = games[indexOfGameId(currentGameId)];
  Local.get(urls.root + 'games/' + currentGameId + '/meta/', function(text, status) {
    if (text.indexOf('{')!=0 && text.indexOf('type="password"')!=-1) { // TODO: replace with if (status==401)
      // session timed out
      return showAlert(['Your session has timed out.','Any unsaved changes will be saved once logged back in.'], function() {
        if (isDirty) {
          var unsavedGame = {
            id: currentGameId,
            title:data.name,
            origin_date: localGame.modified_date,
            data: data,
          };
          localStorage.setItem(UnsavedGameKeyName, JSON.stringify(unsavedGame));
        }
        window.location.reload();
      });
    }
    var remoteGame = JSON.parse(text);

    var oldThrottle = throttlePolling;
    throttlePolling = remoteGame.throttle_polling;
    if (throttlePolling!=oldThrottle) scheduleAutoPoll();

    isDownloadEnabled = remoteGame.is_download_enabled;
    one('body').classList.toggle('enable-downloads', isDownloadEnabled);

    if (localGame.modified_date<remoteGame.modified_date) {
      return showOverlay('conflict');
    }
    else if (callback) {
      callback(localGame,remoteGame);
    }
  });
}

var afterSave = null;
function doSave(localGame, remoteGame, callback) {
  afterSave = callback;
  Local.put(urls.root + 'games/' + currentGameId + '/data/', JSON.stringify(data), function(text, status) {
    var remoteGame = JSON.parse(text);
    localGame.modified_date = remoteGame.modified_date;

    if (afterSave) {
      afterSave();
      afterSave = null;
    }
    markSaved();
  });
}

function saveData(callback) {
  pollMeta(function(localGame, remoteGame) {
    doSave(localGame, remoteGame, callback);
  });
}

function resolveConflictDiscard() {
  if (recoveredUnsavedData) {
    recoveredUnsavedData = false;
    localStorage.removeItem(UnsavedGameKeyName);
  }
  window.location.reload();
}
function resolveConflictSave() {
  hideOverlay();
  Local.get(urls.root + 'games/' + currentGameId + '/meta/', function(text, status) {
    var remoteGame = JSON.parse(text);
    var localGame = games[indexOfGameId(currentGameId)];
    localGame.modified_date = remoteGame.modified_date; // override date so manual save will succeed
    saveData(afterSave);
  });
}

function detectUnsavedData() {
  var unsavedGame = localStorage.getItem(UnsavedGameKeyName);
  if (unsavedGame!=null) {
    // print('detected unsaved data...');
    unsavedGame = JSON.parse(unsavedGame);
    var game = games[indexOfGameId(unsavedGame.id)];
    game.title = unsavedGame.title;
    game.modified_date = unsavedGame.origin_date;
    data = unsavedGame.data;
    recoveredUnsavedData = true;
  }
}
function saveRecoveredData() {
  if (recoveredUnsavedData) {
    recoveredUnsavedData = false;
    saveData(function() {
      localStorage.removeItem(UnsavedGameKeyName);
      // print('saved (and discarded) unsaved data!');
    });
  }
}

function doDownload() {
  window.open(urls.root + 'games/' + currentGameId + '/export/');
}
function downloadPdx() {
  pollMeta(function(localGame,remoteGame) {
    if (!isDownloadEnabled) return showAlert('Sorry, PDX downloads have been temporarily disabled due to heavy load. Please try again later.');

    // NOTE: when deferred by a save Safari blocks the download as a pop-up
    if (isDirty) doSave(localGame, remoteGame, doDownload);
    else doDownload();
  });
}

function importJSON(event) {
  var files = event.target.files;
  if (files.length==1) {
    var reader = new FileReader;
    reader.onload = function(e) {
      var json = e.target.result;
      data = JSON.parse(json);

      // ensure uniqueness
      var gameName = data.name;
      var re = /([0-9]+)\s*$/;
      while (indexOfGameName(gameName)!=-1) {
        var m;
        if (m = gameName.match(re)) {
          var i = parseInt(m[1]) + 1;
          gameName = gameName.replace(re,i);
        }
        else gameName += ' 2';
      }

      games[indexOfGameId(currentGameId)].title = data.name = gameName;

      resetHistory();

      unbindAll();
      onDataReady();
      markDirty();
    };
    reader.readAsText(files[0]);
  }
  event.target.value = null;
}
function exportJSON() {
  var json = JSON.stringify(data);
  var a = document.createElement('a');
  var blob = new Blob([json], {'type':'application/octet-stream'});
  a.href = window.URL.createObjectURL(blob);
  a.download = (data.name || 'Untitled Pulp Game')+'.json';
  a.click();
}

const editorScale = 2;
const roomEditorScale = 2 * editorScale;
const tileEditorScale = 16 * editorScale;
const exitEditorScale = 1.5;

// NOTE: generated by misc/export.php
var exitsFrameData = [
  [1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1]
];
var edgesFrameData = [
  [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],[0,1,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],[0,1,1,1,1,0,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,1,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0],[0,1,1,1,1,1,1,0,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0]
];
var Exit = {
  Misconfigured: 0,
  Connection: 1,
  Ending: 2,
  Target: 3,
};

var pipes = [
  'Top-left','Top','Top-right','Left','Middle','Right','Bottom-left','Bottom','Bottom-right','Prompt','Prompt (Down)','Cursor','Cursor (Inactive)','Pages'
];
var chars = [
  ' ','!','"','#','$','%','&',"'",'(',')','*','+',',','-','.','/','0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?','@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_','`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','{','|','}','~',
];

function decodeStringMatch(str,re) {
  str = str.replace(/\\"/g,'&quot;'); // encode escaped quotes
  var match = str.match(re);
  if (!match) return null;

  for (var i=0; i<match.length; i++) {
    var value = match[i];
    if (!value) continue;

    value = value.replace(/\\n/g, '\n'); // decode newline
    value = value.replace(/\\f/g, '\f'); // decode formfeed
    value = value.replace(/&quot;/g, '\"'); // decode escaped quotes
    match[i] = value;
  }
  return match;
}
function reencodeMatchedString(str) {
  str = str.replace(/\n/g, '\\n');
  str = str.replace(/\f/g, '\\f');
  str = str.replace(/\"/g, '\\"');
  return str
}
function json2ps(json) {
  var Parser = {
    depth: 0,
    value: '',
  };

  function tab() {
    Parser.value += ('\t').repeat(Parser.depth);
  }

  function startEvent(name) {
    Parser.value += 'on '+name+' do\n';
  }
  function endEvent() {
    Parser.value += 'end\n\n';
  }
  function decodeString(value) {
    value = value.replace(/\n/g, '\\n');
    value = value.replace(/\f/g, '\\f');
    value = value.replace(/\"/g, '\\"');
    // any braces in a string were previously escaped
    if (isset(data.version)) value = value.replace(/(\{|\})/g, '\\$1'); // TODO: remove condition after Neven updates
    return value;
  }
  function parseValue(value) {
    if (!isset(value)) return;

    if (Array.isArray(value)) {
      parseExpression(value);
    }
    else if (typeof value=='number') { // || value.match(/^-?(?:[0-9]+)?\.?[0-9]+$/)) {
      Parser.value += value;
    }
    else {
      Parser.value += '"'+decodeString(value)+'"';
    }
  }
  function parseExpression(expr) {
    if (Parser.syntax[expr[0]]) {
      Parser.syntax[expr[0]](expr)
    }
    else {
      console.log('Unsupported expression '+expr[0]);
    }
  }
  function parseBlock(block) {
    Parser.depth += 1;
    var array = json.__blocks[block[1]];
    for (var i=0; i<array.length; i++) {
      var expr = array[i];
      if (expr!=-1 && expr[0]=='_') continue;

      tab();
      if (expr!=-1) {
        parseExpression(expr);
      }
      Parser.value += '\n';
    }
    Parser.depth -= 1;
  }
  function parsePadLeft(expr) {
    Parser.value += expr[2];
    Parser.value += ',';
    Parser.value += expr[3];
    Parser.value += ':';
    parseExpression(expr[1]);
  }
  function parsePadRight(expr) {
    parseExpression(expr[1]);
    Parser.value += ':';
    Parser.value += expr[2];
    Parser.value += ',';
    Parser.value += expr[3];
  }
  function parseFormat(expr) {
    Parser.value += '"';
    for (var i=1; i<expr.length; i++) {
      var value = expr[i];
      if (Array.isArray(value)) {
        Parser.value += '{';
        parseExpression(value);
        Parser.value += '}';
      }
      else {
        Parser.value += decodeString(value);
      }
    }
    Parser.value += '"';
  }
  function parseGet(expr) {
    Parser.value += expr[1];
  }
  function parseSet(expr) {
    Parser.value += expr[1]+' = ';
    parseValue(expr[2]);
  }
  function parseRandom(expr) {
    Parser.value += 'random ';
    parseValue(expr[1]);
    if (expr[2]) {
      Parser.value += ',';
      parseValue(expr[2]);
    }
  }
  function parseFloor(expr) {
    Parser.value += 'floor ';
    parseValue(expr[1]);
  }
  function parseCeil(expr) {
    Parser.value += 'ceil ';
    parseValue(expr[1]);
  }
  function parseRound(expr) {
    Parser.value += 'round ';
    parseValue(expr[1]);
  }

  function parseSine(expr) {
    Parser.value += 'sine ';
    parseValue(expr[1]);
  }
  function parseCosine(expr) {
    Parser.value += 'cosine ';
    parseValue(expr[1]);
  }
  function parseTangent(expr) {
    Parser.value += 'tangent ';
    parseValue(expr[1]);
  }
  function parseDegrees(expr) {
    Parser.value += 'degrees ';
    parseValue(expr[1]);
  }
  function parseRadians(expr) {
    Parser.value += 'radians ';
    parseValue(expr[1]);
  }

  function parseSolid(expr) {
    Parser.value += 'solid ';
    parseValue(expr[1]);
  }
  function parseType(expr) {
    Parser.value += 'type ';
    parseValue(expr[1]);
  }
  function parseName(expr) {
    Parser.value += 'name ';
    parseValue(expr[1]);
  }

  function parseWhile(expr) {
    Parser.value += 'while ';
    parseExpression(expr[1]);
    Parser.value += ' do\n';
    parseBlock(expr[2]);
    tab();
    Parser.value += 'end';
  }
  function parseIf(expr) {
    Parser.value += 'if ';
    parseExpression(expr[1]);
    Parser.value += ' then\n';
    parseBlock(expr[2]);
    for (var i=3; i<expr.length; i++) {
      tab();
      var elif = expr[i];
      if (elif[0]=='elseif') {
        Parser.value += 'elseif ';
        parseExpression(elif[1]);
        Parser.value += ' then\n';
        parseBlock(elif[2]);
      }
      else if (elif[0]=='else') {
        Parser.value += 'else\n';
        parseBlock(elif[1]);
      }
    }
    tab();
    Parser.value += 'end';
  }
  function parseCondition(expr, syntax) {
    Parser.value += expr[1]+syntax;
    parseValue(expr[2]);
  }
  function parseEq(expr) {
    parseCondition(expr, '==');
  }
  function parseNeq(expr) {
    parseCondition(expr, '!=');
  }
  function parseGt(expr) {
    parseCondition(expr, '>');
  }
  function parseLt(expr) {
    parseCondition(expr, '<');
  }
  function parseGte(expr) {
    parseCondition(expr, '>=');
  }
  function parseLte(expr) {
    parseCondition(expr, '<=');
  }
  function parseXY(expr) {
    parseValue(expr[1]);
    Parser.value += ',';
    parseValue(expr[2]);
  }
  function parseRect(expr) {
    parseValue(expr[1]);
    for (var i=2; i<expr.length; i++) {
      Parser.value += ',';
      parseValue(expr[i]);
    }
  }

  function parseInc(expr) {
    Parser.value += expr[1]+'++';
  }
  function parseDec(expr) {
    Parser.value += expr[1]+'--';
  }
  function parseAdd(expr) {
    Parser.value += expr[1]+' += ';
    parseValue(expr[2]);
  }
  function parseSub(expr) {
    Parser.value += expr[1]+' -= ';
    parseValue(expr[2]);
  }
  function parseMul(expr) {
    Parser.value += expr[1]+' *= ';
    parseValue(expr[2]);
  }
  function parseDiv(expr) {
    Parser.value += expr[1]+' /= ';
    parseValue(expr[2]);
  }

  function parseAct(expr) {
    Parser.value += 'act';
  }
  function parseLog(expr) {
    Parser.value += 'log ';
    parseValue(expr[1]);
  }
  function parseDump(expr) {
    Parser.value += 'dump';
  }
  function parseShake(expr) {
    Parser.value += 'shake ';
    parseValue(expr[1]);
    if (expr[2]) {
      Parser.value += ' then\n';
      parseBlock(expr[2]);
      tab();
      Parser.value += 'end';
    }
  }
  function parseSay(expr) {
    Parser.value += 'say ';
    parseValue(expr[1]);
    if (expr[3]) {
      Parser.value += ' at ';
      var rect = expr[3];
      parseValue(rect[1]);
      for (var i=2; i<rect.length; i++) {
        Parser.value += ',';
        parseValue(rect[i]);
      }
    }
    if (expr[2]) {
      Parser.value += ' then\n';
      parseBlock(expr[2]);
      tab();
      Parser.value += 'end';
    }
  }
  function parseAsk(expr) {
    Parser.value += 'ask ';
    parseValue(expr[1]);
    if (expr[3]) {
      Parser.value += ' at ';
      var rect = expr[3];
      parseValue(rect[1]);
      for (var i=2; i<rect.length; i++) {
        Parser.value += ',';
        parseValue(rect[i]);
      }
    }
    Parser.value += ' then\n';
    parseBlock(expr[2]);
    tab();
    Parser.value += 'end';
  }

  function parseFin(expr) {
    Parser.value += 'fin ';
    parseValue(expr[1]);
    if (expr[2]) {
      Parser.value += ' at ';
      var rect = expr[2];
      parseValue(rect[1]);
      for (var i=2; i<rect.length; i++) {
        Parser.value += ',';
        parseValue(rect[i]);
      }
    }
  }
  function parseMenu(expr) {
    Parser.value += 'menu at ';
    var rect = expr[1];
    parseValue(rect[1]);
    for (var i=2; i<rect.length; i++) {
      Parser.value += ',';
      parseValue(rect[i]);
    }
    Parser.value += ' then\n';

    parseBlock(expr[2]);

    tab();
    Parser.value += 'end';
  }
  function parseOption(expr) {
    Parser.value += 'option ';
    parseValue(expr[1]);
    Parser.value += ' then\n';
    // NOTE: expr[2] is the index
    parseBlock(expr[3]);
    tab();
    Parser.value += 'end';
  }
  function parseCall(expr) {
    Parser.value += 'call ';
    parseValue(expr[1]);
  }
  function parseEmit(expr) {
    Parser.value += 'emit ';
    parseValue(expr[1]);
  }
  function parseSwap(expr) {
    Parser.value += 'swap ';
    parseValue(expr[1]);
  }
  function parseTell(expr) {
    Parser.value += 'tell ';
    parseValue(expr[1]);
    Parser.value += ' to\n';
    parseBlock(expr[2]);
    tab();
    Parser.value += 'end';
  }
  function parseFrame(expr) {
    Parser.value += 'frame';
    if (isset(expr[1])) {
      Parser.value += ' ';
      parseValue(expr[1]);

      if (isset(expr[2])) {
        Parser.value += ',';
        parseValue(expr[2]);
      }
    }
  }
  function parseWait(expr) {
    Parser.value += 'wait ';
    parseValue(expr[1]);
    Parser.value += ' then\n';
    parseBlock(expr[2]);
    tab();
    Parser.value += 'end';
  }
  function parsePlay(expr) {
    Parser.value += 'play ';
    parseValue(expr[1]);
    if (expr[2]) {
      Parser.value += ' then\n';
      parseBlock(expr[2]);
      tab();
      Parser.value += 'end';
    }
  }

  function parseWindow(expr) {
    Parser.value += 'window at ';
    var rect = expr[1];
    parseValue(rect[1]);
    for (var i=2; i<rect.length; i++) {
      Parser.value += ',';
      parseValue(rect[i]);
    }
  }
  function parseLabel(expr) {
    Parser.value += 'label ';
    parseValue(expr[1]);
    Parser.value += ' at ';
    var rect = expr[2];
    parseValue(rect[1]);
    for (var i=2; i<rect.length; i++) {
      Parser.value += ',';
      parseValue(rect[i]);
    }
  }
  function parseFill(expr) {
    Parser.value += 'fill ';
    parseValue(expr[1]);
    Parser.value += ' at ';
    var rect = expr[2];
    parseValue(rect[1]);
    for (var i=2; i<rect.length; i++) {
      Parser.value += ',';
      parseValue(rect[i]);
    }
  }

  function parseInvert(expr) {
    Parser.value += 'invert';
  }
  function parseHide(expr) {
    Parser.value += 'hide';
  }
  function parseDraw(expr) {
    Parser.value += 'draw ';
    parseValue(expr[1]);
    Parser.value += ' at ';
    var xy = expr[2];
    parseValue(xy[1]);
    Parser.value += ',';
    parseValue(xy[2]);
  }
  function parseGoto(expr) {
    Parser.value += 'goto ';
    var xy = expr[1];
    parseValue(xy[1]);
    Parser.value += ',';
    parseValue(xy[2]);

    if (expr[2]) {
      Parser.value += ' in ';
      parseValue(expr[2]);
    }
  }
  function parseMimic(expr) {
    Parser.value += 'mimic ';
    parseValue(expr[1]);
  }

  function parseIgnore(expr) {
    Parser.value += 'ignore';
  }
  function parseListen(expr) {
    Parser.value += 'listen';
  }

  function parseLoop(expr) {
    Parser.value += 'loop ';
    parseValue(expr[1]);
  }
  function parseOnce(expr) {
    Parser.value += 'once ';
    parseValue(expr[1]);
    if (expr[2]) {
      Parser.value += ' then\n';
      parseBlock(expr[2]);
      tab();
      Parser.value += 'end';
    }
  }
  function parseStop(expr) {
    Parser.value += 'stop';
  }
  function parseBpm(expr) {
    Parser.value += 'bpm ';
    parseValue(expr[1]);
  }
  function parseSound(expr) {
    Parser.value += 'sound ';
    parseValue(expr[1]);
  }

  function parseStore(expr) {
    Parser.value += 'store ';
    parseValue(expr[1]);
  }
  function parseRestore(expr) {
    Parser.value += 'restore';
    if (expr.length>1) {
      Parser.value += ' ';
      parseValue(expr[1]);
    }
  }
  function parseToss(expr) {
    Parser.value += 'toss';
    if (expr.length>1) {
      Parser.value += ' ';
      parseValue(expr[1]);
    }
  }

  function parseCrop(expr) {
    Parser.value += 'crop to ';
    var rect = expr[1];
    parseValue(rect[1]);
    for (var i=2; i<rect.length; i++) {
      Parser.value += ',';
      parseValue(rect[i]);
    }
  }

  function parseEmbed(expr) {
    Parser.value += 'embed:'+expr[1];
  }
  function parseComment(expr) {
    if (expr[0]=='#') { // stand alone comment
      Parser.value += '// ' + json.__comments[expr[1]];
    }
    else { // trailing comment
      Parser.value = Parser.value.replace(/\n\s*$/, ' // ' + json.__comments[expr[1]]);
    }
  }

  function parseDone(expr) {
    Parser.value += 'done';
  }

  // TODO: keep me in sync
  Parser.syntax = {
    get: parseGet,
    set: parseSet,
    lpad:parsePadLeft,
    rpad:parsePadRight,
    format: parseFormat,
    random: parseRandom,
    floor: parseFloor,
    ceil: parseCeil,
    round: parseRound,

    sine: parseSine,
    cosine: parseCosine,
    tangent: parseTangent,
    degrees: parseDegrees,
    radians: parseRadians,

    solid: parseSolid,
    type: parseType,
    name: parseName,

    block: parseBlock,
    while: parseWhile,
    if: parseIf,

    eq: parseEq,
    neq:parseNeq,
    gt: parseGt,
    lt: parseLt,
    gte: parseGte,
    lte: parseLte,
    xy:parseXY,
    rect:parseRect,

    inc: parseInc,
    dec: parseDec,
    add: parseAdd,
    sub: parseSub,
    mul: parseMul,
    div: parseDiv,

    act: parseAct,
    log: parseLog,
    dump:parseDump,
    say: parseSay,
    ask: parseAsk,
    option:parseOption,
    call: parseCall,
    swap:parseSwap,
    emit: parseEmit,
    tell: parseTell,
    frame: parseFrame,
    shake: parseShake,
    wait: parseWait,
    play: parsePlay,

    window: parseWindow,
    label: parseLabel,
    fill: parseFill,
    menu: parseMenu,

    ignore: parseIgnore,
    listen: parseListen,

    fin: parseFin,
    invert: parseInvert,
    hide: parseHide,
    draw: parseDraw,
    goto: parseGoto,
    mimic: parseMimic,
    embed: parseEmbed,

    loop:parseLoop,
    once:parseOnce,
    stop:parseStop,
    bpm:parseBpm,
    sound:parseSound,

    store:parseStore,
    restore:parseRestore,
    toss:parseToss,

    crop:parseCrop,

    done:parseDone,

    '#': parseComment,
    '#$': parseComment,
  };

  for (var i=0; i<json.__srcOrder.length; i++) {
    var eventName = json.__srcOrder[i];

    if (typeof(eventName)=='number') { // top-level comment or newline
      if (eventName==-1) {
        Parser.value += '\n';
      }
      else {
        Parser.value += '// ' + json.__comments[eventName] + '\n';
      }
      continue;
    }

    startEvent(eventName);
    parseBlock(json[eventName]);
    endEvent();
  }

  return Parser.value;
}
function ps2json(psString) {
  var Parser = {
    error: null,
    line: -1,
    json: {
      __srcOrder:[], // NOTE: integer values are indexes in __comments?
      __comments:[],
      __blocks:[],
    },
    blocks: [],
    block: null,
  };
  function parseError(error) {
    if (!Parser.error) Parser.error = error+' on line '+Parser.line;
    return null;
  }

  function validVar(value) {
    return value!=null && typeof value=='object' && (
      (value.length==2 && value[0]=='get' && value[1].match(/^(?:(?:event|config|datetime)\.)?[a-zA-Z_][a-zA-Z0-9_]*$/)) ||
      (value.length>=2 && value[0]=='format')
    );
  }
  function validNum(value) {
    return validVar(value) || (value!=null && typeof value=='number');
  }
  function validStr(value) {
    return validVar(value) || (value!=null && typeof value=='string');
  }
  function validArr(value, min,max) {
    if (min==1 && validNum(value)) return true;

    if (value!=null && typeof value=='object') {
      if (value[0]=='xy' || value[0]=='rect') { // TODO: is this distinction necessary at this point? kinda?
        min += 1;
        max += 1;
        for (var i=1; i<value.length; i++) {
          if (i>=max || (!validNum(value[i]) && i<min)) return false;
        }
        return true;
      }
    }
    return false;
  }
  function validXY(value) {
    return validArr(value,1,2);
  }
  function validRect(value) {
    return validArr(value,1,4);
  }

  // compile-time detection of invalid object name or ids
  // NOTE: can only validate name or id, not vars or formatted strings
  function validTile(value) {
    if (value==null) return false;
    switch(typeof value) {
      case 'number': return !!data.tiles[value];
      case 'string': return getByName('tile', value)!=-1;
      default: return validVar(value) || validXY(value);
    }
  }
  function validRoom(value) {
    if (value==null) return false;
    switch(typeof value) {
      case 'number': return !!data.rooms[value];
      case 'string': return getByName('room', value)!=-1;
      default: return validVar(value);
    }
  }
  function validSong(value) {
    if (value==null) return false;
    switch(typeof value) {
      case 'number': return !!data.songs[value];
      case 'string': return getByName('song', value)!=-1;
      default: return validVar(value);
    }
  }
  function validSound(value) {
    if (value==null) return false;
    switch(typeof value) {
      case 'number': return !!data.sounds[value];
      case 'string': return getByName('sound', value)!=-1;
      default: return validVar(value);
    }
  }

  function newBlock() {
    var blockId = Parser.json.__blocks.length;
    Parser.json.__blocks.push([
      ['_', Parser.line],
    ]);
    return ['block', blockId];
  }
  function getBlock(blockId) {
    return Parser.json.__blocks[blockId];
  }
  function pushBlock(block) {
    Parser.blocks.push(block);
    Parser.block = block;
  }
  function popBlock() {
    if (Parser.blocks.length==0) return parseError('Unexpected end');
    Parser.blocks.pop();
    Parser.block = Parser.blocks[Parser.blocks.length-1];
  }
  function currentBlock() { // returns the array part of the block
    if (!Parser.block) {
      parseError('Expected event declaration');
      return [];
    }
    var blockType = Parser.block[0];
    if (blockType=='block' || blockType=='else') {
      return getBlock(Parser.block[1]);
    }
    else { // if\elseif
      return getBlock(Parser.block[2]);
    }
  }
  function matchingBlock(match, requester) {
    var re = new RegExp('^'+match+'$');
    for (var i=Parser.blocks.length-1; i>=0; i--) {
      var block = Parser.blocks[i];
      if (block[0].match(re)) return block;
    }
    return parseError('Unexpected '+requester);
  }

  function parseValue(value) {
    var tvalue = value.trim();
    var quotedString = tvalue.match(/^".*"$/s)!=null;
    var tm; // used to report invalid calls to functions with identical signatures by name

    // full matches
    if (tvalue=='') {
      value = parseError('Missing value');
    }
    else if (tm=tvalue.match(/^(floor|ceil|round|sine|cosine|tangent|degrees|radians)\s+/)) { // single arg
      var match = tvalue.match(/^(floor|ceil|round|sine|cosine|tangent|degrees|radians)\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|-?(?:[0-9]+)?\.?[0-9]+)\s*$/)
      if (match) value = [match[1], parseValue(match[2])];
      else value = parseError(`Invalid ${tm[1]} call`);
    }
    else if (tvalue.match(/^invert$/)) { // no arg
      // see also parseInvert() below
      value = ['invert'];
    }
    else if (tvalue.match(/^frame\b/)) { // one or more arg
      var match = tvalue.match(/^frame(?:\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*,\s*((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+))?\s*$/)
      if (match!=null) {
        value = ['frame'];
        if (isset(match[2])) {
          var xy = ['xy'];
          xy.push(parseValue(match[1]));
          xy.push(parseValue(match[2]));
          if (!validTile(xy)) value = parseError('Invalid tile identifier');
          else {
            value.push(xy[1]);
            value.push(xy[2]);
          }
        }
        else if (isset(match[1])) { // single arg is the setter
          value = parseError('Invalid frame call');
        }
      }
      else {
        value = parseError('Invalid frame call');
      }
    }
    else if (tvalue.match(/^random\s+/)) {
      var match = tvalue.match(/^random\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)(?:\s*,\s*((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+))?\s*$/)
      if (match) {
        value = ['random', parseValue(match[1])];
        if (match[2]) {
          value.push(parseValue(match[2]));
        }
      }
      else {
        value = parseError('Invalid random call');
      }
    }
    else if (tm=tvalue.match(/^(name)\s+/)) { // only accepts coords or id
      var match = tvalue.match(/^(name)\s+(((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*,\s*((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)|[0-9]+)\s*$/);
      if (match!=null) {
        var tile = parseValue(match[2]);
        value = validTile(tile) ? [match[1], tile] : parseError('Invalid tile identifier');
      }
      else value = parseError(`Invalid ${tm[1]} call`);
    }
    else if (tm=tvalue.match(/^(solid|type)\s+/)) { // accept coords, id, or name
      var match = tvalue.match(/^(solid|type)\s+(((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*,\s*((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)|[0-9]+|"[^"]+")\s*$/);
      if (match) {
        var tile = parseValue(match[2]);
        value = validTile(tile) ? [match[1], tile] : parseError('Invalid tile identifier');
      }
      else value = parseError(`Invalid ${tm[1]} call`);
    }
    else if (value.match(/^-?(?:[0-9]+)?\.?[0-9]+$/)) {
      value = parseFloat(value); // extract numbers
    }
    else if (quotedString) {
      value = value.substring(1,value.length-1); // remove quotes
      if (value.match(/\{[^\}]+\}/)) { // may have replacements
        var text = value;
        var i = 0;
        var tab = ['format'];
        var f;
        var p;
        var escaped = false;
        var captured = false;
        var replaced = false;
        for (var k=0; k<text.length; k++) {
          var s = text.charAt(k);
          if (s=='\\') {
            escaped = true;
            f = text.substring(i,k);
            if (f!='') tab.push(f);
            i = k+1;
            continue;
          }
          if (escaped && s!='{' && s!='}') {
            tab.push('\\');
          }
          else if (s=='{' && !escaped && text.substring(k,text.length).match(/[^\\]\}/)) {
            f = text.substring(i,k);
            if (f!='') tab.push(f);
            i = k+1;
            captured = true
          }
          else if (captured && s=='}' && !escaped) {
            f = text.substring(i,k);
            if (f!='') {
              if (f.match(/^embed:.+/)) {
                var tileIdent = f.substring(6,f.length);
                var tileId = parseInt(tileIdent);
                if (!isNaN(tileId)) {
                  tileIdent = tileId;
                }
                tab.push(['embed', tileIdent]);
              }
              else {
                if (p=f.match(/^([0-9]+),([^:]+):(.+)$/)) {
                  tab.push(['lpad', ['get', p[3]], parseInt(p[1]),p[2]]);
                }
                else if (p=f.match(/^([^:]+):([0-9]+),(.+)$/)) {
                  tab.push(['rpad', ['get', p[1]], parseInt(p[2]),p[3]]);
                }
                else tab.push(['get', f]);
              }
              replaced = true;
            }
            i = k+1;
            captured = false;
          }
          escaped = false;
        }
        f = text.substring(i,text.length);
        if (f!='') tab.push(f);

        if (replaced) value = tab; // truly positive
        else {
          // false positive, kinda
          // remove slashes since they're not
          // necessary in unformatted strings
          value = value.replace(/\\(\{|\})/g, '$1');
        }
      }
    }
    else if (value.match(/,/)) { // geometry
      value = [];
      var parts = tvalue.split(/\s*,\s*/);

      if (parts.length==2) value.push('xy');
      else value.push('rect');

      for (var i=0; i<parts.length; i++) {
        var val = parseValue(parts[i]);
        if (val==null) {
          value = null;
          break;
        }
        value.push(val);
      }
    }
    // invalid syntax (for now)
    else if (tvalue.match(/\s*=\s*/)) {
      value = parseError('Invalid assignment');
    }
    else if (tm=tvalue.match(/\s*([-+*\/])\s*/)) {
      value = parseError(`Unsupported arithmetic expression (use '${tm[1]}=' instead)`);
    }
    else if (tvalue.match(/^\(/)) {
      value = parseError('Unsupported parenthetical expression');
    }
    else {
      value = ["get", value]; // identify varnames
    }
    return value;
  }
  function parseCondition(condition) {
    // TODO: this only supports variables on the left, so you can't do `if 3==var then`
    var parts = condition.match(/^((?:(?:event|config|datetime)\.)?[a-zA-Z_][a-zA-Z0-9_]*)\s*([!=<>]+)\s*(.+)$/);
    if (!parts) return parseError('Invalid condition');
    var types = {
      '==':'eq',
      '!=':'neq',
      '>':'gt',
      '>=':'gte',
      '<':'lt',
      '<=':'lte',
    };
    var type = types[parts[2]];
    if (!type) return parseError('Invalid condition');

    var varname = parts[1];
    var value = parseValue(parts[3]);

    return [type,varname,value];
  }

  function parseWhile(line) {
    var cond = line.match(/^while\s+(.+)\s+do$/);
    if (!cond) return parseError('Invalid while statement');
    cond = cond[1];

    var block = currentBlock();
    if (!block) return;

    var whileBlock = ['while', parseCondition(cond), newBlock()];
    block.push(whileBlock);

    pushBlock(whileBlock[2]);
  }
  function parseIf(line) {
    var cond = line.match(/^if\s+(.+)\s+then$/);
    if (!cond) return parseError('Invalid if statement');
    cond = cond[1];

    var block = currentBlock();
    if (!block) return;

    var ifBlock = ['if', parseCondition(cond), newBlock()];
    block.push(ifBlock);

    pushBlock(ifBlock);
    pushBlock(ifBlock[2]);
  }
  function parseElseIf(line) {
    popBlock(); // clean up from previous if/elseif
    var cond = line.match(/^elseif\s+(.+)\s+then$/);
    if (!cond) return parseError('Invalid elseif statement');

    var ifBlock = matchingBlock('if','elseif');
    if (!ifBlock) return;

    var elseIfBlock = ['elseif', parseCondition(cond[1]), newBlock()];
    ifBlock.push(elseIfBlock);
    pushBlock(elseIfBlock[2]);
  }
  function parseElse(line) {
    popBlock(); // clean up from previous if/elseif
    var ifBlock = matchingBlock('if','elseif');
    if (!ifBlock) return;

    var cond = line.match(/^else$/);
    if (!cond) {
      if (line.match(/^else\s+if/)) return parseError('Invalid else statement (did you mean elseif?)');
      else return parseError('Invalid else statement');
    }

    var elseBlock = ['else', newBlock()];
    ifBlock.push(elseBlock);
    pushBlock(elseBlock[1]);
  }
  function parseOn(line) {
    var event = line.match(/^on\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+do$/);
    if (!event) return parseError('Invalid event declaration');
    event = event[1];

    if (Parser.json[event]) return parseError('Duplicate event declaration');
    Parser.json.__srcOrder.push(event);
    var onBlock = newBlock();
    Parser.json[event] = onBlock;
    pushBlock(onBlock);
  }
  function parseAct(line) {
    var block = currentBlock()
    if (!block) return;
    block.push(['act']);
  }
  function parseTell(line) {
    // TODO: this (and functions like it) are too prescriptive with their arguments
    // var match = line.match(/^tell\s+(((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*,\s*((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)|[0-9]+|"[^"]+"|event\.(game|room))\s+to$/);
    var match = line.match(/^tell\s+(.+)\s+to$/);
    if (!match) return parseError('Invalid tell statement');

    var block = currentBlock();
    if (!block) return;

    var tile = parseValue(match[1]);
    if (!validTile(tile)) return parseError('Invalid tile identifier');

    var tell = ['tell', tile, newBlock()];
    block.push(tell);
    pushBlock(tell[2]);
  }
  function parseEnd(line) {
    popBlock();
    // NOTE: ifBlocks interject themselves between their
    // parent and their actual block so elseif and else
    // can append themselves...so double-pop!
    if (Parser.block) {
      var blockName = Parser.block[0];
      if (blockName.match(/(if|ask|menu)/)) {
        if (blockName.match(/(ask|menu)/)) {
          if (Parser.block[2].length<1) { // NOTE: this can't really be enforced since we allow conditional options
            return parseError(`Invalid ${blockName} statement (expected at least one option)`);
          }
        }
        popBlock();
      }
    }
  }

  function parseSay(line) {
    var match = decodeStringMatch(line, /^say\s+("[^"]+")(?:\s+at\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*(?:,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)){1,3}))?(\s+then)?$/);
    if (!match) return parseError('Invalid say statement');

    var block = currentBlock();
    if (!block) return;
    var value = parseValue(match[1]);
    var say = ['say', value];

    block.push(say);
    if (match[3]) { // has then clause
      say.push(newBlock());
      pushBlock(say[2]);
    }
    else {
      if (match[2]) say.push(null);
    }

    if (match[2]) {
      var rect = parseValue(match[2]);
      say.push(rect);
    }
  }
  function parseAsk(line) {
    var match = decodeStringMatch(line, /^ask\s+("[^"]+")(?:\s+at\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*(?:,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)){1,3}))?\s+then$/);
    if (!match) return parseError('Invalid ask statement');

    var block = currentBlock();
    if (!block) return;

    var value = parseValue(match[1]);
    var ask = ['ask', value, newBlock()];
    block.push(ask);
    pushBlock(ask);
    pushBlock(ask[2]);
    if (match[2]) {
      var rect = parseValue(match[2]);
      ask.push(rect);
    }
  }
  function parseFin(line) {
    var match = decodeStringMatch(line, /^fin\s+("[^"]+")(?:\s+at\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*(?:,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)){1,3}))?$/);
    if (!match) return parseError('Invalid fin statement');

    var block = currentBlock();
    if (!block) return;

    var value = parseValue(match[1]);
    var fin = ['fin', value];
    block.push(fin);
    if (match[2]) {
      var rect = parseValue(match[2]);
      fin.push(rect);
    }
  }

  function parseMenu(line) {
    var match = line.match(/^(menu)\s+at\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*(?:,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)){1,3})\s+then$/);
    if (!match) return parseError('Invalid menu statement');

    var block = currentBlock();
    if (!block) return;

    var rect = parseValue(match[2]);
    var menu = [match[1],rect,newBlock()];
    block.push(menu);
    pushBlock(menu);
    pushBlock(menu[2]);
  }
  function parseOption(line) {
    var str = decodeStringMatch(line, /^option\s+("[^"]+")\s+then/);
    if (!str) return parseError('Expected non-empty double-quoted string');

    var block = currentBlock();
    if (!block) return;

    var hostBlock = matchingBlock('(ask|menu)','option');
    if (!hostBlock) return;

    var value = parseValue(str[1]);
    var optionBlock = ['option', value, 0, newBlock()];
    block.push(optionBlock);
    pushBlock(optionBlock[3]);
  }
  function parseLog(line) {
    var str = decodeStringMatch(line, /^log\s+("[^"]+")$/);
    if (!str) return parseError('Expected non-empty double-quoted string');

    var block = currentBlock();
    if (!block) return;
    block.push(['log', parseValue(str[1])]);
  }
  function parseDump(line) {
    var block = currentBlock()
    if (!block) return;
    block.push(['dump']);
  }
  function parseCall(line) {
    var event = line.match(/^call\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|"[^"]+")$/);
    if (!event) return parseError('Invalid call statement');
    var block = currentBlock()
    if (!block) return;
    block.push(['call', parseValue(event[1])]);
  }
  function parseEmit(line) {
    var event = line.match(/^emit\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|"[^"]+")$/);
    if (!event) return parseError('Invalid emit statement');
    event = parseValue(event[1]);
    var block = currentBlock()
    if (!block) return;
    block.push(['emit', event]);
  }
  function parseSwap(line) {
    var swap = line.match(/^swap\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"[^"]+")$/);
    if (!swap) return parseError('Invalid swap statement');

    var tile = parseValue(swap[1]);
    if (!validTile(tile)) return parseError('Invalid tile identifier');

    var block = currentBlock();
    if (!block) return;
    block.push(['swap', tile]);
  }
  function parseFrame(line) { // setter only, getter is in parseValue :disappointed
    var frame = line.match(/^frame\s+([0-9]+|(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*)$/);
    if (!frame) return parseError('Invalid frame statement');
    frame = parseValue(frame[1]);
    var block = currentBlock();
    if (!block) return;
    block.push(['frame', frame]);
  }

  function parseShake(line) {
    var match = line.match(/^shake\s+((?:[0-9]+)?\.?[0-9]+|(?:(?:event|config|datetime)\.)?[a-zA-Z_][a-zA-Z0-9_]*)(\s+then)?$/);
    if (!match) return parseError('Invalid shake statement');

    var block = currentBlock();
    if (!block) return;
    var dur = parseValue(match[1]);

    var shake = ['shake', dur];
    block.push(shake);
    if (match[2]) {
      shake.push(newBlock());
      pushBlock(shake[2]);
    }
  }
  function parseWait(line) {
    var dur = line.match(/^wait\s+((?:[0-9]+)?\.?[0-9]+|(?:(?:event|config|datetime)\.)?[a-zA-Z_][a-zA-Z0-9_]*)\s+then$/);
    if (!dur) return parseError('Invalid wait statement');

    var block = currentBlock();
    if (!block) return;

    dur = parseValue(dur[1]);

    var wait = ['wait', dur];
    block.push(wait);
    wait.push(newBlock());
    pushBlock(wait[2]);
  }
  function parsePlay(line) {
    var str = line.match(/^play\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"[^"]+")(\s+then)?$/);
    if (!str) return parseError('Invalid play statement');

    var tile = parseValue(str[1]);
    if (!validTile(tile)) return parseError('Invalid tile identifier');

    var block = currentBlock();
    if (!block) return;

    var play = ['play', tile];
    block.push(play);
    if (str[2]) { // has then clause
      play.push(newBlock());
      pushBlock(play[2]);
    }
  }

  function parseWindow(line) {
    var match = line.match(/^window\s+at\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*(?:,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)){1,3})$/);
    if (!match) return parseError('Invalid window statement');

    var block = currentBlock();
    if (!block) return;

    var rect = parseValue(match[1]);
    var win = ['window', rect];
    block.push(win);
  }
  function parseLabel(line) {
    var match = decodeStringMatch(line, /^label\s+("[^"]+")\s+at\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*(?:,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)){1,3})$/);
    if (!match) return parseError('Invalid label statement');

    var block = currentBlock();
    if (!block) return;

    var text = parseValue(match[1])
    var rect = parseValue(match[2]);
    var label = ['label', text, rect];
    block.push(label);
  }
  function parseFill(line) {
    var match = line.match(/^fill\s+("[^"]+")\s+at\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*(?:,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)){1,3})$/);
    if (!match) return parseError('Invalid fill statement');

    var block = currentBlock();
    if (!block) return;

    var color = parseValue(match[1])
    var rect = parseValue(match[2]);
    var fill = ['fill', color, rect];
    block.push(fill);
  }

  function parseIgnore(line) {
    var block = currentBlock()
    if (!block) return;
    block.push(['ignore']);
  }
  function parseListen(line) {
    var block = currentBlock()
    if (!block) return;
    block.push(['listen']);
  }

  function parseLoop(line) {
    var str = line.match(/^loop\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"[^"]+")$/);
    if (!str) return parseError('Invalid loop statement');

    var song = parseValue(str[1]);
    if (!validSong(song)) return parseError('Invalid song identifier');

    var block = currentBlock()
    if (!block) return;
    block.push(['loop', song]);
  }
  function parseOnce(line) {
    var str = line.match(/^once\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"[^"]+")(\s+then)?$/);
    if (!str) return parseError('Invalid once statement');

    var song = parseValue(str[1]);
    if (!validSong(song)) return parseError('Invalid song identifier');

    var block = currentBlock();
    if (!block) return;
    var once = ['once', song];
    block.push(once);
    if (str[2]) { // has then clause
      once.push(newBlock());
      pushBlock(once[2]);
    }
  }
  function parseStop(line) {
    var block = currentBlock()
    if (!block) return;
    block.push(['stop']);
  }
  function parseBpm(line) {
    var bpm = line.match(/^bpm\s+([0-9]+|(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*)$/);
    if (!bpm) return parseError('Invalid bpm statement');
    bpm = parseValue(bpm[1]);
    var block = currentBlock();
    if (!block) return;
    block.push(['bpm', bpm]);
  }
  function parseSound(line) {
    // NOTE: priority has been removed but we still want to match it in case it already exists in the source, it will be stripped next time it's viewed
    var str = line.match(/^sound\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"[^"]+")(?:\s+priority\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+))?$/);
    if (!str) return parseError('Invalid sound statement');

    var snd = parseValue(str[1]);
    if (!validSound(snd)) return parseError('Invalid sound identifier');

    var block = currentBlock()
    if (!block) return;
    var sound = ['sound', snd];
    block.push(sound);
  }

  function parseInvert(line) {
    // also handled in parseValue because it returns the current invert flag
    var block = currentBlock()
    if (!block) return;
    block.push(['invert']);
  }
  function parseHide(line) {
    var block = currentBlock()
    if (!block) return;
    block.push(['hide']);
  }
  function parseDraw(line) {
    var match = line.match(/^draw\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"[^"]+")\s+at\s+(((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*,\s*((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+))$/);
    if (!match) return parseError('Invalid draw statement');

    var block = currentBlock();
    if (!block) return;

    var tile = parseValue(match[1]);
    if (!validTile(tile)) return parseError('Invalid tile identifier');

    var xy = parseValue(match[2]);
    var draw = ['draw', tile, xy];
    block.push(draw);
  }
  function parseGoto(line) {
    var match = line.match(/^goto\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+))(?:\s+in\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"[^"]+"))?$/);
    if (!match) return parseError('Invalid goto statement');

    var block = currentBlock();
    if (!block) return;

    var xy = parseValue(match[1]);
    var goto = ['goto', xy];
    if (isset(match[2])) {
      var room = parseValue(match[2]);
      if (!validRoom(room)) return parseError('Invalid room identifier');
      goto.push(room);
    }
    block.push(goto);
  }
  function parseMimic(line) {
    var str = line.match(/^mimic\s+((?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+|"[^"]+")$/);
    if (!str) return parseError('Invalid mimic statement');

    var tile = parseValue(str[1]);
    if (!validTile(tile)) return parseError('Invalid tile identifier');

    var block = currentBlock();
    if (!block) return;

    block.push(['mimic', tile]);
  }

  function parseStore(line) {
    var str = decodeStringMatch(line, /^store\s+("[^"]+")$/);
    if (!str) return parseError('Expected non-empty double-quoted string');

    var block = currentBlock();
    if (!block) return;

    block.push(['store', parseValue(str[1])]);
  }
  function parseRestore(line) {
    var str = decodeStringMatch(line, /^restore(?:\s+("[^"]+"))?$/);
    if (!str) return parseError('Expected non-empty double-quoted string');

    var block = currentBlock();
    if (!block) return;

    var restore = ['restore'];
    if (str[1]) {
      restore.push(parseValue(str[1]));
    }
    block.push(restore);
  }
  function parseToss(line) {
    var str = decodeStringMatch(line, /^toss(?:\s+("[^"]+"))?$/);
    if (!str) return parseError('Expected non-empty double-quoted string');

    var block = currentBlock();
    if (!block) return;

    var toss = ['toss'];
    if (str[1]) {
      toss.push(parseValue(str[1]));
    }
    block.push(toss);
  }

  function parseCrop(line) {
    var match = line.match(/^crop\s+to\s+((?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)\s*(?:,\s*(?:(?:event\.)?[a-zA-Z_][a-zA-Z0-9_]*|[0-9]+)){1,3})$/);
    if (!match) return parseError('Invalid crop statement');

    var block = currentBlock();
    if (!block) return;

    var rect = parseValue(match[1]);
    var crop = ['crop', rect];
    block.push(crop);
  }

  function parseDone(line) {
    var block = currentBlock()
    if (!block) return;
    block.push(['done']);
  }

  function parseExpression(line) {
    var parts = decodeStringMatch(line, /^((?:config\.)?[a-zA-Z_][a-zA-Z0-9_]*)\s*(=|[-+*\/]=|\+\+|--)\s*(.*)$/);
    if (!parts) return parseError('Invalid expression');

    var types = {
      '=':'set',
      '+=':'add',
      '-=':'sub',
      '*=':'mul',
      '/=':'div',
      '++':'inc',
      '--':'dec',
    };
    var type = types[parts[2]];
    if (!type) return parseError('Invalid expression');

    var varname = parts[1];
    var value = type.match(/^(inc|dec)$/) ? null : parseValue(parts[3]);
    var expr = [type,varname];

    if (!isset(value)) {
      if (type!='inc' && type!='dec') return parseError('Invalid '+type+' expression');
    }
    else {
      if (type=='inc' || type=='dec') return parseError('Invalid '+type+' expression');
      expr.push(value);
    }

    var block = currentBlock();
    if (!block) return;
    block.push(expr);
  }
  function parseLine(line) {
    if (line=='') {
      if (Parser.block) {
        var block = currentBlock();
        block.push(-1);
      }
      return;
    }

    // stand alone comments
    var comment = line.match(/^\/\/\s*(.*)$/);
    if (comment) {
      var comments = Parser.json.__comments;
      var commentId = comments.length;
      comments.push(comment[1]);

      if (!Parser.block) { // top-level
        Parser.json.__srcOrder.push(commentId);
      }
      else { // block-level
        var block = currentBlock()
        if (!block) return;
        block.push(['#', commentId]);
      }
      return;
    }

    // trailing comments
    comment = line.match(/\s*\/\/\s*(.*)$/);
    if (comment) {
      line = line.replace(comment[0], '');
    }

    var action = line.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
    if (!action) return parseError('Invalid expression');
    action = action[0];

    if (Parser.syntax[action]) {
      Parser.syntax[action](line);
    }
    else {
      parseExpression(line);
    }

    if (comment) {
      var comments = Parser.json.__comments;
      var commentId = comments.length;
      comments.push(comment[1]);
      var block = currentBlock()
      if (!block) return;
      block.push(['#$', commentId]);
    }
  }

  // TODO: keep me in sync
  Parser.syntax = {
    on: parseOn,
    while: parseWhile,
    if: parseIf,
    elseif: parseElseIf,
    else: parseElse,
    end: parseEnd,

    act: parseAct,
    log: parseLog,
    dump: parseDump,
    say: parseSay,
    ask: parseAsk,
    option: parseOption,
    swap: parseSwap,
    call: parseCall,
    emit: parseEmit,
    tell: parseTell,
    frame: parseFrame,
    shake: parseShake,
    wait: parseWait,
    play: parsePlay,

    window: parseWindow,
    label: parseLabel,
    fill: parseFill,
    menu: parseMenu,

    ignore: parseIgnore,
    listen: parseListen,
    fin: parseFin,
    invert: parseInvert,
    hide: parseHide,
    draw: parseDraw,
    goto: parseGoto,
    mimic: parseMimic,

    loop: parseLoop,
    once: parseOnce,
    stop: parseStop,
    bpm:parseBpm,
    sound: parseSound,

    store:parseStore,
    restore:parseRestore,
    toss:parseToss,

    crop:parseCrop,

    done:parseDone,
  };

  try {
    var lines = psString.split(/\n/);
    for (var i=0; i<lines.length; i++) {
      Parser.line = i+1;
      parseLine(lines[i].trim());
      if (Parser.error) break;
    }
  }
  catch (error) {
    // NOTE: this can happen when there's an unhandled
    // error in my JavaScript parsing code, eg. assuming
    // a string.match() result always succeeds o_O;
    parseError('Uncaught JavaScript Parser error');
    print(error);
    print(Parser);
  }

  if (!Parser.error && Parser.block) {
    parseError('Unexpected end of script');
  }

  if (Parser.error) {
    return { error: Parser.error };
  }
  else {
    return { json: Parser.json };
  }
}

function says2jsonf(str) {
  if (str.match(/\{[^\}]+\}/)) {
    var says = 'on compile do\n\tsay "'+str.replace(/"/g,'\\\"').replace(/\n/g, '\\n')+'"\nend\n\n';
    var json = ps2json(says);
    var actions = json.json.__blocks[0];
    for (var i in actions) {
      if (actions[i][0]=='say') return actions[i][1];
    }
  }
  return str;
}
function jsonf2says(jsonf) {
  var json = {
    __srcOrder:["compile"],
    __comments:[],
    __blocks:[[["say",jsonf]]],
    compile:["block",0],
  };
  var value = json2ps(json).replace(/(^on compile do\n\tsay "|"\nend\n\n$)/g,'').trim();
  value = value.replace(/\\"/g, '"');
  value = value.replace(/\\n/g, '\n');
  value = value.replace(/\\f/g, '\f');
  return value;
}

var textPreviewMeta = {
  tilesWide:0,
  tilesHigh:0,
  isHalfWidth: false,
  data: [],
  embeds: [],
  encodeAB: function(a,b) {
    return a + (b % 96) * 96;
  },
  decodeA: function(i) {
    return i % 96;
  },
  decodeB: function(i) {
    return Math.floor(i / 96);
  },
};

var notes = [ 'C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B' ];
var Note = {}; for (var i=0; i<notes.length; i++) { Note[notes[i]] = i; }
var Frequency = [
  0, // rest
  16.351598,
  17.323914,
  18.354048,
  19.445436,
  20.601722,
  21.826764,
  23.124651,
  24.499715,
  25.956544,
  27.5,
  29.135235,
  30.867706,
  32.703196,
  34.647829,
  36.708096,
  38.890873,
  41.203445,
  43.653529,
  46.249303,
  48.999429,
  51.913087,
  55,
  58.27047,
  61.735413,
  65.406391,
  69.295658,
  73.416192,
  77.781746,
  82.406889,
  87.307058,
  92.498606,
  97.998859,
  103.826174,
  110,
  116.54094,
  123.470825,
  130.812783,
  138.591315,
  146.832384,
  155.563492,
  164.813778,
  174.614116,
  184.997211,
  195.997718,
  207.652349,
  220,
  233.081881,
  246.941651,
  261.625565,
  277.182631,
  293.664768,
  311.126984,
  329.627557,
  349.228231,
  369.994423,
  391.995436,
  415.304698,
  440,
  466.163762,
  493.883301,
  523.251131,
  554.365262,
  587.329536,
  622.253967,
  659.255114,
  698.456463,
  739.988845,
  783.990872,
  830.609395,
  880,
  932.327523,
  987.766603,
  1046.502261,
  1108.730524,
  1174.659072,
  1244.507935,
  1318.510228,
  1396.912926,
  1479.977691,
  1567.981744,
  1661.21879,
  1760,
  1864.655046,
  1975.533205,
  2093.004522,
  2217.461048,
  2349.318143,
  2489.01587,
  2637.020455,
  2793.825851,
  2959.955382,
  3135.963488,
  3322.437581,
  3520,
  3729.310092,
  3951.06641,
  4186.009045,
  4434.922096,
  4698.636287,
  4978.03174,
  5274.040911,
  5587.651703,
  5919.910763,
  6271.926976,
  6644.875161,
  7040,
  7458.620184,
  7902.13282,
];
function getFrequencyIndex(note,octave) {
  return 1 + (octave * 12) + note; // 1 + because 0==Rest
}
function getNoteOctave(frequencyIndex) {
  frequencyIndex -= 1;
  var octave =  Math.floor(frequencyIndex / 12);
  var note = frequencyIndex - (octave * 12);
  return {
    note:note,
    octave:octave,
  };
}

var updateId = null;
function onDataReady() {
  if (isDownloadEnabled) one('body').classList.add('enable-downloads');

  //////////////////////////////////////////////////////////
  // TODO: tmp, update values that have changed during development
  // TODO: I'm a little confused by the distinction between data.version and data.editor.version...
  var updatedData = false
  if (!isset(data.editor.activeScriptId)) {
    data.editor.activeScriptId = 0; // game
    updatedData = true;
  }
  if (!isset(data.editor.recentScripts)) {
    data.editor.recentScripts = [-1];
    updatedData = true;
  }
  if (!isset(data.scripts)) {
    for (var i=0; i<data.tiles.length; i++) {
      var tile = data.tiles[i];
      if (!tile) continue;

      if (isset(tile.isSolid)) {
        print(tile.name+': converting isSolid to solid');
        tile.solid = tile.isSolid;
        delete tile.isSolid;
      }

      if (isset(tile.behaviorType)) {
        print(tile.name+': removing behaviorType');
        if (isset(tile.says) && tile.says.trim()=='') {
          print('- removing empty says');
          delete tile.says;
        }
        if (isset(tile.script) && tile.script.__srcOrder.length==0 && tile.type!=TileType.Player) {
          print('- removing empty script');
          delete tile.script;
        }
        delete tile.behaviorType;
      }
    }
    if (!isset(data.player)) {
      var blessedPlayer = -1;
      for (var i=0; i<data.tiles.length; i++) {
        var tile = data.tiles[i];
        if (!tile) continue;
        if (tile.type==TileType.Player) {
          if (isset(tile.script)) {
            blessedPlayer = i;
            break;
          }
          else if (blessedPlayer==-1) {
            blessedPlayer = i;
          }
        }
      }

      var blessedRoom = -1;
      var x,y;
      for (var i=0; i<data.rooms.length; i++) {
        var room = data.rooms[i];
        if (!room) continue;

        var roomTiles = room.tiles;
        for (var j=0; j<roomTiles.length; j++) {
          var tileId = roomTiles[j];
          var tile = data.tiles[tileId];
          if (tile.type==TileType.Player) {
            y = Math.floor(j / roomTilesWide);
            x = j - (y * roomTilesWide);
            roomTiles[j] = data.background;
            blessedRoom = i;
            break;
          }
        }
        if (blessedRoom>-1) break;
      }

      if (blessedRoom==-1) blessedRoom = 0;

      print('blessing player');
      data.player = {
        room: blessedRoom,
        id: blessedPlayer,
        x: x,
        y: y
      };
    }
    var deletedScripts = false;
    print('deleting inaccessible player scripts');
    for (var i=0; i<data.tiles.length; i++) {
      var tile = data.tiles[i];
      if (!tile) continue;

      if (tile.type==TileType.Player) {
        if (isset(tile.script) && tile.script.__srcOrder.length==0 && tile.id!=data.player.id) {
          print('- removing empty script from non-primary player tile');
          deletedScripts = true;
          delete tile.script;
        }
      }
    }
    if (deletedScripts) data.editor.recentScripts = [-1];
    updatedData = true;
  }
  if (!isset(data.scripts)) {
    print('initializing data.scripts');
    data.scripts = [];

    print('- added game script');
    data.script = addScript(ScriptType.Game,0,data.script);

    print('adding btypes');
    for (var i=0; i<data.tiles.length; i++) {
      var tile = data.tiles[i];
      if (!tile) continue;

      if (isset(tile.script) && tile.script.__srcOrder.length>0) {
        tile.btype = BehaviorType.Script;
        print('- moving script from individual tile to data.scripts');
        tile.script = addScript(ScriptType.Tile,tile.id,tile.script);
      }
      else {
        tile.btype = BehaviorType.Simple;
      }
      validateTileProperties(tile); // NOTE: this should correct btype and delete any unnecessary behavior data
    }

    print('resetting recent scripts');
    data.editor.activeScriptId = 0;
    data.editor.recentScripts = [0]; // reset b
    updatedData = true;
  }
  if (isset(data.start)) {
    delete data.start;
    updatedData = true;
  }

  var firstRoom = data.rooms[0]; // player may have deleted the actual first room
  if (!firstRoom) {
    for (var i=0; i<data.rooms.length; i++) {
      var room = data.rooms[i];
      if (!room) continue;
      firstRoom = room;
      break;
    }
  }
  if (firstRoom.exits.length>0 && isset(firstRoom.exits[0].type)) {
    print('removing exit types');
    for (var i=0; i<data.rooms.length; i++) {
      var room = data.rooms[i];
      if (!room) continue;
      for (var j=0; j<room.exits.length; j++) {
        var exit = room.exits[j];
        if (isset(exit.type)) {
          print('- removed exit.type');
          delete exit.type;
        }
      }
    }
    updatedData = true;
  }

  // added data.version to better track/apply these changes
  if (!isset(data.version) || data.version<0.01) { // added "format" expression to replace strings with replacement braces
    print('updating data format to version 0.01');
    print('- adds support for "format" blocks');
    var fail = false;
    for (var i=0; i<data.scripts.length; i++) {
      var script = data.scripts[i];
      if (!script || !isset(script.data)) continue;

      var ps = json2ps(script.data);
      var json = ps2json(ps);
      var ps2 = json2ps(json.json);
      if (ps!=ps2) {
        print('- bad parse!');
        print(ps,json.json);
        print(ps2);
        fail = true;
        break;
      }
      else if (!isset(json.error)) {
        print('- updated PulpScript')
        script.data = json.json;
      }
      else {
        print('error parsing PulpScript during data update', json.error); // TODO: shouldn't be possible...but
        fail = true;
        break;
      }
    }
    if (fail) {
      alert('Failed to automatically update PulpScript, please see the console.');
    }
    data.version = 0.01;
    updatedData = true;
  }
  if (data.version<0.02) { // tile.says can now be a string or a "format" expression
    print('updating data format to version 0.02');
    for (var i=0; i<data.tiles.length; i++) {
      var tile = data.tiles[i];
      if (!tile) continue;

      if (tile.btype==BehaviorType.Simple && isset(tile.says)) {
        var oldValue = tile.says;
        var newValue = says2jsonf(tile.says);
        if (oldValue!=newValue) {
          print('- updated tile.says to "format" expression', tile.name);
          tile.says = newValue;
        }
      }
    }
    data.version = 0.02;
    updatedData = true;
  }

  if (!isset(data.author)) {
    print('adding author to data');
    if (isset(meta.author)) {
      data.author = meta.author;
    }
    else {
      data.author = 'Pulp';
    }
    updatedData = true;
  }

  if (data.font.pipe.length==9) {
    print('added arrow to font');
    for (var i=0;i<defaultArrowsFrameData.length; i++) {
      data.font.pipe.push(clone(defaultArrowsFrameData[i]));
    }
    updatedData = true;
    print(data.font.pipe);
  }

  if (!isset(data.songs)) {
    print('adding songs to data');
    data.songs = [];
    data.editor.activeSongId = 0;
    data.editor.activeVoiceId = 0;
    data.editor.loopSong = true;

    var id = addSong();
    var song = data.songs[id];
    song.name = 'theme';

    // fix for bloated frame.data (caused by working at less than 100% zoom in browser)
    for (var i=0; i<data.frames.length; i++) {
      var frame = data.frames[i];
      if (!frame || frame.data.length==64) continue;
      if (!updatedData) {
        print('fixing bloated frame.data');
        updatedData = true;
      }
      frame.data.length = 64;
    }

    // fix for misconfigured tile scripts
    updatedData = false;
    for (var i=0; i<data.tiles.length; i++) {
      var tile = data.tiles[i];
      if (!tile) continue;
      if (tile.btype==BehaviorType.Script && !isset(tile.script)) {
        if (!updatedData) {
          print('fixing misconfigured tile scripts');
          updatedData = true;
        }
        tile.script = addScript(ScriptType.Tile, tile.id);
      }
    }

    updatedData = true;
  }

  if (data.version<0.03) {
    print('updating data format to version 0.03');
    data.version = 0.03;
    updatedData = true;
  }

  if (data.version<0.04) {
    print('adding songs to rooms');
    for (var i=0; i<=data.rooms.length; i++) {
      var room = data.rooms[i];
      if (!room) continue;

      room.song = -1;
    }

    data.version = 0.04;
    updatedData = true;
  }
  if (!isset(data.song)) {
    print('adding song to game');
    data.song = -1;
    updatedData = true;
  }

  if (data.version<0.05) {
    print('adding songs to exits');
    for (var i=0; i<data.rooms.length; i++) {
      var room = data.rooms[i];
      if (!room) continue;

      for (var j=0; j<room.exits.length; j++) {
        var exit = room.exits[j];
        if (!exit || getExitType(exit)!=ExitType.Ending) continue;
        exit.song = -1;
      }
    }

    data.version = 0.05;
    updatedData = true;
  }

  if (data.version<1) {
    print('updating data format to version 1');
    data.version = 1;
    updatedData = true;
  }

  if (!isset(data.editor.version)) {
    print('updating editor format to version 1 (adds line numbers to blocks for error reporting)');
    data.editor.version = 1;
    updatedData = true;
    for (var i=0; i<data.scripts.length; i++) {
      if (!script || !isset(script.data)) continue;

      var ps = json2ps(script.data);
      var json = ps2json(ps);
      var ps2 = json2ps(json.json);
      if (ps!=ps2) {
        print('- bad parse!');
        print(ps,json.json);
        print(ps2);
        fail = true;
        break;
      }
      else if (!isset(json.error)) {
        print('- updated PulpScript')
        script.data = json.json;
      }
      else {
        print('error parsing PulpScript during data update', json.error); // TODO: shouldn't be possible...but
        fail = true;
        break;
      }
    }
  }

  if (data.editor.version<2) {
    print('updating editor format to version 2 (adds noise channel to songs)');
    data.editor.version = 2;
    updatedData = true;

    for (var i=0; i<data.songs.length; i++) {
      var song = data.songs[i];
      if (!song) continue;
      song.notes[4] = [];
      song.splits[4] = [];
    }
  }

  if (!isset(data.sounds)) {
    data.sounds = [];
    data.editor.activeSoundId = 0;
    delete data.editor.activeNoteId;

    var id = addSound();
    var sound = data.sounds[id];
    sound.name = 'beep';

    print('adding sounds to data format');
    updatedData = true;
  }

  if (!isset(data.editor.showCard)) {
    data.editor.showCard = false;
    updatedData = true;
  }

  if (!isset(data.intro)) {
    data.intro = '';

    print('adding intro to data format');
    updatedData = true;
  }

  if (!isset(data.card)) {
    data.card = getCardFallback();

    print('adding card to data format');
    updatedData = true;
  }
  if (!isset(data.editor.loopNotes)) {
    print('adding ability to loop just the Notes section in Song mode');
    data.editor.loopNotes = false;
    updatedData = true;
  }

  if (data.font.pipe.length==11) {
    print('added cursor to font');
    for (var i=2;i<defaultArrowsFrameData.length; i++) {
      data.font.pipe.push(clone(defaultArrowsFrameData[i]));
    }
    updatedData = true;
    print(data.font.pipe);
  }
  if (data.font.pipe.length==13) {
    print('added paging to font');
    for (var i=4;i<defaultArrowsFrameData.length; i++) {
      data.font.pipe.push(clone(defaultArrowsFrameData[i]));
    }
    updatedData = true;
    print(data.font.pipe);
  }
  if (!isset(data.editor.highlightTiles)) {
    print('added tile highlighting');
    data.editor.highlightTiles = false;
    updatedData = true;
  }


  if (data.editor.activeVoiceId<0) {
    data.editor.activeVoiceId = 0;
  }

  saveButton = one('#save'); // NOTE: should be set before markDirty()
  if (updatedData) {
    markDirty();
    print('done updating data format, please save');
  }


  //////////////////////////////////////////////////////////
  // reset persistent data
  elapsed = 0;
  frameTimers = {};

  //////////////////////////////////////////////////////////
  var importOverride = false;
  bind(one('#import input'), 'click', function(event) {
    if (!importOverride) {
      event.preventDefault();
      confirmAction(['Are you sure you want to overwrite the current game?','If not, cancel and create a new game before importing.'], 'Continue', function(confirmed) {
        if (!confirmed) return;
        importOverride = true;
        one('#import input').click();
      });
    }
    else {
      importOverride = false;
    }
  });
  bind(one('#import input'), 'change', importJSON);
  bind(one('#export'), 'click', exportJSON);
  bind(one('#download'), 'click', downloadPdx);

  // constants?
  var playButton = one('#play');
  var undoButton = one('#undo');
  var redoButton = one('#redo');

  var scratchCanvas = document.createElement('canvas');
  var scratchContext = scratchCanvas.getContext('2d');

  var frameCanvas = document.createElement('canvas');
  var frameContext = frameCanvas.getContext('2d');
  var frameImage = one('#frame');

  var previewImage = one('#preview');

  var playerCanvas = document.createElement('canvas');
  var playerContext = playerCanvas.getContext('2d');
  playerCanvas.width = tileWidth;
  playerCanvas.height = tileHeight;

  var roomCanvas = document.createElement('canvas');
  var roomContext = roomCanvas.getContext('2d');
  var roomImage = one('#room');
  var roomCursor = one('#room-cursor');

  var highlightCanvas = document.createElement('canvas');
  var highlightContext = highlightCanvas.getContext('2d');
  var highlightImage = one('#highlighted-tiles');

  var fontImage = one('#font');
  var charImage = one('#char');
  var pipeTiles = one('#pipe-tiles');
  var arrowTiles = one('#arrow-tiles');
  var charTiles = one('#char-tiles');

  var charType = one('#char-type');
  var charName = one('#char-name');
  var sampleText = one('#sample-text');
  var customText = one('#custom-text');

  var animationPreview = one('#tile-preview');
  var backgroundTiles = one('#background-tiles');
  var roomTiles = one('#room-tiles');
  var tileFrames = one('#tile-frames');
  var roomSongSelect = one('#room-song-select');

  var gameName = one('#game-name');
  var gameFile = one('#game-file');
  var gameAuthor = one('#game-author');
  var gameIntro = one('#game-intro');
  var gameSongSelect = one('#game-song-select');
  var gameCardSelect = one('#game-card-select');
  var roomName = one('#room-name');
  var tileName = one('#tile-name');
  var scriptName = one('#script-name');
  var behaviorSoundSelect = one('#behavior-sound-select');

  var roomSelect = one('#room-select');
  var scriptSelect = one('#script-select');
  var scriptEventsSelect = one('#script-events-select');

  var tileFps = one('#tile-fps');
  var tileIsSolid = one('#tile-is-solid');
  var tileTypePill = one('#tile-type-pill');

  var layers = one('#layers');
  var modes = one('#modes');

  var exitPane = one('#exit-pane');
  var exitConnection = one('#exit-connection');
  var exitEnding = one('#exit-ending');
  var exitSelect = one('#exit-select');
  var exitImage = one('#exit-room');
  var exitCursor = one('#exit-cursor');
  var exitSays = one('#exit-says');
  var exitSongSelect = one('#exit-song-select');
  var exitTypePill = one('#exit-type-pill');

  var editRoom = one('#edit-room'); // TODO: tmp?

  var behavior = one('#behavior');
  var behaviorTypePill = one('#behavior-type-pill');
  var tileSays = one('#tile-says');

  var editorScrollOffsets = []; // line indexed by scriptId
  var editorCursorOffsets = []; // cursor position indexed by scriptId
  var sharedEditor = one('#shared-editor');
  var acePath = urls.static+'js/ace';
  ace.config.set('basePath', acePath);
  ace.config.set('modePath',acePath);
  ace.config.set('themePath', acePath);

  var autocompleters = [];
  (function() {
    // TODO: keep in sync! see *VarnameMap in runtime.lua
    var suggestions = [];
    var defaultEvents = [
      'load',
      'start',
      'finish',
      'enter',
      'exit',
      'loop',
      'update',
      'bump',
      'confirm',
      'cancel',
      'crank',
      'dock',
      'undock',
      'draw',
      'interact',
      'collect',
      'change',
      'select',
      'dismiss',
      'invalid',
      'any',
    ];
    var eventMembers = [
      'game',
      'name',
      'player',
      'px',
      'py',
      'dx',
      'dy',
      'tx',
      'ty',
      'x',
      'y',
      'tile',
      'room',
      'aa',
      'ra',
      'frame',
      'option',
      'ax',
      'ay',
      'az',
      'orientation',
    ];
    var configMembers = [
      'follow',
      'followOverflowTile',
      'followCenterX',
      'followCenterY',
      'autoAct',
      'inputRepeat',
      'inputRepeatDelay',
      'inputRepeatBetween',
      'allowDismissRootMenu',
      'sayAdvanceDelay',
    ];
    var datetimeMembers = [
      'year',
      'month',
      'day',
      'weekday',
      'hour',
      'minute',
      'second',
      'millisecond',
      'year99',
      'hour12',
      'ampm',
    ];

    autocompleters.push({
      getCompletions: (editor, session, pos, prefix, callback) => {
        // based on https://stackoverflow.com/a/32621466/145965
        // and https://github.com/TouK/nussknacker/blob/v0.0.9/ui/client/components/graph/ExpressionSuggest.js#L31
        // https://github.com/ajaxorg/ace/blob/ccfb820418034c5974191451ce71ac5ec59cc845/lib/ace/ext/language_tools.js#L190

        var line = session.getLine(pos.row);
        var match;

        if (match = line.match(/^o/)) {
          if (line.match(/^on\s+/)) {
            // already in an on statement so just suggest the event name
            callback(null, defaultEvents.map(eventName => {
              return {value: eventName};
            }));
          }
          else if (!line.match(/(^on\s+([a-zA-Z]+)\s+)/)) {
            callback(null, defaultEvents.map(eventName => {
              return {value: `on ${eventName} do`};
            }));
          }
        }
        else if (match = line.match(/^\s*(call|emit)\s+"/)) {
          callback(null, defaultEvents.map(eventName => {
            return {value: eventName};
          }));
        }
          // NOTE: trim line to current cursor position to
          // eliminate false positives when returning and
          // typing before the global name and to allow
        // suggestions when typing inside a string
        else if (match = line.substr(0,pos.column).match(/event\./)) {
          callback(null, eventMembers.map(memberName => {
            return {value: memberName};
          }));
        }
        else if (match = line.substr(0,pos.column).match(/config\./)) {
          callback(null, configMembers.map(memberName => {
            return {value: memberName};
          }));
        }
        else if (match = line.substr(0,pos.column).match(/datetime\./)) {
          callback(null, datetimeMembers.map(memberName => {
            return {value: memberName};
          }));
        }
      }
    });
  })();
  var scriptEditor = ace.edit('script-editor', {
    mode: "ace/mode/pulpscript",
    theme: "ace/theme/twilight",
    tabSize: 2,
    useSoftTabs: true,
    enableSnippets: true,
    behavioursEnabled: true,
    enableLiveAutocompletion: autocompleters,
    showFoldWidgets: false,
  });
  scriptEditor.on('input', function(event) {
    if (scriptEditor.completer && !scriptEditor.completer.exactMatch) {
      scriptEditor.completer.exactMatch = true;
      if (scriptEditor.completer.completions) {
        scriptEditor.completer.completions.exactMatch = true;
      }
    }
  });
  each('#script-editor .ace_scrollbar', function(i, elem) {
    elem.classList.add('scrollable');
  });
  var scriptStatus = one('#script-status');

  var playheadReturn = one('#playhead-return');
  var songLoopFrom = one('#loop-from');

  var sharedModifiers = one('#shared-modifiers');
  var sharedNotes = one('#shared-notes');
  var sharedEnvelope = one('#shared-envelope');

  var notesCanvas = document.createElement('canvas');
  var notesContext = notesCanvas.getContext('2d');
  var notesImage = one('#notes-image');
  var notesCursor = one('#notes-cursor');
  var notesSelect = one('#notes-selection');
  var notesPlayhead = one('#notes-playhead');

  var songCanvas = document.createElement('canvas');
  var songContext = songCanvas.getContext('2d');
  var songImage = one('#song-image');
  var songNotes = one('#song-notes');
  var songNotesTrack = one('#song-notes-track');
  var songPlayhead = one('#song-playhead');
  var songPlayheadTrack = one('#song-playhead-track');
  var songIntro = one('#song-intro');
  var songName = one('#song-name');
  var songBpm = one('#song-bpm');
  var songParts = one('#song-parts');
  var songSelect = one('#song-select');

  var voiceName = one('#voice-name .name');
  var voiceIcon = one('#voice-name .icon');

  var voiceTypePill = one('#voice-type-pill');
  var soundName = one('#sound-name');
  var soundBpm = one('#sound-bpm');
  var soundSelect = one('#sound-select');

  //////////////////////////////////////////////////////////
  // one-time UI setup
  scratchCanvas.width = frameCanvas.width = tileWidth;
  scratchCanvas.height = frameCanvas.height = tileHeight;

  frameImage.width = tileWidth * tileEditorScale;
  frameImage.height = tileHeight * tileEditorScale;

  previewImage.width = roomWidth * 2;
  previewImage.height = roomHeight * 2;

  roomCanvas.width = highlightCanvas.width = roomWidth;
  roomCanvas.height = highlightCanvas.height = roomHeight;
  roomImage.width = highlightImage.width = roomWidth * roomEditorScale;
  roomImage.height = highlightImage.height = roomHeight * roomEditorScale;
  roomCursor.width = tileEditorScale;
  roomCursor.src = spacerDataURL;

  roomTiles.style.maxWidth = (tileWidth * 20 * roomEditorScale) + 'px';

  exitImage.width = roomWidth * exitEditorScale;
  exitImage.height = roomHeight * exitEditorScale;
  exitCursor.width = tileWidth * exitEditorScale;
  exitCursor.src = spacerDataURL;
  exitEnding.style.width = (tileWidth * tileEditorScale) + 6 + 'px';

  animationPreview.width = tileEditorScale * 2;
  animationPreview.height = tileEditorScale * 2;

  layers.style.width = (tileWidth * 4.5 * roomEditorScale) + 'px';

  roomTiles.style.minWidth = tileEditorScale + 'px';
  roomTiles.style.minHeight = tileEditorScale + 'px';
  tileFrames.style.maxWidth = (tileEditorScale * 5) + 'px';
  tileFrames.style.minWidth = tileEditorScale + 'px';
  tileFrames.style.minHeight = tileEditorScale + 'px';
  if (data.editor.showGrid) {
    document.body.classList.add('show-grid');
  }
  if (data.editor.showWalls) {
    document.body.classList.add('show-walls');
  }
  if (data.editor.showCard) {
    document.body.classList.add('show-card');
  }

  fontImage.width = roomImage.width;
  fontImage.height = roomImage.height;

  var textChars = 17;
  var textLines = 4; // TODO: revisit lines?

  charImage.width = tileWidth * tileEditorScale;
  charImage.height = tileHeight * tileEditorScale;

  // TODO: set canvas sizes!
  songImage.width = tileWidth * roomEditorScale * 32;
  songImage.height = tileWidth * roomEditorScale * VoiceName.length;
  songCanvas.width = songImage.width / 2;
  songCanvas.height = songImage.height / 2;

  notesImage.width = tileWidth * roomEditorScale * 32;
  notesImage.height = tileWidth * roomEditorScale * 6;
  notesCanvas.width = notesImage.width / 4;
  notesCanvas.height = notesImage.height / 4;

  var radiosHTML = '';
  for (var type in TileType) {
    if (TileType[type]==TileType.Exit) continue;
    radiosHTML += '<input type="radio" name="tile-type-radio" value="'+TileType[type]+'" title="'+type+' tile" aria-label="'+type+' tile" class="icon tile-type-'+type.toLowerCase()+'" />';
  }
  tileTypePill.innerHTML = radiosHTML;

  radiosHTML = '';
  var voiceHTML = '';
  for (var type in VoiceType) {
    voiceHTML += '<li data-voice-type="'+VoiceType[type]+'"><span class="icon voice-type-'+type.toLowerCase()+'"></span> '+type+'</li>';
    radiosHTML += '<input type="radio" name="voice-type-radio" value="'+VoiceType[type]+'" title="'+type+'" aria-label="'+type+'" class="icon voice-type-'+type.toLowerCase()+'" />';
  }
  one('.voice-list').innerHTML = voiceHTML;
  voiceTypePill.innerHTML = radiosHTML;

  //////////////////////////////////////////////////////////
  var isCommandPressed = false;
  var isShiftPressed = false;
  var isOptionPressed = false;

  //////////////////////////////////////////////////////////////
  // overlay
  var activeOverlay = null;
  function showOverlay(which) {
    var selectBackdrop = one('#select-backdrop');
    if (selectBackdrop) selectBackdrop.dispatchEvent(new Event('mousedown'));

    one('#non-modal-content').disabled = true;
    activeOverlay = which;
    var id = '#overlay-content-'+activeOverlay;
    var content = one(id);
    one('#overlay').style.display = content.style.display = 'block';

    one('#input-focus').focus();

    if (content.show) content.show();
  }
  function hideOverlay() {
    if (!activeOverlay) return;
    one('#non-modal-content').disabled = false;

    var content = one('#overlay-content-'+activeOverlay);
    one('#overlay').style.display = content.style.display = 'none';
    activeOverlay = null;

    if (content.hide) content.hide();
  }
  bind('.button-overlay', 'click', function(event) {
    showOverlay(event.target.id.replace('button-overlay-', ''));
  });
  bind('.button-overlay-cancel', 'click', hideOverlay);
  bind('#overlay', 'mousedown', function(event) {
    if (event.target!=one('#overlay')) return;
    hideOverlay();
    event.preventDefault();
  });

  bind('#button-conflict-discard', 'click', function(event) {
    resolveConflictDiscard();
  });
  bind('#button-conflict-save', 'click', function(event) {
    resolveConflictSave();
  });

  function formatOverlay(msg) { // message can be a string or an array with 1 or 2 values
    if (typeof msg=='string') return msg;

    var html = `<h3>${msg[0]}</h3>`;
    if (msg.length==2) html += `<p>${msg[1]}</p>`;
    return html;
  }

  var alertCallback = null;
  function showAlert(message, callback) {
    alertCallback = callback;
    one('#overlay-alert-message').innerHTML = formatOverlay(message);
    showOverlay('alert');
  }
  bind('#button-alert-ok', 'click', function(event) {
    hideOverlay();
  });
  one('#overlay-content-alert').hide = function() {
    if (alertCallback) {
      alertCallback();
      alertCallback = null;
    }
  };

  var wasConfirmed = false;
  var confirmCallback = null;
  function showConfirm(message, confirmLabel, callback) { // callback(wasConfirmed)
    wasConfirmed = false;
    confirmCallback = callback;
    one('#button-confirm-ok').innerHTML = confirmLabel || 'OK';
    one('#overlay-confirm-message').innerHTML = formatOverlay(message);
    showOverlay('confirm');
  }
  function confirmAction(message, confirmLabel, callback) { // overridable with shift key
    if (isShiftPressed) callback(true);
    else showConfirm(message, confirmLabel, callback);
  }
  bind('#button-confirm-ok', 'click', function(event) {
    wasConfirmed = true;
    hideOverlay();
  });
  one('#overlay-content-confirm').hide = function() {
    confirmCallback(wasConfirmed);
    confirmCallback = null;
  };

  var wasPromptConfirmed = false;
  var promptCallback = null;
  function showPrompt(message, defaultValue, confirmLabel, callback) {
    wasPromptConfirmed = false;
    promptCallback = callback;
    one('#overlay-prompt-message').innerHTML = formatOverlay(message);
    one('#overlay-prompt-value').value = defaultValue || '';
    one('#button-prompt-ok').innerHTML = confirmLabel || 'OK';
    showOverlay('prompt');
  }
  bind('#button-prompt-ok', 'click', function(event) {
    wasPromptConfirmed = true;
    hideOverlay();
  });
  var promptOverlay = one('#overlay-content-prompt');
  promptOverlay.show = function() {
    one('#overlay-prompt-value').focus();
  }
  promptOverlay.hide = function() {
    promptCallback(wasPromptConfirmed ? one('#overlay-prompt-value').value : null);
    promptCallback = null;
  };

  // make globally accessible
  window.showOverlay = showOverlay;
  window.hideOverlay = hideOverlay;
  window.showAlert = showAlert;

  //////////////////////////////////////////////////////////
  var isPreviewingText = false;
  function previewText(say,cursor) {
    isPreviewingText = true;
    renderText(say,roomImage,cursor);
  }
  function dismissPreview() {
    if (!isPreviewingText) return;

    isPreviewingText = false;
    renderRoom();
  }
  var initialScript = '';
  var editorHasFocus = false;
  var scriptHasError = false;
  var scriptEvents = [];
  function renderScriptEvents(json) {
    var updatedScriptEvents = [];
    if (json) {
      for (var i=0; i<json.__srcOrder.length; i++) {
        var eventName = json.__srcOrder[i];
        if (typeof eventName=='number') continue;
        updatedScriptEvents.push(eventName);
      }
      updatedScriptEvents.sort();
    }

    if (scriptEvents.join(',')!=updatedScriptEvents.join(',')) {
      scriptEvents = clone(updatedScriptEvents);
      var eventsHTML = '';
      for (var i=0; i<scriptEvents.length; i++) {
        var event = scriptEvents[i];
        eventsHTML += `<li data-value="${event}">${event}</li>`;
      }
      scriptEventsSelect.innerHTML = eventsHTML;
      syncSelect(scriptEventsSelect);
    }

    one('#script-events').style.display = scriptEvents.length ? 'inline-block' : 'none';
  }
  function updateActiveScriptEvent() {
    if (!scriptEvents.length) return;

    var cursor = scriptEditor.selection.getCursor();
    var lines = scriptEditor.session.getLines(0,cursor.row);
    var script = lines.reverse().join('');
    var m = script.match(/on\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+do/);
    if (m && m[1]) setSelectValue(scriptEventsSelect, m[1]);
  }
  function clearScriptError() {
    scriptHasError = false;
    scriptStatus.innerHTML = '';
    scriptStatus.classList.remove('status-fail');
  }
  function saveScript(scriptId, scriptString) {
    // print('saveScript');

    var script = data.scripts[scriptId];
    if (script) {
      // print('found valid script', scriptId);
      var json = ps2json(scriptString);
      if (json.error) {
        scriptHasError = true;
        scriptStatus.innerHTML = json.error;
        scriptStatus.classList.add('status-fail');
      }
      else {
        clearScriptError();
        renderScriptEvents(json.json);
        if (json.json.__srcOrder.length>0) {
          script.data = json.json;
          // print('saved script', scriptId);
        }
        else {
          // print('script is empty, deleting its data', scriptId, new Error().stack);
          delete script.data;
        }
      }
    }
    // else {
    // 	print('- unable to find script...', scriptId, new Error().stack);
    // }
  }
  scriptEditor.session.on('change', function(delta) {
    if (!editorHasFocus) return; // NOTE: changed in code

    var scriptId = parseInt(sharedEditor.dataset.scriptId);
    var script = data.scripts[scriptId];
    if (script) {
      var source = getScriptSource(script);
      if (source) {
        var currentScript = scriptEditor.session.getValue().trim();
        if (initialScript!=currentScript) {
          initialScript = currentScript;
          saveScript(scriptId, currentScript);
        }
      }
    }
  });
  scriptEditor.selection.on('changeCursor', function(event) {
    updateActiveScriptEvent();

    if (data.editor.activeModeId!=EditorMode.Room) return;

    var cursor = scriptEditor.selection.getCursor();
    var line = scriptEditor.session.getLine(cursor.row);
    var say = decodeStringMatch(line, /^\s*(?:say|fin)\s+"([^"]+)"(\s+then)?\s*$/);

    if (say) {
      say = say[1];
      var encodedSay = reencodeMatchedString(say);
      var cursor = cursor.column - line.indexOf(encodedSay);
      if (cursor>=0 && cursor<=encodedSay.length) {
        previewText(say,cursor);
      }
      else dismissPreview();
    }
    else dismissPreview();
  });
  var scriptHistory = {
    scriptId:null,
    cleanScript: null,
    cleanString: null,
  };
  var scriptX = -1;
  var scriptY = -1;
  function scriptMouseMove(event) {
    scriptX = event.clientX;
    scriptY = event.clientY;
  }
  var scriptFocusTime = 0;
  scriptEditor.on('focus', function(event) {
    if (editorHasFocus || Date.now()-scriptFocusTime<5) return; // we just gained focus, ignore
    scriptFocusTime = Date.now();
    editorHasFocus = true;

    var scriptId = data.editor.activeScriptId;
    var script = data.scripts[scriptId];

    if (script) {
      scriptHistory.scriptId = scriptId;
      scriptHistory.cleanScript = clone(script);
      scriptHistory.cleanString = scriptEditor.session.getValue().trim();
    }

    bind(document, 'mousemove', scriptMouseMove);
  });
  scriptEditor.on('blur', function(event) {
    if (Date.now()-scriptFocusTime<5) return; // we just gained focus, ignore
    editorHasFocus = false;

    if (scriptHasError) { // ignoring this is not an option
      function addressSyntaxError() {
        event.preventDefault();
        event.stopPropagation();
        showAlert("This script cannot be compiled in its current state. Please address or comment out the unresolved issue before switching away.", function() {
          scriptEditor.focus();
        });
      }
      var target = document.elementFromPoint(scriptX, scriptY);
      if (target.target=='docs' || target.target=='forum') {
        window.setTimeout(addressSyntaxError,500);
      }
      else addressSyntaxError();
      return;
    }

    unbind(document, 'mousemove', scriptMouseMove);

    if (isset(scriptHistory.scriptId)) {
      var oldValue = scriptHistory.cleanString;
      var newValue = scriptEditor.session.getValue().trim();

      if (oldValue!=newValue) {
        var scriptId = scriptHistory.scriptId;
        var oldScript = clone(scriptHistory.cleanScript);
        var newScript = clone(data.scripts[scriptId]);

        pushHistory('edit script', function(){
          data.scripts[scriptId] = newScript;
          loadScriptEditor(scriptId);
        }, function(){
          data.scripts[scriptId] = oldScript;
          loadScriptEditor(scriptId);
        }, true);
      }

      scriptHistory.scriptId = null;
      scriptHistory.cleanScript = null;
      scriptHistory.cleanString = null;
    }

    if (data.editor.activeModeId!=EditorMode.Room) return;
    dismissPreview();
  });
  bindSelect(scriptEventsSelect, 'select', function onScriptEventSelect(event) {
    var eventName = getSelectValue(scriptEventsSelect);
    var range = scriptEditor.find(`on ${eventName} do`, {
      wrap: true,
      caseSensitive: false,
      preventScroll: false,
      backwards: false,
    });
    if (range) {
      scriptEditor.scrollToLine(range.start.row, false, false);
      scriptEditor.navigateLineStart();
      scriptEditor.focus();
    }
  });

  //////////////////////////////////////////////////////////
  // b/w drawing init
  var clearPixel = frameContext.createImageData(1,1);
  clearPixel.data[0] = 0;
  clearPixel.data[1] = 0;
  clearPixel.data[2] = 0;
  clearPixel.data[3] = 0;

  var whitePixel = frameContext.createImageData(1,1);
  whitePixel.data[0] = rgbLight[0];
  whitePixel.data[1] = rgbLight[1];
  whitePixel.data[2] = rgbLight[2];
  whitePixel.data[3] = 255;

  var blackPixel = frameContext.createImageData(1,1);
  blackPixel.data[0] = rgbDark[0];
  blackPixel.data[1] = rgbDark[1];
  blackPixel.data[2] = rgbDark[2];
  blackPixel.data[3] = 255;

  // NOTE: used by exit image data, not tinted
  var pureGrayPixel = frameContext.createImageData(1,1);
  pureGrayPixel.data[0] = 0;
  pureGrayPixel.data[1] = 0;
  pureGrayPixel.data[2] = 0;
  pureGrayPixel.data[3] = Math.floor(0.6 * 255);

  //////////////////////////////////////////////////////////
  // cache frame ImageData
  var frameImageDatas = new Array();
  var wallImageDatas = new Array();
  function cacheFrameImageData(frameId) {
    // clear
    frameContext.fillStyle = uiLight;
    frameContext.fillRect(0,0,tileWidth,tileHeight);

    // draw frame from data
    var frameData = data.frames[frameId].data;
    for (var y=0; y<tileHeight; y++) {
      for (var x=0; x<tileWidth; x++) {
        var i = y * tileWidth + x;
        var frame = frameData[i];
        if (frame==1) frameContext.putImageData(blackPixel,x,y);
        else if (frame==2) frameContext.clearRect(x,y,1,1);

      }
    }

    // cache
    frameImageDatas[frameId] = frameContext.getImageData(0,0,tileWidth,tileHeight);

    // wall addition
    frameContext.fillStyle = 'rgba(255,0,0,0.5)';
    frameContext.fillRect(0,0,tileWidth,tileHeight);
    wallImageDatas[frameId] = frameContext.getImageData(0,0,tileWidth,tileHeight);
  }
  function deleteImageData(frameId) {
    frameImageDatas[frameId] = false;
    wallImageDatas[frameId] = false;
  }
  function tidyImageDatas() {
    tidyTail(frameImageDatas);
    tidyTail(wallImageDatas);
  }
  for (var i=0; i<data.frames.length; i++) {
    if (!data.frames[i]) continue;
    cacheFrameImageData(i);
  }

  //////////////////////////////////////////////////////////
  // cache ImageData used by exits
  function cachePreblendedImageData(frameDatas, imageDatas, imageDatasActive, imageDatasArmed) {
    for (var id=0; id<frameDatas.length; id++) {
      frameContext.fillStyle = uiLight;
      frameContext.fillRect(0,0,tileWidth,tileHeight);

      // TODO: this imageData isn't actually used anywhere is it?
      // draw frame from data
      var frameData = frameDatas[id];
      for (var y=0; y<tileHeight; y++) {
        for (var x=0; x<tileWidth; x++) {
          var i = y * tileWidth + x;
          if (frameData[i]==1) {
            frameContext.putImageData(blackPixel,x,y);
          }
        }
      }
      // cache
      imageDatas[id] = frameContext.getImageData(0,0,tileWidth,tileHeight);

      // build base of active/armed image data
      frameContext.fillStyle = 'rgb(255,255,255)'; // pure white
      frameContext.fillRect(0,0,tileWidth,tileHeight);
      for (var y=0; y<tileHeight; y++) {
        for (var x=0; x<tileWidth; x++) {
          var i = y * tileWidth + x;
          if (frameData[i]==1) {
            frameContext.putImageData(pureGrayPixel,x,y);
          }
        }
      }
      var baseImageData = frameContext.getImageData(0,0,tileWidth,tileHeight);

      // active
      frameContext.globalCompositeOperation = 'multiply';
      frameContext.fillStyle = uiYellow;
      frameContext.fillRect(0,0,tileWidth,tileHeight);
      frameContext.globalCompositeOperation = 'source-over';
      // cache
      imageDatasActive[id] = frameContext.getImageData(0,0,tileWidth,tileHeight);

      // in-active
      frameContext.putImageData(baseImageData,0,0);
      frameContext.globalCompositeOperation = 'multiply';
      frameContext.fillStyle = uiGreen;
      frameContext.fillRect(0,0,tileWidth,tileHeight);
      frameContext.globalCompositeOperation = 'source-over';
      // cache
      imageDatasArmed[id] = frameContext.getImageData(0,0,tileWidth,tileHeight);
    }
  }
  var exitImageDatas = new Array();
  var exitImageDatasActive = new Array();
  var exitImageDatasArmed = new Array();
  cachePreblendedImageData(exitsFrameData, exitImageDatas, exitImageDatasActive, exitImageDatasArmed);
  var edgeImageDatas = new Array();
  var edgeImageDatasActive = new Array();
  var edgeImageDatasArmed = new Array();
  cachePreblendedImageData(edgesFrameData, edgeImageDatas, edgeImageDatasActive, edgeImageDatasArmed);

  //////////////////////////////////////////////////////////
  // cache font pipe/char ImageData
  var pipeImageDatas = new Array();
  function cachePipeImageData(pipeId) {
    // clear
    frameContext.fillStyle = uiDark;
    frameContext.fillRect(0,0,tileWidth,tileHeight);

    // draw frame from data
    var frameData = data.font.pipe[pipeId];
    for (var y=0; y<tileHeight; y++) {
      for (var x=0; x<tileWidth; x++) {
        var i = y * tileWidth + x;
        if (frameData[i]==0) {
          frameContext.putImageData(whitePixel,x,y);
        }
      }
    }

    // cache
    pipeImageDatas[pipeId] = frameContext.getImageData(0,0,tileWidth,tileHeight);
  }
  for (var i=0; i<data.font.pipe.length; i++) {
    cachePipeImageData(i);
  }
  var charImageDatas = new Array();
  function cacheCharImageData(charId) {
    // clear
    frameContext.clearRect(0,0,tileWidth,tileHeight);

    var charWidth = tileWidth;
    if (data.font.type==FontType.HalfWidth) {
      charWidth /= 2;
    }

    frameContext.fillStyle = uiDark;
    frameContext.fillRect(0,0,charWidth,tileHeight);

    // draw frame from data
    var frameData = data.font.chars[charId];
    for (var y=0; y<tileHeight; y++) {
      for (var x=0; x<charWidth; x++) {
        var i = y * tileWidth + x;
        if (frameData[i]==0) {
          frameContext.putImageData(whitePixel,x,y);
        }
      }
    }

    // cache
    charImageDatas[charId] = frameContext.getImageData(0,0,tileWidth,tileHeight);
  }
  for (var i=0; i<data.font.chars.length; i++) {
    cacheCharImageData(i);
  }

  //////////////////////////////////////////////////////////
  // setup animations, initial tile sort
  var sortTiles = data.editor.sortedTiles===null;
  if (sortTiles) data.editor.sortedTiles = [];
  for (var i=0; i<data.tiles.length; i++) {
    var tile = data.tiles[i];
    addFrameTimer(tile.fps);
    if (sortTiles) {
      if (!data.editor.sortedTiles[tile.type]) {
        data.editor.sortedTiles[tile.type] = [];
      }
      data.editor.sortedTiles[tile.type].push(tile.id);
    }
  }

  //////////////////////////////////////////////////////////
  // data url helpers
  function getFrameDataURL(frameId, tileId) {
    if (data.tiles[tileId].solid && data.editor.showWalls) {
      frameContext.putImageData(wallImageDatas[frameId],0,0);
    }
    else {
      frameContext.putImageData(frameImageDatas[frameId],0,0);
    }
    return frameCanvas.toDataURL('image/png');
  }
  function pushRoomToContext(roomId,isExitMap,skipExtras) {
    // TODO: this is more than a helper, it's actually doing the drawing...
    var isActiveRoom = roomId==data.editor.activeRoomId;

    // clear
    roomContext.fillStyle = uiLight;
    roomContext.fillRect(0,0,roomWidth,roomHeight);

    // draw tiles
    var roomData = data.rooms[roomId];
    var roomTiles = roomData.tiles;
    var showWalls = data.editor.showWalls;
    for (var y=0; y<roomTilesHigh; y++) {
      for (var x=0; x<roomTilesWide; x++) {
        var i = y * roomTilesWide + x;
        var tileId = roomTiles[i];
        var tile = data.tiles[tileId];
        if (!data.editor.showLayer[TileTypeToLayer[tile.type]]) continue;

        var tileFrames = tile.frames;
        var j = tileFrames[0];
        if (!skipExtras && isActiveRoom && tileFrames.length>1 && tile.fps>0) {
          j = tileFrames[frameTimers[tile.fps].frame % tileFrames.length];
        }
        var imageData;
        if (!skipExtras && showWalls && tile.solid) {
          imageData = wallImageDatas[j];
        }
        else {
          imageData = frameImageDatas[j];
        }
        roomContext.putImageData(imageData, x*tileWidth,y*tileHeight);
      }
    }

    if (!skipExtras && roomId==data.player.room && data.editor.showLayer[Layer.Player]) {
      var tile = data.tiles[data.player.id];

      var tileFrames = tile.frames;
      var j = tileFrames[0];
      if (isActiveRoom && tileFrames.length>1 && tile.fps>0) {
        j = tileFrames[frameTimers[tile.fps].frame % tileFrames.length];
      }

      playerContext.putImageData(frameImageDatas[j],0,0);
      roomContext.drawImage(playerCanvas, data.player.x*tileWidth,data.player.y*tileHeight);
      // roomContext.putImageData(frameImageDatas[j], data.player.x*tileWidth,data.player.y*tileHeight);
    }

    if (skipExtras) return;

    if (data.editor.showLayer[Layer.Exits]) {
      var roomExits = roomData.exits;
      for (var i=0; i<roomExits.length; i++) {
        if (!isActiveRoom) continue;

        var exit = roomExits[i];
        var imageDataId = Exit.Misconfigured;
        var exitType = getExitType(exit);
        var isConfigured = isExitConfigured(exit);
        if (isConfigured) {
          switch (exitType) {
            case ExitType.Connection:
              imageDataId = Exit.Connection;
              break;
            case ExitType.Ending:
              imageDataId = Exit.Ending;
              break;
          }
        }
        var isActiveExit = data.editor.activeLayerId==Layer.Exits && exit.id==data.editor.activeExitId;
        if (exitType==ExitType.Edge) {
          var imageDataSource = isActiveExit ? edgeImageDatasActive : edgeImageDatasArmed;
          // NOTE: passthrough is intentional
          switch (exit.edge) {
            case ExitEdge.South:
            case ExitEdge.North:
              roomContext.putImageData(imageDataSource[4], 0,exit.y*tileHeight);

              var ew = roomTilesWide-1;
              for (var ex=1; ex<ew; ex++) {
                imageData = (ex==ew/2) ? (isConfigured ? imageDataSource[exit.edge] : imageDataSource[10]) : imageDataSource[5];
                roomContext.putImageData(imageData, ex*tileWidth,exit.y*tileHeight);
              }
              roomContext.putImageData(imageDataSource[6], ew*tileWidth,exit.y*tileHeight);
              break;

            case ExitEdge.East:
            case ExitEdge.West:
              roomContext.putImageData(imageDataSource[7], exit.x*tileWidth,0);
              var eh = roomTilesHigh-1;
              for (var ey=1; ey<eh; ey++) {
                imageData = (ey==eh/2) ? (isConfigured ? imageDataSource[exit.edge] : imageDataSource[11]) : imageDataSource[8];
                roomContext.putImageData(imageData, exit.x*tileWidth,ey*tileHeight);
              }
              roomContext.putImageData(imageDataSource[9], exit.x*tileWidth,ey*tileHeight);
              break;
          }
        }
        else {
          var imageData;
          if (isActiveExit) imageData = exitImageDatasActive[imageDataId];
          else imageData = exitImageDatasArmed[imageDataId];
          roomContext.putImageData(imageData, exit.x*tileWidth,exit.y*tileHeight);
        }
      }

      if (isExitMap) {
        roomExits = data.rooms[data.editor.activeRoomId].exits;
        for (var i=0; i<roomExits.length; i++) {
          var exit = roomExits[i];
          if (exit.room!=roomId) continue;

          var exitType = getExitType(exit);
          var isActiveExit = (exit.id==data.editor.activeExitId);
          var isConfigured = isExitConfigured(exit);

          if (exitType==ExitType.Edge) {
            var imageDataSource = isActiveExit ? edgeImageDatasActive : edgeImageDatasArmed;
            // NOTE: passthrough is intentional
            var exitEdge = getOppositeEdge(exit);
            switch (exitEdge) {
              case ExitEdge.South:
              case ExitEdge.North:
                roomContext.putImageData(imageDataSource[4], 0,exit.ty*tileHeight);

                var ew = roomTilesWide-1;
                for (var ex=1; ex<ew; ex++) {
                  imageData = (ex==ew/2) ? (isConfigured ? imageDataSource[exitEdge] : imageDataSource[10]) : imageDataSource[5];
                  roomContext.putImageData(imageData, ex*tileWidth,exit.ty*tileHeight);
                }
                roomContext.putImageData(imageDataSource[6], ew*tileWidth,exit.ty*tileHeight);
                break;

              case ExitEdge.East:
              case ExitEdge.West:
                roomContext.putImageData(imageDataSource[7], exit.tx*tileWidth,0);
                var eh = roomTilesHigh-1;
                for (var ey=1; ey<eh; ey++) {
                  imageData = (ey==eh/2) ? (isConfigured ? imageDataSource[exitEdge] : imageDataSource[11]) : imageDataSource[8];
                  roomContext.putImageData(imageData, exit.tx*tileWidth,ey*tileHeight);
                }
                roomContext.putImageData(imageDataSource[9], exit.tx*tileWidth,ey*tileHeight);
                break;
            }
          }
          else {
            var imageData;
            if (isActiveExit) imageData = exitImageDatasActive[Exit.Target];
            else imageData = exitImageDatasArmed[Exit.Target];
            roomContext.putImageData(imageData, exit.tx*tileWidth,exit.ty*tileHeight);
          }
        }
      }
    }
  }
  function getRoomDataURL(roomId, isExitMap) {
    pushRoomToContext(roomId, isExitMap);
    return roomCanvas.toDataURL('image/png');
  }
  function getTileDataURL(tileId, skipExtras) {
    var tile = data.tiles[tileId];
    var tileFrames = tile.frames;
    var frame = tileFrames[0];
    if (!skipExtras && tileFrames.length>1 && tile.fps>0) {
      frame = tileFrames[frameTimers[tile.fps].frame % tileFrames.length];
    }
    frameContext.putImageData(frameImageDatas[frame],0,0);
    if (!skipExtras && tile.solid && data.editor.showWalls) {
      frameContext.fillStyle = 'rgba(255,0,0,0.5)';
      frameContext.fillRect(0,0,tileWidth,tileHeight);
    }
    return frameCanvas.toDataURL('image/png');
  }
  function getExitDataURL(exitId,forceActive) {
    if (forceActive) {
      frameContext.putImageData(exitImageDatasActive[exitId],0,0);
    }
    else {
      frameContext.putImageData(exitImageDatas[exitId],0,0);
    }
    return frameCanvas.toDataURL('image/png');
  }
  function getPipeDataURL(pipeId) {
    frameContext.putImageData(pipeImageDatas[pipeId],0,0);
    return frameCanvas.toDataURL('image/png');
  }
  function getCharDataURL(charId) {
    frameContext.clearRect(0,0,tileWidth,tileHeight);
    frameContext.putImageData(charImageDatas[charId],0,0);
    return frameCanvas.toDataURL('image/png');
  }

  //////////////////////////////////////////////////////////
  var tools = {};
  function getToolModeId(name, modeName) { // TODO: unused?
    var tool = tools[name];
    for (var i=0; i<tool.modes.length; i++) {
      if (tool.modes[i].name==modeName) return i;
    }
    return -1;
  }
  function setActiveToolMode(name, newModeId) {
    var tool = tools[name];
    var oldModeId = tool.active;
    tool.active = newModeId;
    var oldMode = tool.modes[oldModeId];
    var newMode = tool.modes[newModeId];
    document.body.dataset[`${name}ToolMode`] = newMode.name;
    one(`input[name="${name}-tool-mode-radio"][value="${newModeId}"]`).checked = true;
  }
  function getToolMode(name) { // returns mode name as a string...
    // eg. if (getToolMode('room')=='move')...
    var tool = tools[name];
    var i = tool.override!=-1 ? tool.override : tool.active;
    return tool.modes[i].name;
  }
  function updateToolOverrides() {
    for (var name in tools) {
      var tool = tools[name];
      tool.override = -1;
      for (var i=0; i<tool.modes.length; i++) {
        var mode = tool.modes[i];
        if ((isCommandPressed && mode.key=='command') ||
          (isOptionPressed && mode.key=='option') ||
          (isShiftPressed && mode.key=='shift')) {

          if (isShiftPressed && mode.key=='shift' && data.editor.activeLayerId!=Layer.Player && name=='tile') continue;

          if (isOptionPressed && mode.key=='option' && data.editor.activeModeId==EditorMode.Room && name=='room') {
            if (data.editor.activeLayerId==Layer.Exits) continue;
            if (data.editor.activeLayerId==Layer.Player) continue;
          }

          tool.override = i;
          break;
        }
      }
      var i = tool.override!=-1 ? tool.override : tool.active;
      one(`input[name="${name}-tool-mode-radio"][value="${i}"]`).checked = true;
      document.body.dataset[`${name}ToolMode`] = tool.modes[i].name;
    }
  }
  function renderTools(name, modes) {
    if (modes.length<=1) return; // no point

    tools[name] = {
      active: 0,
      override: -1,
      modes: modes,
    };

    function ucfirst(s) {
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    var stack = one(`#${name}-tools`);
    var html = '';
    for (var i=0; i<modes.length; i++) {
      var mode = modes[i];
      var label = ucfirst(mode.name) + (i!=0 ? ` (hold ${ucfirst(mode.key)})` : '');
      html += `<input type="radio" ${i==0?'checked="checked"':''} name="${name}-tool-mode-radio" data-tool-name="${name}" value="${i}" title="${label}" aria-label="${label}" class="icon tool-mode-${mode.icon}">`;
    }
    stack.innerHTML = html;

    setActiveToolMode(name, 0);
    bind(`input[name="${name}-tool-mode-radio"]`, 'change', function(event) {
      // TODO: hook into history?
      setActiveToolMode(name, parseInt(this.value));
    });
  }
  //////////////////////////////////////////////////////////
  function renderThemes() {
    var defaultTheme = 'Asheville';
    var themeSelect = one('#theme-select');
    var themeStylesheet = one('#theme-stylesheet');

    var optionHTML = '';
    for (var i=0; i<themes.length; i++) {
      var themeName = themes[i];
      optionHTML += '<li data-value="'+themeName+'">'+themeName+'</li>';
    }
    themeSelect.innerHTML = optionHTML;
    function setActiveTheme(themeName) {
      if (themes.indexOf(themeName)==-1) {
        themeName = defaultTheme;
      }

      localStorage.setItem('activeTheme', themeName);
      themeStylesheet.href = urls.shared + 'themes/' + themeName+'.css';
      setSelectValue(themeSelect, themeName);
    }

    bindSelect(themeSelect, 'select', function(event) {
      setActiveTheme(getSelectValue(themeSelect));
    });
    setActiveTheme(localStorage.getItem('activeTheme') || defaultTheme);

    bind(window, 'storage', function(event) {
      if (event.key=='activeTheme') setActiveTheme(localStorage.getItem('activeTheme') || defaultTheme);
    });
  }
  renderThemes();

  function renderGlobalVolume() {
    var volumeNode = one('#volume');
    function updateVolume() {
      var volume = localStorage.getItem('playerVolume');
      volume = (volume==null) ? 0.5 : parseFloat(volume);
      Playhead.setVolume(volume);
      volumeNode.value = volume * volumeNode.max;
    }
    updateVolume();
    function setPlayerVolume(volume) {
      if (volume==0) return mute();
      Playhead.setVolume(volume);
      localStorage.setItem('playerVolume', volume);
    }
    bind(volumeNode, 'input', function(event) {
      unmute();
      setPlayerVolume(event.target.value / event.target.max);
    });

    var isMuted = false;
    function updateMute() {
      isMuted = localStorage.getItem('muteVolume')=='true';
      if (isMuted) {
        document.body.classList.add('muted');
        Playhead.setVolume(0); // don't save to localStorage
        volumeNode.value = 0;
      }
      else {
        document.body.classList.remove('muted');
        updateVolume();
      }
    }
    updateMute();
    function mute() {
      if (isMuted) return;
      isMuted = !isMuted;
      Playhead.setVolume(0); // don't save to localStorage
      volumeNode.value = 0;
      document.body.classList.add('muted');
    }
    function unmute() {
      if (!isMuted) return;
      isMuted = !isMuted;
      localStorage.setItem('muteVolume', isMuted);
      document.body.classList.remove('muted');
    }
    bind('#button-mute', 'click', function(event) {
      isMuted = !isMuted;
      localStorage.setItem('muteVolume', isMuted);
      updateMute();
    });

    bind(window, 'storage', function(event) {
      if (event.key=='activeTheme') updateTheme();
      if (event.key=='playerVolume') updateVolume();
      if (event.key=='muteVolume') updateMute();
    });
  }
  renderGlobalVolume();

  //////////////////////////////////////////////////////////
  function renderTitle() {
    document.title = 'Playdate Pulp - ' + data.name;
  }
  function renderCard() {
    pushRoomToContext(data.card, false, true);
    previewImage.src = roomCanvas.toDataURL('image/png');
  }
  function renderGame() {
    renderTitle();
    renderCard();

    gameName.value = data.name;
    gameFile.innerHTML = data.name;
    gameAuthor.value = data.author;
    gameIntro.value = data.intro;
    setSelectValue(gameCardSelect, data.card);

    var tilesHTML = '';
    for (var i=0; i<2; i++) {
      // NOTE: bypasses getFrameDataURL() because we don't care about the parent tile and its solid state
      frameContext.putImageData(frameImageDatas[i],0,0);
      tilesHTML += '<i draggable="false"'+(i==data.background?' class="active"':'')+' data-background-id="'+i+'"><img draggable="false" width="'+tileEditorScale+'" src="'+frameCanvas.toDataURL('image/png')+'"></i>';
    }
    backgroundTiles.innerHTML = tilesHTML;

    // behavior
    each('#background-tiles i', function(i,node) {
      bind(node, 'click', function(event) {
        var oldBackground = data.background;
        var newBackground = parseInt(event.target.dataset.backgroundId);

        if (oldBackground!=newBackground) {

          var oldClassList = one('#background-tiles i[data-background-id="'+oldBackground+'"]').classList;
          var newClassList = one('#background-tiles i[data-background-id="'+newBackground+'"]').classList;

          var oldRooms = clone(data.rooms);
          var newRooms = clone(data.rooms);
          for (var i=0; i<newRooms.length; i++) {
            var room = newRooms[i];
            if (!room) continue;

            var refill = true;
            for (var j=0; j<room.tiles.length; j++) {
              if (room.tiles[j]!=oldBackground) {
                refill = false;
                break;
              }
            }
            if (refill) {
              room.tiles = newRoomTiles(newBackground);
            }
          }

          pushHistory('set background', function() {
            data.background = newBackground;
            data.rooms = newRooms;
            oldClassList.remove('active');
            newClassList.add('active');
          }, function() {
            data.background = oldBackground;
            data.rooms = oldRooms;
            oldClassList.add('active');
            newClassList.remove('active');
          });
        }
      });
    });

    loadScriptEditor(0);
  }
  renderGame();

  //////////////////////////////////////////////////////////
  function renderRoom() {
    roomImage.src = getRoomDataURL(data.editor.activeRoomId);

    // TODO: find a better place for this?

    if (data.editor.highlightTiles) {
      // clear
      highlightContext.clearRect(0, 0, roomWidth,roomHeight);
      highlightContext.fillStyle = 'rgba(0,0,0,0.6)';
      highlightContext.fillRect(0,0,roomWidth,roomHeight);

      // draw tiles
      var roomData = data.rooms[data.editor.activeRoomId];
      var roomTiles = roomData.tiles;
      // overdraw white
      highlightContext.fillStyle = '#FFF';
      for (var y=0; y<roomTilesHigh; y++) {
        for (var x=0; x<roomTilesWide; x++) {

          var i = y * roomTilesWide + x;
          var tileId = roomTiles[i];
          if (tileId!=data.editor.activeTileId) continue;
          highlightContext.fillRect(x*tileWidth-1,y*tileHeight-1,tileWidth+2,tileWidth+2);
        }
      }
      // knockout highlights
      for (var y=0; y<roomTilesHigh; y++) {
        for (var x=0; x<roomTilesWide; x++) {
          var i = y * roomTilesWide + x;
          var tileId = roomTiles[i];
          if (tileId!=data.editor.activeTileId) continue;
          highlightContext.clearRect(x*tileWidth,y*tileHeight,tileWidth,tileWidth);
        }
      }
      highlightImage.src = highlightCanvas.toDataURL('image/png');
    }
  }
  renderRoom();
  renderTools('room', [
    {name:'draw',	key:'default',	icon:'pencil'},
    {name:'sample',	key:'shift',	icon:'sample'},
    {name:'fill',	key:'option',	icon:'fill'},
    {name:'move',	key:'command',	icon:'grab'},
  ]);

  function renderFrame() {
    frameImage.src = getFrameDataURL(data.editor.activeFrameId,data.editor.activeTileId);
  }
  renderTools('tile', [
    {name:'draw',	key:'default',	icon:'pencil'},
    {name:'erase',	key:'shift',	icon:'eraser'},
    {name:'fill',	key:'option',	icon:'fill'},
    {name:'move',	key:'command',	icon:'grab'},
  ]);

  var dragNode;
  var dragClone;
  var dragOffsetX,dragOffsetY;
  function onDragStart(event) {
    // print('drag started');
    dragOffsetX = event.offsetX;
    dragOffsetY = event.offsetY;
    dragNode = event.target;
    dragClone = dragNode.cloneNode(true);
    dragClone.style.position = 'absolute';
    dragClone.style.zIndex = 1000;
    dragClone.style.left = (event.x - dragOffsetX + window.pageXOffset) + 'px';
    dragClone.style.top = (event.y - dragOffsetY + window.pageYOffset) + 'px';
    dragClone.style.opacity = 0.8;
    dragClone.style.pointerEvents = 'none';
    document.body.appendChild(dragClone);
    dragNode.style.opacity = 0;
    event.preventDefault();
  }
  function onDragMove(event) {
    // print('drag moved')
    event.preventDefault();
    if (!dragNode) return;
    if (dragNode==event.target) return;
    if (dragNode.parentNode!=event.target.parentNode) return;

    if (event.offsetX<16 && dragNode.nextElementSibling!=event.target) {
      dragNode.parentNode.insertBefore(dragNode, event.target);
    }
    else if (event.offsetX>=16 && event.target.nextElementSibling!=dragNode) {
      dragNode.parentNode.insertBefore(dragNode, event.target.nextElementSibling);
    }
  }

  function UI_changeFrame(frameId) {
    var oldFrameId = data.editor.activeFrameId;
    var newFrameId = frameId;
    if (oldFrameId!=newFrameId) {
      var activeTileId = data.editor.activeTileId;
      pushHistory('set active frame '+newFrameId, function() {
        setActiveTile(activeTileId, newFrameId);
      }, function() {
        setActiveTile(activeTileId, oldFrameId);
      }, false, true);
    }
  }

  function renderFrames() {
    // ui
    var framesHTML = '';
    var tile = data.tiles[data.editor.activeTileId];
    var frames = tile.frames;
    for (var i=0; i<frames.length; i++) {
      var frameId = frames[i];
      framesHTML += '<i draggable="false" data-tile-id="'+tile.id+'" data-frame-id="'+frameId+'"><img draggable="false" width="'+tileEditorScale+'" src="'+getFrameDataURL(frameId,tile.id)+'"></i>';
    }
    tileFrames.innerHTML = framesHTML;

    // behavior
    each('#tile-frames i', function(i,node) {
      bind(node, 'click', function(event) {
        UI_changeFrame(parseInt(event.target.dataset.frameId));
      });
      bind(node, 'mousedown', onDragStart);
      bind(node, 'mousemove', onDragMove);
    });
  }
  renderFrames();

  function UI_changeTile(tileId) {
    var oldTileId = data.editor.activeTileId;
    var newTileId = tileId;
    if (oldTileId!=newTileId) {
      pushHistory('set active tile', function() {
        setActiveTile(newTileId);
      }, function() {
        setActiveTile(oldTileId);
      }, false, true);
    }
  }

  function renderTiles() {
    // ui
    var tileIds = flatten(data.editor.sortedTiles);
    var tilesHTML = '';
    for (var i=0; i<tileIds.length; i++) {
      var tile = data.tiles[tileIds[i]];
      if (!tile) continue;

      var frameId = tile.frames[0];
      tilesHTML += '<i draggable="false" title="'+tile.name+' (tile '+tile.id+')" aria-label="'+tile.name+' (tile '+tile.id+')" data-tile-id="'+tile.id+'" data-frame-id="'+frameId+'" data-tile-type="'+tile.type+'"><img draggable="false" width="'+tileEditorScale+'" src="'+getFrameDataURL(frameId,tile.id)+'"></i>';
    }
    roomTiles.innerHTML = tilesHTML;

    // behavior
    each('#room-tiles i', function(i,node) {
      bind(node, 'click', function(event) {
        UI_changeTile(parseInt(event.target.dataset.tileId));
      });
      bind(node, 'mousedown', onDragStart);
      bind(node, 'mousemove', onDragMove);
    });
  }

  function renderRoomSelect() {
    var rooms = [];
    for (var i=0; i<data.rooms.length; i++) {
      var room = data.rooms[i];
      if (!room) continue;
      rooms.push(room);
    }
    rooms.sort(sortByName);

    var optionsHTML = '';
    for (var i=0; i<rooms.length; i++) {
      var room = rooms[i];
      if (!room) continue;
      optionsHTML += '<li data-value="'+room.id+'">'+room.name+'<span class="icons">';
      if (data.player.room==room.id) optionsHTML += '<span class="icon tile-type-player">*</span>';
      if (data.editor.highlightTiles && room.tiles.indexOf(data.editor.activeTileId)!=-1) optionsHTML += '<span class="icon highlight-tile"></span>';
      optionsHTML += '</span></li>';
    }
    roomSelect.innerHTML = optionsHTML;
    gameCardSelect.innerHTML = optionsHTML;
    exitSelect.innerHTML  = '<li data-value="-1">nowhere</li>'+optionsHTML;

    syncSelect(roomSelect);
    syncSelect(gameCardSelect);
    syncSelect(exitSelect);

    setSelectValue(roomSelect, data.editor.activeRoomId);
  }
  renderRoomSelect();
  window.renderRoomSelect = renderRoomSelect;

  window.getExitAt = function(x,y,roomId,notExit) {
    if (!isset(roomId)) roomId = data.editor.activeRoomId;
    var exits = data.rooms[roomId].exits;
    for (var i=exits.length-1; i>=0; i--) {
      var exit = exits[i];
      if (exit==notExit) continue;

      // print('checking exit', exit, x, y);
      if (exit.x==x && exit.y==y) return exit;
      else if (notExit && isset(notExit.edge) && notExit.edge!=-1) {
        switch (notExit.edge) {
          case ExitEdge.North:
          case ExitEdge.South:
            if (exit.y==y) return exit;
            break;
          case ExitEdge.East:
          case ExitEdge.West:
            if (exit.x==x) return exit;
            break;
        }
      }
      else if (isset(exit.edge) && exit.edge!=-1) {
        switch (exit.edge) {
          case ExitEdge.North:
          case ExitEdge.South:
            if (exit.y==y) return exit;
            break;
          case ExitEdge.East:
          case ExitEdge.West:
            if (exit.x==x) return exit;
            break;
        }
      }
    }
    return null;
  }
  function getExit() {
    return data.rooms[data.editor.activeRoomId].exits[data.editor.activeExitId];
  }
  function syncExitProperties() {
    exitSays.value = '';
    var exit = getExit();

    if (exit) {
      var exitType = getExitType(exit);
      exitPane.classList.remove('empty');

      one('input[name="exit-type-radio"][value="'+exitType+'"]').checked = true;
      exitTypePill.style.display = 'inline-block';

      if (exitType==ExitType.Ending) {
        exitConnection.style.display = 'none';
        exitEnding.style.display = 'block';
        var fin = exit.fin || '';
        exitSays.value = isset(exit.fin) ? jsonf2says(exit.fin) : '';
        setSelectValue(exitSongSelect, exit.song);
      }
      else {
        exitEnding.style.display = 'none';
        exitConnection.style.display = 'block';

        // TODO: this is super buggy
        // TODO: figure out where to isolate invalid rooms
        // TODO: reasons for invalid rooms:
        // 1. haven't selected a room yet
        // 2. this exit points to a room that has been deleted
        if (!isset(exit.room) || !data.rooms[exit.room]) {
          exit.room = -1;
          exit.tx = -1;
          exit.ty = -1;
        }
        setSelectValue(exitSelect, exit.room);

        if (exitType==ExitType.Edge) updateExitEdge(exit);

        if (exit.room!=-1) {
          exitImage.dataset.roomId = exit.room;
          exitImage.src = getRoomDataURL(exit.room, true);
          exitCursor.src = getExitDataURL(Exit.Target, true);
          editRoom.style.display = 'inline-block';
        }
        else {
          exitImage.src = spacerDataURL;
          exitCursor.src = spacerDataURL;
          editRoom.style.display = 'none';
        }
      }
    }
    else {
      exitPane.classList.add('empty');
      exitTypePill.style.display = 'none';
      exitConnection.style.display = 'none';
      exitEnding.style.display = 'none';
    }

    if (data.editor.activeLayerId==Layer.Exits && data.editor.activeExitId>data.rooms[data.editor.activeRoomId].exits.length) {
      setActiveExit(data.rooms[data.editor.activeRoomId].exits.length);
    }
  }
  function setActiveExit(exitId) {
    data.editor.activeExitId = exitId;

    each('#room-exits i.active', function(i,node) {
      node.classList.remove('active');
    });
    each('#room-exits i[data-exit-id="'+data.editor.activeExitId+'"]', function(i,node) {
      node.classList.add('active');
    });

    syncExitProperties();
  }
  setActiveExit(data.editor.activeExitId);

  function renderPreview() {
    var imageData = getTileDataURL(data.editor.activeTileId);
    animationPreview.src = imageData;

    if (data.editor.activeLayerId==Layer.Exits) {
      roomCursor.src = getExitDataURL(Exit.Connection,true);
    }
    else {
      var tile = data.tiles[data.editor.activeTileId];
      if (tile.type==TileType.Player) {
        imageData = getTileDataURL(data.player.id);
      }
      roomCursor.src = imageData;
    }
  }
  function preventDeletingStartRoom() {
    if (data.editor.activeRoomId==data.player.room) {
      each('#room-actions .delete', function(i,node) {
        node.style.visibility = 'hidden';
      });
    }
    else {
      each('#room-actions .delete', function(i,node) {
        node.style.visibility = 'visible';
      });
    }
  }
  function setActiveRoom(roomId) {
    var room = data.rooms[roomId];

    document.body.classList[room.id==data.card?'add':'remove']('is-card');

    data.editor.activeRoomId = roomId;
    roomName.value = room.name;
    setSelectValue(roomSelect, roomId);
    roomName.title = '(room '+roomId+')';
    setSelectValue(roomSongSelect, room.song);
    preventDeletingStartRoom();
    // data.editor.activeExitId = 0; // TODO: yay or nay?
    syncExitProperties();
    renderRoom(); // force a redraw immediately
  }
  setActiveRoom(data.editor.activeRoomId);

  function setActiveLayer(layerId) {
    // state
    var oldLayerId = data.editor.activeLayerId;
    data.editor.activeLayerId = layerId;

    // ui
    each('#layers li.active', function(i,node) {
      node.classList.remove('active');
    });
    each('#layers li:nth-child('+(layerId+1)+')', function(i,node) {
      node.classList.add('active');
    });

    var tileType = LayerToTileType[layerId]
    document.body.dataset.tileType = tileType;
    document.body.dataset.layerId = layerId;

    if (getToolMode('tile')=='erase' && layerId!=Layer.Player) setActiveToolMode('tile', 0);

    if (layerId==Layer.Exits || oldLayerId==Layer.Exits) {
      if (layerId==Layer.Exits) {
        if (getToolMode('room')=='fill') setActiveToolMode('room', 0);
        setActiveExit(data.editor.activeExitId);
      }
      renderRoom();
      if (layerId==Layer.Exits) return;
    }
    else if (layerId==Layer.Player) {
      if (getToolMode('room')=='fill') setActiveToolMode('room', 0);
    }

    // a valid tile is already selected
    if (data.tiles[data.editor.activeTileId].type==tileType) return;

    var sortedTiles = data.editor.sortedTiles[tileType];
    if (sortedTiles.length>0) setActiveTile(sortedTiles[0]);
    else print('no valid tile'); // TODO: handle this
  }
  setActiveLayer(data.editor.activeLayerId);

  function highlightActiveTile() {
    each('#room-tiles i.active, #tile-frames i.active', function(i,node) {
      node.classList.remove('active');
    });
    each('#room-tiles i[data-tile-id="'+data.editor.activeTileId+'"],#tile-frames i[data-frame-id="'+data.editor.activeFrameId+'"]', function(i,node) {
      node.classList.add('active');
    });
  }
  function fullRoomRedraw() {
    renderFrame();
    renderPreview();
    renderFrames();
    renderTiles();
    renderRoom();
    syncExitProperties();
    highlightActiveTile();
    renderScriptSelect();
    renderRecentScripts();
  }
  function syncTileProperties() {
    var tileId = data.editor.activeTileId;
    var frameId = data.editor.activeFrameId
    var tile = data.tiles[tileId];
    var sortedTiles = data.editor.sortedTiles[tile.type];

    if (tile.id==0 || tile.id==1) {
      frameImage.classList.remove('editable');
      each('input[name="tile-type-radio"]', function(i,node) {
        node.disabled = true;
      });
      tileName.disabled = true;
      tileFps.disabled = true;
      each('#tile-actions .delete, #frame-actions button, #tile-modifiers', function(i,node) {
        node.disabled = true;
      });
    }
    else {
      frameImage.classList.add('editable');
      each('input[name="tile-type-radio"]', function(i,node) {
        node.disabled = (tile.id==data.player.id || sortedTiles.length==1);
      });
      tileName.disabled = false;
      tileFps.disabled = false;

      each('#tile-actions button, #frame-actions button, #tile-modifiers', function(i,node) {
        node.disabled = false;
      });

      if (tile.id==data.player.id || sortedTiles.length==1) {
        each('#tile-actions button.delete', function(i,node) {
          node.disabled = true;
        });
      }

      if (tile.frames.length==1) {
        each('#frame-actions button.delete', function(i,node) {
          node.disabled = true;
        });
      }
    }

    validateTileProperties(tile);

    // toggle properties depending on type
    tileIsSolid.disabled = tile.type!=TileType.World;

    tileName.value = tile.name;
    tileFps.value = tile.fps;
    frameImage.dataset.frameId = roomCursor.dataset.frameId = frameId;
    roomCursor.dataset.tileId = tileId;
    tileIsSolid.checked = tile.solid;
    one('input[name="tile-type-radio"][value="'+tile.type+'"]').checked = true;

    behavior.dataset.behaviorType = tile.btype;
    each('input[name="behavior-type-radio"]', function(i,node) {
      node.disabled = (tile.type==TileType.Player);
    })

    if (tile.btype==BehaviorType.None) {
      behavior.style.display = 'none';
    }
    else {
      behavior.style.display = '';
      one('input[name="behavior-type-radio"][value="'+tile.btype+'"]').checked = true;

      if (tile.btype==BehaviorType.Script) {
        tileSays.value = '';
        // print('loading script for ', tile.name, tile.script);
        setActiveScript(tile.script);
      }
      else {
        clearScriptEditor();

        tileSays.value = isset(tile.says) ? jsonf2says(tile.says) : '';
        setSelectValue(behaviorSoundSelect, isset(tile.sound) ? tile.sound : -1);
      }
    }

    fullRoomRedraw();
  }
  function setActiveTile(tileId,frameId) {
    var tile = data.tiles[tileId];

    // state
    if (frameId==null) frameId = tile.frames[0];
    data.editor.activeTileId = tileId;
    data.editor.activeFrameId = frameId;

    var cursorId = tileId;
    if (tile.type==TileType.Player) {
      cursorId = data.player.id;
    }
    roomCursor.src = getTileDataURL(cursorId, true);

    var layerId = TileTypeToLayer[tile.type];
    if (layerId!=data.editor.activeLayerId) {
      setActiveLayer(layerId);
    }
    highlightActiveTile();
    syncTileProperties();
    renderRoomSelect();
  }
  setActiveTile(data.editor.activeTileId, data.editor.activeFrameId);

  //////////////////////////////////////////////////////////
  var songVoices = [];
  var soundVoices = [];
  var AudioSource = {
    Song: 0,
    Sound: 1,
  };
  var audioSource = {
    type: AudioSource.Song,
    voice: VoiceType.Sine,
    voices: null, // []
    notes: null, // []
    source: null, // song or sound
  };
  function updateAudioSource() {
    // NOTE: I dislike everything about this...
    if (audioSource.notes==null || data.editor.activeModeId==EditorMode.Song) {
      var song = data.songs[data.editor.activeSongId];
      audioSource.type = AudioSource.Song;
      audioSource.source = song;
      audioSource.voice = data.editor.activeVoiceId;
      audioSource.voices = songVoices;
      audioSource.notes = song.notes[audioSource.voice];
    }
    else if (data.editor.activeModeId==EditorMode.Sound) {
      var sound = data.sounds[data.editor.activeSoundId];
      audioSource.type = AudioSource.Sound;
      audioSource.source = sound;
      audioSource.voice = sound.type;
      audioSource.voices = soundVoices;
      audioSource.notes = sound.notes;
    }
  }
  updateAudioSource();
  function setSoundAudioSource(soundId) {
    var sound = data.sounds[soundId];
    audioSource.type = AudioSource.Sound;
    audioSource.source = sound;
    audioSource.voice = sound.type;
    audioSource.voices = soundVoices;
    audioSource.notes = sound.notes;
  }

  function relocateNode(node, target) {
    node.parentNode.removeChild(node);
    target.appendChild(node);
  }
  // TODO: find a better place for these
  var activeResultId = -1;
  var searchResults = [];
  var lastSearch = null;
  function setActiveMode(modeId) {
    // TODO: only update on change?
    var oldMode = data.editor.activeModeId;

    data.editor.activeModeId = modeId;
    document.body.dataset.editorMode = modeId;

    // ui
    each('#modes li.active', function(i,node) {
      node.classList.remove('active');
    });
    each('#modes li:nth-child('+(modeId+1)+')', function(i,node) {
      node.classList.add('active');
    });

    if (oldMode!=modeId) {
      stopPlayback();
      allOff();
    }

    if (modeId==EditorMode.Game) {
      renderCard();
    }
    else if (modeId==EditorMode.Font) {
      renderText();
    }
    else if (modeId==EditorMode.Room) {
      relocateNode(sharedEditor, one('#tile-script-editor'));
      scriptEditor.resize();
      var tile = data.tiles[data.editor.activeTileId];
      if (tile && isset(tile.script)) {
        setActiveScript(tile.script);
      }
      else {
        clearScriptEditor();
      }
    }
    else if (modeId==EditorMode.Script) {
      relocateNode(sharedEditor, one('#script-script-editor'));
      scriptEditor.resize();
      setActiveScript(data.editor.activeScriptId);
      renderScriptSelect();
    }
    else if (modeId==EditorMode.Song) {
      relocateNode(sharedModifiers, one('#song-modifiers'));
      relocateNode(sharedNotes, one('#song-notes-container'));
      relocateNode(sharedEnvelope, one('#song-envelope-container'));
      setActiveSong(data.editor.activeSongId);
    }
    else if (modeId==EditorMode.Sound) {
      relocateNode(sharedModifiers, one('#sound-modifiers'));
      relocateNode(sharedNotes, one('#sound-notes-container'));
      relocateNode(sharedEnvelope, one('#sound-envelope-container'));
      setActiveSound(data.editor.activeSoundId);
    }

    sanityCheck();
  }
  setActiveMode(data.editor.activeModeId);

  var searchInput = one('#search');
  var resultsList = one('#results-list');
  var clearSearchButton = one('#clear-search');
  function focusSearchInput() {
    searchInput.focus();
    searchInput.select();
  }

  scriptEditor.commands.addCommand({
    name: "find",
    bindKey: {
      win: "Ctrl-F",
      mac: "Command-F",
    },
    exec: function(editor, line) {
      focusSearchInput();
      return false;
    },
    readOnly: true
  });

  function offsetActiveResult(resultId, offset) {
    var highlighted = one(`#results-list li.highlighted`);
    if (highlighted) highlighted.classList.remove('highlighted');

    offset = offset || 0;
    if (offset<0) {
      resultId -= 1;
      if (resultId<0) resultId = searchResults.length-1;
    }
    else if (offset>0) {
      resultId += 1;
      if (resultId>=searchResults.length) resultId = 0;
    }
    activeResultId = resultId;

    highlighted = one(`#results-list li[data-result-id="${activeResultId}"]`);
    if (highlighted) {
      highlighted.classList.add('highlighted');
      highlighted.scrollIntoView({block:'nearest'});
    }
  }

  bind(searchInput, 'focus', function(event) {
    if (searchInput.value!='' && searchResults.length>0) document.body.classList.add('searching');
    else document.body.classList.remove('searching');
  });
  bind('#search-results', 'click', function(event) {
    document.body.classList.remove('searching');
  });
  bind(searchInput, 'keydown', function(event) {
    if (event.keyCode==27) { // escape
      document.body.classList.remove('searching');
      searchInput.blur();
      event.stopPropagation();
      event.preventDefault();
    }

    if (!searchResults.length) return;

    if (event.keyCode==38 || (event.keyCode==9 && isShiftPressed)) { // up or shift+tab
      offsetActiveResult(activeResultId, -1);
      event.stopPropagation();
      event.preventDefault();
    }
    else if (event.keyCode==40 || event.keyCode==9) { // down or tab
      offsetActiveResult(activeResultId, 1);
      event.stopPropagation();
      event.preventDefault();
    }
  });
  bind(searchInput, 'keyup', function(event) {
    if (!searchResults.length) return;

    if (event.keyCode==13) { // return
      setActiveResult(activeResultId, 0);
      event.stopPropagation();
      return;
    }
  });
  function clearSearch() {
    clearSearchButton.style.display = 'none';
    searchInput.value = '';
    searchInput.dispatchEvent(new Event('input'));
    searchInput.focus();
  }
  bind(clearSearchButton, 'click', function onClearSearch(event) {
    clearSearch();
    event.stopPropagation();
    event.preventDefault();
  });
  bind(clearSearchButton, 'keydown', function(event) {
    if (event.keyCode==13) {
      clearSearch();
      event.stopPropagation();
      event.preventDefault();
    }
  });

  function showSearchResults() {
    if (searchResults.length>0) {
      // required to prevent results from disappearing when changing from scrollable to not...
      document.body.classList.remove('searching');

      var items = resultsList.querySelectorAll('li');

      var style = getComputedStyle(resultsList);
      var maxItems = parseInt(style.getPropertyValue('--ui-max-select-options') || 0);

      if (items.length>maxItems) {
        resultsList.classList.add('scrollable');
      }
      else {
        resultsList.classList.remove('scrollable');
      }
      offsetActiveResult(activeResultId, 0);

      document.body.classList.add('searching'); // must be visible before getting bounds
      var target = searchInput.getBoundingClientRect();
      resultsList.style.left = target.width + 16 + 'px';

      var bounds = resultsList.getBoundingClientRect();
      var oy = -24;
      if (bounds.top+bounds.height>window.innerHeight) {
        oy -= (bounds.top+bounds.height)-window.innerHeight;
      }
      resultsList.style.top = oy + 'px';

    }
    else {
      document.body.classList.remove('searching');
    }
  }
  function renderSearchResults() {
    var resultsHTML = '';
    var lastType = null;
    for (var i=0; i<searchResults.length; i++) {
      var result = searchResults[i];
      switch (result.type) {
        case ResultType.Game:
          if (lastType!=result.type) resultsHTML += `<li class="label">Game</li>`;
          var which = result.id==GameMeta.Name ? 'name' : (result.id==GameMeta.Author ? 'author' : 'intro');
          resultsHTML += `<li data-result-id="${i}"><span class="icon icon-game"></span>${which}</li>`;
          break;
        case ResultType.Room:
          if (lastType!=result.type) resultsHTML += `<li class="label">Room</li>`;
          var room = data.rooms[result.id];
          if (room) resultsHTML += `<li data-result-id="${i}"><span class="icon tile-type-world"></span>${room.name}</li>`;
          break;
        case ResultType.Tile:
          if (lastType!=result.type) resultsHTML += `<li class="label">Tile</li>`;
          var tile = data.tiles[result.id];
          if (tile) resultsHTML += `<li data-result-id="${i}"><span class="icon wall"></span>${tile.name}</li>`;
          break;
        case ResultType.Song:
          if (lastType!=result.type) resultsHTML += `<li class="label">Song</li>`;
          var song = data.songs[result.id];
          if (song) resultsHTML += `<li data-result-id="${i}"><span class="icon mode-song"></span>${song.name}</li>`;
          break;
        case ResultType.Sound:
          if (lastType!=result.type) resultsHTML += `<li class="label">Sound</li>`;
          var sound = data.sounds[result.id];
          if (sound) resultsHTML += `<li data-result-id="${i}"><span class="icon voice-type-noise"></span>${sound.name}</li>`;
          break;
        case ResultType.Script:
          if (lastType!=result.type) resultsHTML += `<li class="label">Script</li>`;
          var script = data.scripts[result.id];
          if (script) {
            var source = getScriptSource(script);
            if (source) {
              var sourceName = (source==data) ? 'game' : source.name;
              resultsHTML += `<li data-result-id="${i}"><span class="icon behavior-type-script"></span>${sourceName}</li>`;
            }
          }
          break;
      }
      lastType = result.type;
    }
    resultsList.innerHTML = resultsHTML;
  }

  function performSearch(search) {
    function dismissSearch() {
      document.body.classList.remove('searching');
      lastSearch = search;
    }

    if (search=='') {
      clearSearchButton.style.display = 'none';
      dismissSearch();
      return
    }
    clearSearchButton.style.display = 'block';
    if (search==lastSearch) return;

    lastSearch = search;
    var re = new RegExp(search, 'i');

    var results = [];

    // game
    if (data.name.match(re)) 	results.push({type:ResultType.Game,id:GameMeta.Name});
    if (data.author.match(re))	results.push({type:ResultType.Game,id:GameMeta.Author});
    if (data.intro.match(re)) 	results.push({type:ResultType.Game,id:GameMeta.Intro});

    // rooms
    for (var i=0; i<data.rooms.length; i++) {
      var room = data.rooms[i];
      if (!room) continue;
      if (room.name.match(re)) results.push({type:ResultType.Room,id:i});
    }
    // tiles
    for (var i=0; i<data.tiles.length; i++) {
      var tile = data.tiles[i];
      if (!tile) continue;
      if (tile.name.match(re)) results.push({type:ResultType.Tile,id:i});
    }
    // songs
    for (var i=0; i<data.songs.length; i++) {
      var song = data.songs[i];
      if (!song) continue;
      if (song.name.match(re)) results.push({type:ResultType.Song,id:i});
    }
    // sounds
    for (var i=0; i<data.sounds.length; i++) {
      var sound = data.sounds[i];
      if (!sound) continue;
      if (sound.name.match(re)) results.push({type:ResultType.Sound,id:i});
    }

    // scripts (throttle this or make it interuptable?)
    for (var i=0; i<data.scripts.length; i++) {
      var script = data.scripts[i];
      if (!script || !script.data) continue;
      var source = getScriptSource(script);
      if (source) {
        var code = json2ps(script.data).trim();
        if (code.match(re)) results.push({type:ResultType.Script,id:i});
      }
    }

    searchResults = results;
    activeResultId = 0;
    renderSearchResults();
    showSearchResults();
  }

  bind(searchInput, 'input', function onInputSearch(event) {
    performSearch(event.target.value);

  });
  bind(searchInput, 'focus', function onInputSearch(event) {
    lastSearch = ''; // force refresh the search
    performSearch(event.target.value);

  });
  function setActiveResult(resultId, offset) {
    // prevent switching away from editor if it has compile errors
    scriptEditor.blur();
    if (scriptHasError) return;

    // NOTE: there's some kind of latency happening that requires defering til the next frame for some reason...
    delay(0, function() {
      var oldData = clone(data.editor);
      var oldActiveResultId = activeResultId;

      offsetActiveResult(resultId, offset);

      var result = searchResults[activeResultId];
      if (!result) return;

      function commit() {
        document.body.classList.remove('searching');

        var newData = clone(data.editor);
        var newActiveResultId = activeResultId;
        pushHistory('set active result', function() { // redo
          if (oldData.activeModeId!=newData.activeModeId) 	setActiveMode(newData.activeModeId);
          if (oldData.activeRoomId!=newData.activeRoomId) 	setActiveRoom(newData.activeRoomId);
          if (oldData.activeTileId!=newData.activeTileId || oldData.activeFrameId!=newData.activeFrameId)
            setActiveTile(newData.activeTileId, newData.activeFrameId);
          if (oldData.activeSongId!=newData.activeSongId) 	setActiveSong(newData.activeSongId);
          if (oldData.activeSoundId!=newData.activeSoundId)	setActiveSound(newData.activeSoundId);
          if (oldData.activeScriptId!=newData.activeScriptId) setActiveScript(newData.activeScriptId);

          offsetActiveResult(newActiveResultId,0);
        },function() { // undo
          if (oldData.activeModeId!=newData.activeModeId) 	setActiveMode(oldData.activeModeId);
          if (oldData.activeRoomId!=newData.activeRoomId) 	setActiveRoom(oldData.activeRoomId);
          if (oldData.activeTileId!=newData.activeTileId || oldData.activeFrameId!=newData.activeFrameId)
            setActiveTile(oldData.activeTileId, oldData.activeFrameId);
          if (oldData.activeSongId!=newData.activeSongId) 	setActiveSong(oldData.activeSongId);
          if (oldData.activeSoundId!=newData.activeSoundId)	setActiveSound(oldData.activeSoundId);
          if (oldData.activeScriptId!=newData.activeScriptId) setActiveScript(oldData.activeScriptId);

          offsetActiveResult(oldActiveResultId,0);
        },true,true);
      }
      function tidy() {
        searchResults.splice(activeResultId,1);
        renderSearchResults();
      }

      // TODO: we need to make sure each item still exists before activating...
      var found = false;
      function focusTarget(target) {
        if (!target) return;
        delay(0, function() {
          target.scrollIntoView({block:'nearest'});
          target.focus();
          // select just the search term
          target.selectionStart = target.value.toLowerCase().indexOf(lastSearch.toLowerCase());
          target.selectionEnd = target.selectionStart + lastSearch.length;
        });
      }
      switch (result.type) {
        case ResultType.Game:
          found = true;
          setActiveMode(EditorMode.Game);
          switch(result.id) {
            case GameMeta.Name: focusTarget(one('#game-name')); break;
            case GameMeta.Author: focusTarget(one('#game-author')); break;
            case GameMeta.Intro: focusTarget(one('#game-intro')); break;
          }
          break;
        case ResultType.Room:
          if (data.rooms[result.id]) {
            found = true;
            setActiveMode(EditorMode.Room);
            setActiveRoom(result.id);
            focusTarget(one('#room-name'));
          }
          break;
        case ResultType.Tile:
          if (data.tiles[result.id]) {
            found = true;
            setActiveMode(EditorMode.Room);
            setActiveTile(result.id);
            focusTarget(one('#tile-name'));
          }
          break;
        case ResultType.Song:
          if (data.songs[result.id]) {
            found = true;
            setActiveMode(EditorMode.Song);
            setActiveSong(result.id);
            focusTarget(one('#song-name'));
          }
          break;
        case ResultType.Sound:
          if (data.sounds[result.id]) {
            setActiveMode(EditorMode.Sound);
            setActiveSound(result.id);
            focusTarget(one('#sound-name'));
          }
          break;
        case ResultType.Script:
          if (data.scripts[result.id]) {
            // found = true; // handled after delay
            setActiveMode(EditorMode.Script);
            setActiveScript(result.id);
            delay(0.01, function() {
              var row = 0;
              var col = 0;
              var backwards = offset==-1;
              if (backwards) {
                row = scriptEditor.session.getLength()-1;
                col = scriptEditor.session.getLine(row).length-1;
              }
              // print(`jump to ${row},${col} (backwards:${backwards?'true':'false'})`);
              scriptEditor.selection.setRange(new ace.Range(row,col,row,col));
              var range = scriptEditor.find(lastSearch, {
                wrap: false,
                caseSensitive: false,
                preventScroll: false,
                backwards:backwards,
              });

              if (range) {
                // print(`	`, range);
                scriptEditor.scrollToLine(range.start.row, false, false);
                scriptEditor.focus();
                commit();
              }
              else {
                tidy();
              }
            });
          }
          break;
      }
      if (found) commit();
      else if (result.type!=ResultType.Script) { // script is cleaned up later
        tidy();
      }
    });
  }
  bind('#results-list', 'click', function(event) {
    if (event.target.nodeName!='LI' || event.target.classList.contains('label')) return;
    setActiveResult(parseInt(event.target.dataset.resultId));
  });

  scriptEditor.session.on('wrapstart', function() {
    setActiveResult(activeResultId,1);
    return false;
  });
  scriptEditor.session.on('wrapend', function() {
    setActiveResult(activeResultId,-1);
    return false;
  });

  //////////////////////////////////////////////////////////
  function setActivePipe(pipeId) {
    data.editor.activePipeId = pipeId;
    data.editor.activeCharId = -1;

    // ui
    charType.innerHTML = 'UI';
    charName.innerHTML = pipes[pipeId];
    charImage.src = getPipeDataURL(pipeId);
    delete charImage.dataset.charId;
    charImage.dataset.pipeId = pipeId;

    each('#pipe-tiles i.active,#arrow-tiles i.active,#char-tiles i.active', function(i,node) {
      node.classList.remove('active')
    });
    each('#pipe-tiles i[data-pipe-id="'+pipeId+'"],#arrow-tiles i[data-pipe-id="'+pipeId+'"]', function(i,node) {
      node.classList.add('active')
    });
  }
  function setActiveChar(charId) {
    data.editor.activeCharId = charId;
    data.editor.activePipeId = -1;

    // ui
    charType.innerHTML = 'Char';
    var char = chars[charId];
    if (char==' ') char = 'Space';
    charName.innerHTML = char;
    charImage.src = getCharDataURL(charId);
    delete charImage.dataset.pipeId;
    charImage.dataset.charId = charId;

    each('#pipe-tiles i.active,#char-tiles i.active,#arrow-tiles i.active', function(i,node) {
      node.classList.remove('active')
    });
    each('#char-tiles i[data-char-id="'+charId+'"]', function(i,node) {
      node.classList.add('active')
    });
  }
  function UI_changePipe(newPipeId) {
    var oldCharId = data.editor.activeCharId;
    var oldPipeId = data.editor.activePipeId;
    if (oldPipeId!=newPipeId) {
      pushHistory('set active pipe', function() {
        setActivePipe(newPipeId);
      },function() {
        if (oldPipeId==-1) setActiveChar(oldCharId);
        else setActivePipe(oldPipeId);
      }, false, true);
    }
  }
  function renderPipes() {
    // ui
    pipeTiles.parentNode.style.width = (tileWidth * 4.5 * roomEditorScale) + 'px';
    pipeTiles.style.width = (tileEditorScale * 3) + 'px';
    var pipeHTML = '';
    for (var i=0; i<9; i++) {
      pipeHTML += '<i draggable="false" data-pipe-id="'+i+'" title="'+pipes[i]+'" aria-label="'+pipes[i]+'"><img draggable="false" width="'+tileEditorScale+'" src="'+getPipeDataURL(i)+'" /></i>';
    }
    pipeTiles.innerHTML = pipeHTML;

    var arrowHTML = '';
    arrowTiles.style.width = (tileEditorScale * 3) + 'px';
    for (var i=0; i<5; i++) {
      var j = 9+i;
      arrowHTML += '<i draggable="false" data-pipe-id="'+j+'" title="'+pipes[j]+'" aria-label="'+pipes[j]+'"><img draggable="false" width="'+tileEditorScale+'" src="'+getPipeDataURL(j)+'" /></i>';
    }
    arrowTiles.innerHTML = arrowHTML;

    // behavior
    each('#pipe-tiles i, #arrow-tiles i', function(i,node) {
      bind(node, 'click', function(event) {
        UI_changePipe(parseInt(event.target.dataset.pipeId));
      });
    });
  }
  function UI_changeChar(newCharId) {
    var oldPipeId = data.editor.activePipeId;
    var oldCharId = data.editor.activeCharId;
    if (oldCharId!=newCharId) {
      pushHistory('set active char', function() {
        setActiveChar(newCharId);
      },function() {
        if (oldCharId==-1) setActivePipe(oldPipeId);
        else setActiveChar(oldCharId);
      }, false, true);
    }
  }
  function renderChars() {
    // ui
    var charHTML = '';
    charTiles.style.width = (tileEditorScale * 20) + 'px';
    for (var i=0; i<chars.length; i++) {
      var char = chars[i];
      if (char==' ') char = 'Space';
      if (char=='"') char = '&quot;';
      charHTML += '<i draggable="false" title="'+char+'" aria-label="'+char+'" data-char-id="'+i+'"><img draggable="false" width="'+tileEditorScale+'" src="'+getCharDataURL(i)+'" /></i>';
    }
    charTiles.innerHTML = charHTML;

    // behavior
    each('#char-tiles i', function(i,node) {
      bind(node, 'click', function(event) {
        UI_changeChar(parseInt(event.target.dataset.charId));
      });
    });
  }
  function renderText(text, target, cursor) {
    pushRoomToContext(data.editor.activeRoomId, false, target==null);

    if (cursor==null) {
      var input = document.activeElement;
      if (input && input instanceof HTMLTextAreaElement) {
        cursor = input.selectionStart;
      }
      else {
        cursor = 0;
      }
    }

    //////////////////////////////////////////////////////////
    // render text box
    var ox = tileWidth*3;
    var oy = tileHeight*3;
    var rows = 1+textLines+1;
    var cols = 1+textChars+1;
    textPreviewMeta.tilesWide = cols;
    textPreviewMeta.tilesHigh = rows;
    for (var y=0; y<rows; y++) {
      textPreviewMeta.data[y] = [];
      for (var x=0; x<cols; x++) {
        var i = 4;
        if (y==0) {
          if (x==0) i = 0;
          else if (x==cols-1) i = 2;
          else i = 1;
        }
        else if (y==rows-1) {
          if (x==0) i = 6;
          else if (x==cols-1) i = 8;
          else if (x==cols-2) i = 9;
          else i = 7;
        }
        else {
          if (x==0) i = 3;
          else if (x==cols-1) i = 5;
        }
        roomContext.putImageData(pipeImageDatas[i], ox+(x*tileWidth),oy+(y*tileHeight));

        textPreviewMeta.data[y][x] = -(i+1);
      }
    }

    //////////////////////////////////////////////////////////
    // render text
    text = text!=null ? text : (data.editor.activeTextId==TextSampleType.Custom?data.editor.sampleText:TextSamples[data.editor.activeTextId]);

    var isHalfWidth = data.font.type==FontType.HalfWidth;
    textPreviewMeta.embeds = [];

    // replace variables, Lua-style
    var i = 0;
    var tab = [];
    var f;
    var escaped = false;
    var captured = false;
    for (var k=0; k<text.length; k++) {
      var s = text.charAt(k);
      if (s=='\\') {
        escaped = true;
        f = text.substring(i,k);
        if (f!='') tab.push(f);
        i = k+1;
        continue;
      }
      if (escaped && s!='{' && s!='}') {
        tab.push('\\');
      }
      else if (s=='{' && !escaped && text.substring(k,text.length).match(/[^\\]\}/)) {
        f = text.substring(i,k);
        if (f!='') tab.push(f);
        i = k+1;
        captured = true
      }
      else if (captured && s=='}' && !escaped) {
        f = text.substring(i,k);
        if (f!='') {
          if (f.match(/^embed:.+/)) {
            var tileIdent = f.substring(6,f.length);
            var tileId = parseInt(tileIdent);
            if (isNaN(tileId) || tileId<0 || tileId>=data.tiles.length) {
              tileId = getByName('tile', tileIdent);
            }
            var embedId = textPreviewMeta.embeds.indexOf(tileId);
            if (embedId==-1) {
              embedId = textPreviewMeta.embeds.length;
              textPreviewMeta.embeds.push(tileId);
            }
            tab.push(String.fromCharCode(128+embedId));
          }
          else {
            tab.push('0');
          }
        }
        i = k+1;
        captured = false;
      }
      escaped = false;
    }
    f = text.substring(i,text.length);
    if (f!='') tab.push(f);
    text = tab.join('');
    // print(text);
    // /variable replacement

    ox += tileWidth;
    oy += tileHeight;
    var charWidth = tileWidth;
    rows = textLines;
    cols = textChars;
    textPreviewMeta.isHalfWidth = isHalfWidth;
    if (isHalfWidth) {
      cols *= 2;
      charWidth /= 2;
    }

    // auto wrap
    var lines = [];
    var tmpLines = text.split(/\n/);
    for (var i=0; i<tmpLines.length; i++) {
      var sublines = tmpLines[i].split(/\f/);
      for (var j=0; j<sublines.length; j++) {
        var line = sublines[j];
        // cursor -= 1; // we removed a newline, I think that counts
        while (line.length>cols) { // line is too long
          var char = line.charAt(cols-1);
          var nextChar = line.charAt(cols);
          var isSpace = nextChar==' ';
          if (char=='-' || (char+nextChar).match(/[.,?!][\s]/) || isSpace) { // natural wrapping point
            lines.push(line.slice(0,cols));
            line = line.slice(cols+(isSpace?1:0));
            if (isSpace) cursor -= 1;
          }
          else { // look behind for whitespace
            if (line.slice(0,cols-1).match(/\s/)) {
              for (var k=cols-2; k>=0; k--) { // NOTE: if there's a bug it's this cols-2
                var char = line.charAt(k);
                var nextChar = line.charAt(k+1);
                var isSpace = nextChar==' ';
                if (char=='-' || (char+nextChar).match(/[.,?!][\s]/) || isSpace) { // natural wrapping point
                  lines.push(line.slice(0,k+1));
                  line = line.slice(k+1+(isSpace?1:0));
                  if (isSpace) cursor -= 1;
                  break;
                }
              }
            }
            else { // no whitespace, force hard wrap
              lines.push(line.slice(0,cols));
              line = line.slice(cols);
            }
          }
        }
        lines.push(line);
        if (sublines.length>1 && j<sublines.length-1) {
          // TODO: figure out how this affects cursor (if at all)
          while (lines.length%textLines>0) {
            lines.push('');
          }
        }
      }
    }

    // draw 4 line pages based on cursor position
    // TODO: this is still broken
    // var minLine = Math.max(0,lines.length - textLines);
    // var maxLine = Math.min(lines.length, minLine+textLines);
    var pages = Math.ceil(lines.length / textLines);
    var page = 0;
    var cursorPage = 0;
    for (var i=0; i<lines.length; i++) {
      var line = lines[i];
      cursorPage += line.length;
      if (cursorPage>=cursor) {
        page = Math.floor(i / textLines);
        break;
      }
    }
    var minLine = page * textLines;
    var maxLine = minLine + textLines;
    oy -= minLine * tileHeight;

    for (var y=minLine; y<maxLine; y++) {
      var line = lines[y];
      if (!line) continue;
      for (var x=0; x<line.length; x++) {
        var charId = line.charCodeAt(x);
        var tile = null;
        if (charId>=128) {
          var tileId = textPreviewMeta.embeds[charId - 128];
          tile = data.tiles[tileId];
        }
        charId -= 32;
        if (charId<0) charId = 0;
        if (charId>chars.length-1) charId = 0;

        if (isset(tile)) {
          roomContext.putImageData(frameImageDatas[tile.frames[0]], ox+(x*charWidth),oy+(y*tileHeight), 0,0,charWidth,tileHeight);
        }
        else {
          roomContext.putImageData(charImageDatas[charId], ox+(x*charWidth),oy+(y*tileHeight), 0,0,charWidth,tileHeight);
        }

        var dx = 1 + (Math.floor(x * charWidth / tileWidth));
        var dy = 1 + (y - minLine);
        var i = textPreviewMeta.data[dy][dx];
        if (i<0) {
          textPreviewMeta.data[dy][dx] = charId;
        }
        else { // only true for halfwidth
          textPreviewMeta.data[dy][dx] = textPreviewMeta.encodeAB(i, charId);
        }
      }
    }

    // display preview
    target = target || fontImage;
    target.src = roomCanvas.toDataURL('image/png');
  }
  function setActiveText(textId) {
    data.editor.activeTextId = textId;

    one('input[name="font-text-radio"][value="'+data.editor.activeTextId+'"]').checked = true;
    if (data.editor.activeTextId==TextSampleType.Custom) {
      customText.value = data.editor.sampleText;
      customText.disabled = false;
    }
    else {
      customText.value = TextSamples[data.editor.activeTextId];
      customText.disabled = true;
    }
  }
  function renderFont() {
    one('input[name="font-type-radio"][value="'+data.font.type+'"]').checked = true;

    setActiveText(data.editor.activeTextId);

    renderText();

    renderPipes();
    renderChars();

    if (data.editor.activePipeId>-1) setActivePipe(data.editor.activePipeId);
    else setActiveChar(data.editor.activeCharId);
  }
  renderFont();
  renderTools('char', [
    {name:'draw', key:'default',icon:'pencil'},
    {name:'fill', key:'option',icon:'fill'},
    {name:'move', key:'command',icon:'grab'},
  ]);

  //////////////////////////////////////////////////////////

  function renderScriptSelect() {
    // print('renderScriptSelect()');

    var games = [];
    var rooms = [];
    var tiles = [];

    for (var i=0; i<data.scripts.length; i++) {
      var script = data.scripts[i];
      if (!script) continue;

      switch (script.type) {
        case ScriptType.Game:
          games.push({id:i,name:'game'});
          break;
        case ScriptType.Room:
          var room = data.rooms[script.id];
          rooms.push({id:i,name:room.name}); // TODO: add * to start room
          break;
        case ScriptType.Tile:
          var tile = data.tiles[script.id];
          var name = tile.id==data.player.id ? 'player' : tile.name;
          tiles.push({id:i,name:name});
          break;
      }
    }

    rooms.sort(sortByName);
    tiles.sort(sortByName);

    var optionsHTML = '';
    optionsHTML += '<li class="label">Game</li>';
    for (var i=0; i<games.length; i++) {
      var option = games[i];
      optionsHTML += `<li data-value="${option.id}">${option.name}</li>`;
    }

    if (rooms.length>0) {
      optionsHTML += '<li class="label">Rooms</li>';
      for (var i=0; i<rooms.length; i++) {
        var option = rooms[i];
        optionsHTML += `<li data-value="${option.id}">${option.name}</li>`;
      }
    }

    if (tiles.length>0) {
      optionsHTML += '<li class="label">Tiles</li>';
      for (var i=0; i<tiles.length; i++) {
        var option = tiles[i];
        optionsHTML += `<li data-value="${option.id}">${option.name}</li>`;
      }
    }

    scriptSelect.innerHTML = optionsHTML;
    syncSelect(scriptSelect);
    setSelectValue(scriptSelect, data.editor.activeScriptId);
  }
  // renderScriptSelect();

  function renderRecentScripts() {
    // print('renderRecentScripts()');

    var recentScripts = data.editor.recentScripts;
    if (recentScripts.length==0) {
      one('#recent-scripts').style.display = 'none';
      return;
    }

    // ui
    var itemsHTML = '';
    var width = tileEditorScale/2;
    for (var i=0; i<recentScripts.length; i++) {
      var scriptId = recentScripts[i];
      var script = data.scripts[scriptId];
      if (!script) continue;

      switch (script.type) {
        case ScriptType.Game:
          itemsHTML += '<li data-script-id="'+scriptId+'"><span class="icon icon-game"></span>game</li>';
          break;
        case ScriptType.Room:
          var room = data.rooms[script.id];
          itemsHTML += '<li data-script-id="'+scriptId+'"><span class="icon tile-type-world"></span>'+room.name+'</li>';
          break;
        case ScriptType.Tile:
          var tile = data.tiles[script.id];
          var name = tile.id==data.player.id ? 'player' : tile.name;
          itemsHTML += '<li data-script-id="'+scriptId+'"><img class="icon" src="'+getTileDataURL(tile.id, true)+'" draggable="false" data-frame-id="'+tile.frames[0]+'">'+name+'</li>';
          break;
      }
    }
    one('#recent-list').innerHTML = itemsHTML;
    one('#recent-scripts').style.display = 'block';

    // behavior
    each('#recent-list li', function(i,node) {
      bind(node, 'click', function(event) {
        var oldScriptId = data.editor.activeScriptId;
        var newScriptId = parseInt(event.target.dataset.scriptId);
        if (oldScriptId!=newScriptId) {
          pushHistory('set active script', function() {
            setActiveScript(newScriptId);
          },function() {
            setActiveScript(oldScriptId);
          }, false, true);
        }
      });
    });

    each('#recent-list li.active', function(i,node) {
      node.classList.remove('active');
    });
    each('#recent-list li[data-script-id="'+data.editor.activeScriptId+'"]', function(i,node) {
      node.classList.add('active');
    });
  }
  // renderRecentScripts();
  var canSetActiveScript = false; // prevent init from polluting activeScript value
  function addRecentScript(scriptId) {
    if (!canSetActiveScript) return;

    // print('addRecentScript(',scriptId,')');

    var recentScripts = data.editor.recentScripts;
    var i = recentScripts.indexOf(scriptId);
    if (i>-1) recentScripts.splice(i,1);
    recentScripts.unshift(scriptId);
    if (recentScripts.length>16) {
      recentScripts.pop();
    }
    renderRecentScripts();
  }
  window.removeRecentScript = function(scriptId) {
    var recentScripts = data.editor.recentScripts;
    var i = recentScripts.indexOf(scriptId);
    if (i>-1) recentScripts.splice(i,1);
    renderRecentScripts();
  }

  function clearScriptEditor() {
    // print('clearScriptEditor()');

    editorHasFocus = false;
    initialScript = '';
    scriptEditor.session.setValue('');
    scriptEditor.gotoLine(1,0,true);
    clearScriptError();
    delete sharedEditor.dataset.scriptId;
  }
  function loadScriptEditor(scriptId) {
    // print(`loadScriptEditor(${scriptId})`);

    // scriptSelect.value = scriptId;
    setSelectValue(scriptSelect, scriptId);

    // TODO: update tile preview

    var script = data.scripts[scriptId];
    if (script) {
      var source = getScriptSource(script);
      if (source) {
        var hadFocus = editorHasFocus;
        editorHasFocus = false;

        initialScript = isset(script.data) ? json2ps(script.data).trim() : '';
        sharedEditor.dataset.scriptId = scriptId;
        scriptEditor.session.setValue(initialScript);
        var cursor = editorCursorOffsets[scriptId] || {column:0,row:0};
        scriptEditor.gotoLine(cursor.row+1, cursor.column, false);
        var line = editorScrollOffsets[scriptId] || 0;
        scriptEditor.scrollToLine(line, false, false);
        renderScriptEvents(script.data);
        clearScriptError();

        editorHasFocus = hadFocus;

        // ui
        scriptName.innerHTML = script.type==ScriptType.Game? 'game' : (script.type==ScriptType.Tile && script.id==data.player.id ? 'player' : source.name);

        addRecentScript(scriptId);

        // print('- loaded script', scriptId, initialScript);
      }
      else {
        // print('- unable to find script source...', scriptId, script.id, new Error().stack);
        clearScriptEditor();
      }
    }
    else {
      // print('- unable to find script...', scriptId, new Error().stack);
      clearScriptEditor();
    }
  }
  function setActiveScript(scriptId) {
    if (!canSetActiveScript) return;
    // print('setActiveScript()');

    editorScrollOffsets[data.editor.activeScriptId] = scriptEditor.getFirstVisibleRow();
    editorCursorOffsets[data.editor.activeScriptId] = scriptEditor.selection.getCursor();

    if (isset(data.scripts[scriptId])) {
      data.editor.activeScriptId = scriptId;
      loadScriptEditor(scriptId);
    }
    else {
      clearScriptEditor();
    }

    // ui
    var script = data.scripts[data.editor.activeScriptId];
    one('#goto-game').style.display = (script.type==ScriptType.Game) ? 'inline-block' : 'none';
    one('#goto-tile').style.display = (script.type==ScriptType.Tile && data.editor.activeModeId==EditorMode.Script) ? 'inline-block' : 'none';
    each('#script-actions .delete, #goto-room', function(i,node) {
      node.style.display = (script && script.type==ScriptType.Room) ? 'inline-block' : 'none';
    });
  }
  canSetActiveScript = true;
  setActiveScript(data.editor.activeScriptId);

  //////////////////////////////////////////////////////////
  // musical typing
  var pianoKeys = [];
  var keyVoices = [[],[],[],[],[]]; // by voice then note
  var keyDown = []; // by note
  var keyTimeout = []; // by note
  var baseOctave = 4; // used for musical typing
  var pianoKeyboardKeys = ['a','w','s','e','d','f','t','g','y','h','u','j','k','o','l','p',';', "'"];

  function pianoShouldListen() {
    return inAudioMode() && !inTextInput();
  }
  function updateBaseOctave(d) {
    var oldBase = baseOctave;
    baseOctave += d;
    if (baseOctave<0) baseOctave = 0;
    if (baseOctave>8) baseOctave = 8;

    if (baseOctave!=oldBase) {
      document.body.dataset.baseOctave = baseOctave;
      one('#base-octave').innerHTML = 'C'+baseOctave;
      one('#plus-octave').innerHTML = 'C'+(baseOctave+1)
      one('#plus-octave').style.display = baseOctave<8 ? 'inline-block' : 'none';
    }
  }
  function noteOn(note) {
    if (keyDown[note]) return;
    keyDown[note] = true;

    if (pianoKeys[note]) pianoKeys[note].classList.add('down');

    var voice = keyVoices[audioSource.voice][note];
    if (!voice) {
      voice = new Voice(audioSource.voice, getVoiceEnvelope(audioSource.voice));
      keyVoices[audioSource.voice][note] = voice;
    }

    var octave = baseOctave;
    if (note>11) {
      octave += 1;
      note %= 12;
    }

    if (octave>8) {
      keyDown[note+12] = false;
      return;
    }

    var freqIdx = getFrequencyIndex(note, octave);
    var pitch = Frequency[freqIdx];
    voice.noteOn(pitch);
  }
  function noteOff(note) {
    // if (!keyDown[note]) return; // NOTE: this prevents releasing a stuck key

    var voice = keyVoices[audioSource.voice][note];
    if (voice) {
      if (pianoKeys[note]) pianoKeys[note].classList.remove('down');
      keyDown[note] = false;
      voice.noteOff();
    }
  }
  function allOff() {
    if (!keyVoices) return; // NOTE: I _hate_ this...
    for (var i=0; i<keyVoices[audioSource.voice].length; i++) {
      noteOff(i);
    }
  }
  function noteOnOff(note,octave,hold,voiceType,useSong) {
    var voice;
    var when = Playhead.getCurrentTime();
    if (useSong) {
      var quantize = tick==playTick ? 'floor' : 'ceil';
      when = Math[quantize](when / unit) * unit; // quantize to interval
      voice = audioSource.voices[voiceType];
    }
    else {
      voice = keyVoices[voiceType][note];
      if (!voice) {
        voice = new Voice(voiceType, getVoiceEnvelope(voiceType));
        keyVoices[voiceType][note] = voice;
      }
    }

    var freqIdx = getFrequencyIndex(note, octave);
    var pitch = Frequency[freqIdx];

    voice.playNote(pitch, hold * unit, when);

    if (voiceType==data.editor.activeVoiceId) {
      window.clearTimeout(keyTimeout[note]);
      if (pianoKeys[note]) pianoKeys[note].classList.add('down');

      keyTimeout[note] = window.setTimeout(function() {
        if (pianoKeys[note]) pianoKeys[note].classList.remove('down');
      }, (hold * unit * 1000) - 100);
    }
  }

  function readyPianoKeys() {
    document.body.dataset.baseOctave = baseOctave;

    var keysHTML = '';
    for (var i=0; i<pianoKeyboardKeys.length; i++) {
      var j = i % notes.length;
      var note = notes[j];
      var flat = note.match(/b$/) ? ' flat' : '';
      var label = note+' (musical type with '+pianoKeyboardKeys[i].toUpperCase()+')';
      keysHTML += '<div class="piano-key'+flat+'" id="key-'+note+'" data-note-id="'+i+'" title="'+label+'" aria-label="'+label+'"></div>';
    }
    one('.piano-keys').innerHTML = keysHTML;

    var isMouseDown = false;
    bind(document, 'mousedown', function(event) {
      isMouseDown = true;
    });
    bind(document, 'mouseup', function(event) {
      isMouseDown = false;
    });

    each('.piano-key', function(i,node) {
      pianoKeys[i] = node;
      bind(node, 'mousedown,mouseenter', function(event) {
        if (event.type=='mousedown' || isMouseDown) {
          noteOn(i);
        }
      });
      bind(node, 'mouseup,mouseleave', function(event) {
        noteOff(i);
      });
    });

    bind(window, 'keydown', function(event) {
      if (!pianoShouldListen()) return;
      if (event[cmdKey]) return;

      var note = -1;
      switch (event.keyCode) {
        case 65: note = 0; break;
        case 87: note = 1; break;
        case 83: note = 2; break;
        case 69: note = 3; break;
        case 68: note = 4; break;
        case 70: note = 5; break;
        case 84: note = 6; break;
        case 71: note = 7; break;
        case 89: note = 8; break;
        case 72: note = 9; break;
        case 85: note = 10; break;
        case 74: note = 11; break;
        case 75: note = 12; break;
        case 79: note = 13; break;
        case 76: note = 14; break;
        case 80: note = 15; break;
        case 186: note = 16; break;
        case 222: note = 17; break;

        case 90: return updateBaseOctave(-1);
        case 88: return updateBaseOctave(+1);
      }
      if (note==-1) return;

      noteOn(note);
    });
    bind(window, 'keyup', function(event) {
      if (!pianoShouldListen()) return;

      var note = -1;
      switch (event.keyCode) {
        case 65: note = 0; break;
        case 87: note = 1; break;
        case 83: note = 2; break;
        case 69: note = 3; break;
        case 68: note = 4; break;
        case 70: note = 5; break;
        case 84: note = 6; break;
        case 71: note = 7; break;
        case 89: note = 8; break;
        case 72: note = 9; break;
        case 85: note = 10; break;
        case 74: note = 11; break;
        case 75: note = 12; break;
        case 79: note = 13; break;
        case 76: note = 14; break;
        case 80: note = 15; break;
        case 186: note = 16; break;
        case 222: note = 17; break;
      }
      if (note==-1) return;

      noteOff(note);
    });
  }
  readyPianoKeys();

  //////////////////////////////////////////////////////////
  var tick = 0;
  var playTick = 0;
  var scrollNoteId = 0;
  var base = 16;
  var unit; // (60 / song.bpm) / (base / 4)
  var isPaused = false;
  var isPlaying = false;

  var maxSongLength = 512;
  var notesLength = 64;
  var notesScale = 16; // in pixels
  var notesCanvasScale = 4; // in pixels

  function setBpm(bpm) {
    unit = (60 / bpm) / (base / 4);
    Playhead.setInterval(unit);
  }
  function updatePlayheads() {
    songPlayhead.style.left = (tick * 2) + 'px';
    notesPlayhead.style.left = ((tick - scrollNoteId) * 16) + 'px';
    playheadReturn.disabled = tick==0;

    var song = data.songs[data.editor.activeSongId];
    songLoopFrom.disabled = tick>=song.ticks;
  }
  function updateIntro() {
    songIntro.style.width = (data.songs[data.editor.activeSongId].loopFrom * 2) + 'px';
  }
  function stopAllVoices() {
    for (var i=0; i<4; i++) {
      audioSource.voices[i].stop();
    }
  }
  function playPause(letRing) {
    playTick = tick;

    if (!isPlaying) {
      isPlaying = true;
    }
    else {
      isPaused = !isPaused;
    }

    if (isPlaying && isPaused && !letRing) {
      stopAllVoices();
    }

    if (isPlaying && !isPaused) {
      // attempting to stop quantizing error in noteOnOff() from starting from full stop
      tick -= 1;
      playTick = tick-1;

      Playhead.play();
      document.body.classList.add('song-playing');
    }
    else {
      Playhead.stop();
      document.body.classList.remove('song-playing');
    }
  }
  function stopPlayback() {
    if (!isset(tick)) return; // NOTE: may be called before these variables are defined

    if (isPlaying && !isPaused) playPause();
  }
  function resetPlayheads() {
    stopAllVoices();
    tick = 0;
    if (data.editor.loopNotes) tick = scrollNoteId;
    playTick = tick-1;
    updatePlayheads();
  }
  function readyPlayback() {
    (new Voice(0)).playNote(0,0,0); // NOTE: required for play/pause to work without musically typing first

    for (var i=0; i<VoiceName.length; i++) {
      songVoices[i] = new Voice(i);
      soundVoices[i] = new Voice(i);
    }

    setBpm(120); // initializes unit

    Playhead.scheduleRepeat(function() {
      if (!isPlaying || isPaused) return;

      if (audioSource.type==AudioSource.Song) {
        var song = data.songs[data.editor.activeSongId];
        var voiceNotes = song.notes;
        for (var i=0; i<voiceNotes.length; i++) {
          var notes = voiceNotes[i];
          var j = tick * 3;
          var note = notes[j];
          if (note) {
            note -= 1;
            var octave = notes[j+1];
            var hold = notes[j+2];
            var freqIdx = getFrequencyIndex(note, octave);
            var pitch = Frequency[freqIdx];
            noteOnOff(note,octave,hold,i,true);
          }
        }
        tick += 1;

        if (data.editor.loopNotes && (tick>=scrollNoteId+notesLength || tick>=song.ticks)) {
          tick = scrollNoteId;
          playTick = tick-1; // TODO: yea or nay?
        }
        else if (tick>=song.ticks) {
          if (data.editor.loopSong && song.ticks>0) {
            tick -= song.ticks; // wrap
            tick += song.loopFrom; // jump to loop point
            if (song.loopFrom==0) playTick = -1; // fixes quantizing error
          }
          else {
            if (tick>0) tick -= 1;
            playPause(true);
          }
        }
      }
      else {
        var sound = data.sounds[data.editor.activeSoundId];
        var j = tick * 3;
        var note = sound.notes[j];
        if (note) {
          note -= 1;
          var octave = sound.notes[j+1];
          var hold = sound.notes[j+2];
          var freqIdx = getFrequencyIndex(note, octave);
          var pitch = Frequency[freqIdx];
          noteOnOff(note,octave,hold,sound.type,true);
        }
        tick += 1;

        if (tick>=sound.ticks) {
          if (data.editor.loopSong && sound.ticks>0) {
            tick -= sound.ticks; // wrap
          }
          else {
            tick = 0;
            playPause(true);
          }
        }
      }

      var when = Playhead.getCurrentTime();
      var quantized = Math.ceil(when / unit) * unit;
      var delay = (quantized - when) * 1000
      window.setTimeout(updatePlayheads, delay);
    }, unit);

    bind(document, 'keydown', function(event) {
      if (!inAudioMode() || inTextInput()) return;

      if (event.keyCode==32) { // space
        playPause();
        event.preventDefault();
      }
      else if (event.keyCode==13) { // return?
        resetPlayheads();
        event.preventDefault();
      }
    });
  }
  readyPlayback();

  function renderSongSelect() {
    var songs = [];
    for (var i=0; i<data.songs.length; i++) {
      var song = data.songs[i];
      if (!song) continue;
      songs.push({id:song.id,name:song.name});
    }
    songs.sort(sortByName);

    var optionsHTML = '';
    for (var i=0; i<songs.length; i++) {
      var song = songs[i];
      if (!song) continue;
      optionsHTML += '<li data-value="'+song.id+'">'+song.name+'</li>';
    }
    songSelect.innerHTML = optionsHTML;

    var groupHTML = '<li class="label">Action</li><li data-value="-2">Stop</li><li data-value="-1">Continue</li><li class="label">Song</li>'+optionsHTML;
    roomSongSelect.innerHTML = groupHTML;
    gameSongSelect.innerHTML = '<li data-value="-1">Nothing</li><li class="label">Song</li>'+optionsHTML;
    exitSongSelect.innerHTML = groupHTML;

    syncSelect(songSelect);
    syncSelect(roomSongSelect);
    syncSelect(gameSongSelect);
    syncSelect(exitSongSelect);

    setSelectValue(songSelect, data.editor.activeSongId);
    setSelectValue(roomSongSelect, data.rooms[data.editor.activeRoomId].song);
    setSelectValue(gameSongSelect, data.song);
  }
  renderSongSelect();

  // TODO: you should be able to create and select (move,copy,delete)
  // parts across all voices at once...
  // TODO: creating a split after the end of a song should zero fill
  // notes up to that point, effectively extending the song
  var selectedParts = [];
  function getPartMetas(voiceType) {
    var metas = []; // NOTE: x, x2, and width are in 4ths! y is voice
    var song = data.songs[data.editor.activeSongId];
    var start = 0;
    var end = song.splits.length;
    if (voiceType) {
      start = voiceType;
      end = start + 1;
    }
    for (var i=start; i<end; i++) {
      var splits = song.splits[i];
      var lastSplit = 0;
      for (var j=0; j<splits.length; j++) {
        var split = splits[j];
        metas.push({x:lastSplit, x2:split, y:i, width:split-lastSplit});
        lastSplit = split;
      }

      var len = (song.notes[i].length / 3) / 4; // in 4th notes
      if (lastSplit!=len) {
        metas.push({x:lastSplit, x2:len, y:i, width:len-lastSplit});
      }
    }
    return metas;
  }
  function getPartAt(x,y) {
    var song = data.songs[data.editor.activeSongId]
    var notes = song.notes[data.editor.activeVoiceId];
    var len = (notes.length / 3) / 4;
    if (startX<len) {
      var splits = song.splits[data.editor.activeVoiceId];
      var splitX = 0;
      for (var i=0; i<splits.length; i++) {
        var split = splits[i];
        if (split>startX) break;
        splitX = split;
      }
      return splitX;
    }
    return -1;
  }
  function deselectParts() {
    each('.song-part.active', function(i,node) {
      node.classList.remove('active');
    });
    selectedParts.length = 0;

    // NOTE: don't add to history, finalizeDrawHistory() handles that
  }
  function setLoopFrom() {
    var song = data.songs[data.editor.activeSongId];
    var oldValue = song.loopFrom;
    var newValue = tick;
    pushHistory('set loop point', function() {
      song.loopFrom = newValue;
      updateIntro();
    },function() {
      song.loopFrom = oldValue;
      updateIntro();
    });
  }
  function splitPart(split) {
    if (split==null) split = Math.round(tick / 4);

    var songId = data.editor.activeSongId;
    var voiceId = data.editor.activeVoiceId;
    var song = data.songs[songId];
    var splits = song.splits[voiceId];
    var notes = song.notes[voiceId];
    var len = (notes.length / 3) / 4;
    if (split>=len || splits.indexOf(split)>-1 || split==0) return;

    var oldSplits = clone(splits);
    var oldParts = clone(selectedParts);

    splits.push(split);
    splits.sort(sortNumeric);
    selectedParts.push(split);

    var newSplits = clone(splits);
    var newParts = clone(selectedParts);

    function cleanup() {
      renderParts();
    }
    cleanup();

    // TODO: history overkill?
    pushHistory('split part', function() {
      data.songs[songId].splits[voiceId] = clone(newSplits);
      selectedParts = clone(newParts);
      cleanup();
    },function() {
      data.songs[songId].splits[voiceId] = clone(oldSplits);
      selectedParts = clone(oldParts);
      cleanup();
    });
  }
  function joinParts() {
    if (selectedParts.length<=1) return;
    selectedParts.sort(sortNumeric);

    var songId = data.editor.activeSongId;
    var voiceId = data.editor.activeVoiceId;
    var song = data.songs[songId];
    var splits = song.splits[voiceId];
    var firstSplit = splits.indexOf(selectedParts[0]);
    var lastSplit = splits.indexOf(selectedParts[selectedParts.length-1]);

    var oldSplits = clone(splits);
    var oldParts = clone(selectedParts);
    for (var i=lastSplit; i>firstSplit; i--) {
      var split = splits[i];
      splits.splice(i,1);
      var k = selectedParts.indexOf(split);
      if (k>-1) selectedParts.splice(k,1);
    }
    var newSplits = clone(splits);
    var newParts = clone(selectedParts);

    renderParts();

    // TODO: history overkill?
    pushHistory('join parts', function() {
      data.songs[songId].splits[voiceId] = clone(newSplits);
      selectedParts = clone(newParts);
      renderParts();
    },function() {
      data.songs[songId].splits[voiceId] = clone(oldSplits);
      selectedParts = clone(oldParts);
      renderParts();
    }, true);
  }
  function deleteParts() {
    if (selectedParts.length==0) return;
    selectedParts.sort(sortNumeric);

    var songId = data.editor.activeSongId;
    var voiceId = data.editor.activeVoiceId;
    var metas = getPartMetas(voiceId);
    var song = data.songs[songId];
    var voices = song.notes;

    var oldSong = clone(song);
    var oldParts = clone(selectedParts);

    var wasTrailing = false;
    for (var i=selectedParts.length-1; i>=0; i--) {
      var partId = selectedParts[i];
      for (var j=0; j<metas.length; j++) {
        var meta = metas[j];
        if (meta.x==partId && meta.y==voiceId) {
          var voice = voices[meta.y];
          if (meta.x2*3*4==voice.length) {
            wasTrailing = true;
            voice.length -= meta.width*3*4;
            selectedParts.splice(i,1);
            var splits = song.splits[meta.y];
            var k = splits.indexOf(partId);
            if (k>-1) splits.splice(k,1);
          }
          else {
            var notes = voice.slice(meta.x*4*3,meta.x2*4*3);
            for (var k=0; k<(notes.length/3); k++) {
              setNoteAt((meta.x*4)+k, 0,0,0);
            }
          }
        }
      }
    }

    if (wasTrailing) { // update ticks
      var songLength = 0;
      for (var i=0; i<song.notes.length; i++) {
        var notes = song.notes[i];
        if (notes.length>songLength) songLength = notes.length;
      }
      if (songLength<song.ticks*3) {
        song.ticks = songLength / 3;
      }
    }

    var newSong = clone(song);
    var newParts = clone(selectedParts);

    renderNotes();
    renderSong();

    // TODO: history overkill?
    pushHistory('delete parts', function() {
      data.songs[songId] = clone(newSong);
      selectedParts = clone(newParts);
      renderNotes();
      renderSong();
    },function() {
      data.songs[songId] = clone(oldSong);
      selectedParts = clone(oldParts);
      renderNotes();
      renderSong();
    }, true);
  }
  function moveSelectedParts(dx,dy,copy) {
    // TODO: this is not honoring copy at all :\

    if (dx==0 && dy==0) return;

    selectedParts = selectedParts.filter(filterUnique);
    selectedParts.sort(sortNumeric);
    var activeVoiceId = data.editor.activeVoiceId;
    var metas = getPartMetas(activeVoiceId);
    var song = data.songs[data.editor.activeSongId]
    var voices = song.notes;

    // TODO: this is a disaster :\

    if (dx>0) selectedParts.reverse();

    var ox = dx * 4;
    for (var i=0; i<selectedParts.length; i++) {
      var partId = selectedParts[i];
      for (var j=0; j<metas.length; j++) {
        var meta = metas[j];
        if (meta.x==partId && meta.y==activeVoiceId) {
          // NOTE: can't use moveSelectedNotes() because its y refers to note, not voice (o.O; )
          var notes = voices[meta.y].slice(meta.x*4*3,meta.x2*4*3);
          var noteIds = [];
          for (var k=0; k<(notes.length/3); k++) {
            noteIds.push(k+(meta.x*4));
          }
          if (ox>0) noteIds.reverse();

          notes = voices[meta.y];
          for (var k=0; k<noteIds.length; k++) {
            var noteId = noteIds[k];
            var l = noteId * 3;
            var note = notes[l];
            var octave = notes[l+1];
            var hold = notes[l+2];

            if (!copy) setNoteAt(noteId, 0,0,0, meta.y);
            setNoteAt(ox+noteId, note,octave,hold, (dy+meta.y));
          }
        }
      }
    }
    // TODO: need to cleanup overlapping notes

    // move and integrate splits
    var bounds = [];
    var voiceId = dy+activeVoiceId;
    setActiveVoice(voiceId);
    for (var i=selectedParts.length-1; i>=0; i--) {
      var partId = selectedParts[i];
      for (var j=0; j<metas.length; j++) {
        var meta = metas[j];
        if (meta.x==partId && meta.y==activeVoiceId) {
          var adjX1 = partId + dx;
          var adjX2 = adjX1 + meta.width;
          bounds.push([adjX1,adjX2]);
          if (adjX1<=0 || adjX1>=notesLength) {
            selectedParts.splice(i,1);
          }
          else {
            splitPart(adjX1);
            selectedParts[i] = adjX1;
          }

          if (adjX2>0 && adjX2<notesLength) {
            splitPart(adjX2);
          }
        }
      }
    }

    // remove existing splits between two new/moved splits
    var splits = song.splits[activeVoiceId];
    for (var i=0; i<bounds.length; i++) {
      var b = bounds[i];
      for (var j=splits.length-1; j>=0; j--) {
        var partId = splits[j];
        if (partId>b[0] && partId<b[1]) {
          splits.splice(j,1);
        }
      }
    }
    // TODO: this might be injecting duplicate partIds!

    if (dx>0) selectedParts.reverse();
  }
  function highlightSelectedParts() {
    var voiceType = data.editor.activeVoiceId;
    var className = '.song-part';
    if (isCopying || isMoving) {
      var dy = moveY-startY;
      voiceType += dy;
      className += '.moving';
    }
    className += '[data-voice-type="'+voiceType+'"]';
    each(className, function(i,node) {
      var x = parseInt(node.dataset.songPartX);
      if (selectedParts.indexOf(x)>-1) {
        node.classList.add('active');
      }
    });
  }
  function renderParts() {
    var metas = getPartMetas();
    var partsHTML = '';
    for (var i=0; i<metas.length; i++) {
      var meta = metas[i];
      partsHTML += '<div class="song-part" data-song-part-x="'+meta.x+'" data-voice-type="'+meta.y+'" style="top:'+(meta.y*32)+'px;left:'+(meta.x*8)+'px;width:'+(meta.width*8)+'px;"></div>';
    }
    if (isCopying || isMoving) {
      var dx = moveX-startX;
      var dy = moveY-startY;
      for (var i=0; i<metas.length; i++) {
        var meta = metas[i];
        if (meta.y!=data.editor.activeVoiceId || selectedParts.indexOf(meta.x)==-1) continue;

        partsHTML += '<div class="song-part moving" data-song-part-x="'+meta.x+'" data-voice-type="'+(dy+meta.y)+'" style="top:'+((dy+meta.y)*32)+'px;left:'+((dx+meta.x)*8)+'px;width:'+(meta.width*8)+'px;"></div>';
      }
    }
    songParts.innerHTML = partsHTML;
    highlightSelectedParts();
  }
  function renderSong() {
    // songContext.fillStyle = 'black';
    songContext.clearRect(0,0,songCanvas.width,songCanvas.height);

    var voices = data.songs[data.editor.activeSongId].notes;
    for (var i=0; i<voices.length; i++) {
      var notes = voices[i];
      if (notes.length==0) continue;

      var len = notes.length / 3; // 16ths
      var ox = 0;
      var oy = i * 16;
      var width = len;

      songContext.fillStyle = uiLight;
      songContext.fillRect(0,oy,width,16);

      var metas = getPartMetas(i);
      var metaId = 0;
      var meta = metas[metaId];
      // print('first meta', meta);
      for (var j=0; j<len; j++) {
        if (j>=meta.x2*4) {
          metaId += 1;
          meta = metas[metaId];
        }

        var k = j * 3;
        var note = notes[k];
        if (!note) continue;
        note -= 1;

        var isSelected = meta.y==data.editor.activeVoiceId && selectedParts.indexOf(meta.x)!=-1;
        if (isSelected && isMoving && j>=meta.x*4 && j<meta.x2*4) {
          // we draw selected below
        }
        else {
          var x = j;
          var y = 11 - note;
          y += 2;
          var width = notes[k+2];
          songContext.fillStyle = uiDark;
          songContext.fillRect(ox+x,oy+y,width,1);
        }
      }
    }

    if (isCopying || isMoving) {
      var dx = moveX-startX;
      var dy = moveY-startY;
      for (var i=0; i<voices.length; i++) {
        var notes = voices[i];
        if (notes.length==0) continue;

        var len = notes.length / 3; // 16ths
        var ox = dx * 4;
        var oy = (dy+i) * 16;

        var metas = getPartMetas(i);
        var metaId = 0;
        var meta = metas[metaId];

        var isSelected = meta.y==data.editor.activeVoiceId && selectedParts.indexOf(meta.x)!=-1;
        if (isSelected) {
          if (isMoving) {
            songContext.fillStyle = uiLight;
            songContext.fillRect((dx+meta.x)*4,(dy+meta.y)*16,meta.width*4,16);
          }
          if (dy!=0) {
            songContext.fillStyle = uiLight50;
            songContext.fillRect((dx+meta.x)*4,(dy+meta.y)*16,meta.width*4,16);
          }
        }

        for (var j=0; j<len; j++) {
          if (j>=meta.x2*4) {
            metaId += 1;
            meta = metas[metaId];

            var isSelected = meta.y==data.editor.activeVoiceId && selectedParts.indexOf(meta.x)!=-1;
            if (isSelected) {
              if (isMoving) {
                songContext.fillStyle = uiLight;
                songContext.fillRect((dx+meta.x)*4,(dy+meta.y)*16,meta.width*4,16);
              }
              if (dy!=0) {
                songContext.fillStyle = uiLight50;
                songContext.fillRect((dx+meta.x)*4,(dy+meta.y)*16,meta.width*4,16);
              }
            }
          }

          var k = j * 3;
          var note = notes[k];
          if (!note) continue;
          note -= 1;

          var isSelected = meta.y==data.editor.activeVoiceId && selectedParts.indexOf(meta.x)!=-1;
          if (!isSelected) {
            // buh
          }
          else if (j>=meta.x*4 && j<meta.x2*4) {
            var x = j;
            var y = 11 - note;
            y += 2;
            var width = notes[k+2];
            songContext.fillStyle = uiDark50;
            songContext.fillRect(ox+x,oy+y,width,1);
          }
        }
      }
    }
    songImage.src = songCanvas.toDataURL('image/png');

    renderParts();
  }
  renderSong();
  renderTools('song', [
    {name:'select',	key:'default',	icon:'pointer'},
    {name:'lasso',	key:'shift',	icon:'lasso'},
    {name:'clone',	key:'option',	icon:'sheep'},
  ]);

  var selectedNotes = [];
  var selectedNoteId = -1;
  var note = one('#note');
  var notePitch = one('#note-pitch');
  var noteOctave = one('#note-octave');
  var noteHold = one('#note-hold');
  function syncSelectedNote() {
    if (selectedNoteId<0 || selectedNotes.length==0) {
      note.style.display = 'none';
      return;
    }

    var j = selectedNoteId * 3;
    var pitch = audioSource.notes[j] - 1;
    var octave = audioSource.notes[j+1];
    var hold = audioSource.notes[j+2];

    if (isCopying || (isMoving && !isSelecting)) {
      var dy = moveY-startY;
      pitch -= dy;
    }

    notePitch.innerHTML = notes[pitch];
    noteOctave.innerHTML = octave;
    noteHold.innerHTML = hold;
    note.style.display = 'flex';
  }
  function deselectNotes() {
    selectedNotes.length = 0;
    selectedNoteId = -1;
    syncSelectedNote();

  }
  function setSelectedNote(noteId) {
    selectedNoteId = noteId;
    syncSelectedNote();
  }
  function pushSelectedNote(noteId) {
    if (selectedNotes.length==0) {
      selectedNoteId = noteId;
    }
    selectedNotes.push(noteId);
    syncSelectedNote();
  }

  function renderNotes() {
    notesContext.fillStyle = uiLight;
    notesContext.fillRect(0,0,notesCanvas.width,notesCanvas.height);

    var gridOffset = (scrollNoteId % 16) / 4;
    document.documentElement.style.setProperty('--ui-grid-notes-x', -gridOffset * 64 + 'px');

    var notes = audioSource.notes;
    var noteX = scrollNoteId;
    var lastOctave = 4;
    // look backwards for last octave
    for (var i=noteX-1; i>=0; i--) {
      var j = i * 3;
      var note = notes[j];
      if (!note) continue;
      lastOctave = notes[j+1];
      break;
    }

    // look backwards for any previous note who's tail should be drawn onscreen
    for (var i=noteX-1; i>=0; i--) {
      var j = i * 3;
      var note = notes[j];
      if (!note) continue;
      var hold = notes[j+2];
      if (i+hold>scrollNoteId) noteX = i;
      else break;
    }

    var dx = scrollNoteId - noteX;
    for (var i=noteX; i<noteX+notesLength+dx; i++) {
      var j = i * 3;
      var note = notes[j];
      if (!note) continue; // not set or 0
      note -= 1;

      var octave = notes[j+1];

      var isSelected = selectedNotes.indexOf(i)!=-1;
      if (isSelected && isMoving && !isSelecting) {
        // buh
      }
      else {
        var offset = octave - lastOctave;
        var hold = notes[j+2];

        var y = (11 - note) * notesCanvasScale;
        var x = (i-noteX-dx) * notesCanvasScale;
        var width = hold * notesCanvasScale;
        var height = notesCanvasScale;

        notesContext.fillStyle = (isSelected && !isCopying) ? uiYellow : uiDark; // TODO: enable
        if (offset!=0) {
          if (offset>0) {
            if (hold>1) notesContext.fillRect(x+3,y,1,1);
            notesContext.fillRect(x+2,y+1,1+(hold>1?1:0),1);
            notesContext.fillRect(x+1,y+2,2+(hold>1?1:0),1);
            notesContext.fillRect(x,y+3,3+(hold>1?1:0),1);
          }
          else {
            notesContext.fillRect(x,y,3+(hold>1?1:0),1);
            notesContext.fillRect(x+1,y+1,2+(hold>1?1:0),1);
            notesContext.fillRect(x+2,y+2,1+(hold>1?1:0),1);
            if (hold>1) notesContext.fillRect(x+3,y+3,1,1);
          }

          width -= notesCanvasScale;
          x += notesCanvasScale;
        }
        if (width>0) {
          notesContext.fillRect(x,y,width-1,height);
        }
      }
      lastOctave = octave;
    }

    if (isCopying || (isMoving && !isSelecting)) {
      // preview copy location
      notesContext.fillStyle = uiYellow50;
      var dx = moveX-startX-scrollNoteId;
      var dy = moveY-startY;

      for (var i=0; i<selectedNotes.length; i++) {
        var noteId = selectedNotes[i];
        j = noteId * 3;
        var note = notes[j] - 1;
        var hold = notes[j+2];

        var x = (dx + noteId);
        if (x+hold<0) continue;
        if (x>notesLength) continue;
        if (x+hold>notesLength) hold = notesLength - x;
        if (hold<=0) continue;

        var y = (dy + (11 - note));
        if (y<0) y += 12;
        if (y>11) y -= 12;

        y *= notesCanvasScale;
        x *= notesCanvasScale;
        var width = hold * notesCanvasScale;
        var height = notesCanvasScale;

        notesContext.fillRect(x,y,width-1,height);
      }
    }

    notesImage.src = notesCanvas.toDataURL('image/png');
    syncSelectedNote();
  }
  renderNotes();
  renderTools('notes', [
    {name:'draw',	key:'default',	icon:'pencil'},
    {name:'lasso',	key:'shift',	icon:'lasso'},
    {name:'clone',	key:'option',	icon:'sheep'},
  ]);

  var voiceAttack = one('#voice-attack');
  var voiceDecay = one('#voice-decay');
  var voiceSustain = one('#voice-sustain');
  var voiceRelease = one('#voice-release');
  var voiceVolume = one('#voice-volume');
  var resetVoiceEnvelope = one('#reset-voice-envelope');

  function applyEnvelope(voiceId) {
    var envelope = getVoiceEnvelope(voiceId);
    var sourceVoice = audioSource.voices[voiceId];
    for (var key in envelope) {
      sourceVoice.envelope[key] = envelope[key];
    }
    for (var i in keyVoices[voiceId]) {
      var keyVoice = keyVoices[voiceId][i];
      for (var key in envelope) {
        keyVoice.envelope[key] = envelope[key];
      }
    }
  }
  function getVoiceEnvelope(voiceId) {
    var envelope = clone(Voice.defaultEnvelope);

    var sourceEnvelope;
    if (audioSource.type==AudioSource.Song) {
      var song = data.songs[data.editor.activeSongId];
      if (song.voices && song.voices[voiceId]) {
        sourceEnvelope = song.voices[voiceId];
      }
    }
    else {
      var sound = data.sounds[data.editor.activeSoundId];
      if (sound.envelope) {
        sourceEnvelope = sound.envelope;
      }
    }

    if (sourceEnvelope) {
      for (var key in sourceEnvelope) {
        envelope[key] = sourceEnvelope[key];
      }
    }
    return envelope;
  }
  function setVoiceEnvelope(voiceId, key, value) {
    if (audioSource.type==AudioSource.Song) {
      var song = data.songs[data.editor.activeSongId];
      // remove if default value
      if (value==Voice.defaultEnvelope[key]) {
        delete song.voices[voiceId][key]; // delete key
        if (Object.keys(song.voices[voiceId]).length==0) delete song.voices[voiceId]; // delete envelope
        if (isEmpty(song.voices)) delete song.voices; // delete array
        applyEnvelope(voiceId);
        return;
      }

      // add/update non-default value
      if (!song.voices) song.voices = [];
      if (!song.voices[voiceId]) song.voices[voiceId] = {};
      song.voices[voiceId][key] = value;
    }
    else {
      var sound = data.sounds[data.editor.activeSoundId];
      // remove if default value
      if (value==Voice.defaultEnvelope[key]) {
        delete sound.envelope[key]; // delete key
        if (Object.keys(sound.envelope).length==0) delete sound.envelope; // delete envelope
        applyEnvelope(voiceId);
        return;
      }

      // add/update non-default value
      if (!sound.envelope) sound.envelope = {};
      sound.envelope[key] = value;
    }


    applyEnvelope(voiceId);
  }
  function syncVoiceEnvelope() {
    var envelope = getVoiceEnvelope(audioSource.voice);
    voiceAttack.value = envelope.attack;
    voiceDecay.value = envelope.decay;
    voiceSustain.value = envelope.sustain;
    voiceRelease.value = envelope.release;
    voiceVolume.value = envelope.volume;
  }
  function setActiveVoice(voiceId) {
    allOff();
    if (voiceId<0) voiceId = 0;
    else if (voiceId>VoiceType.Noise) voiceId = VoiceType.Noise;
    data.editor.activeVoiceId = voiceId;

    each('.voice-list li.active', function(i,node) {
      node.classList.remove('active');
    });
    one('.voice-list li[data-voice-type="'+voiceId+'"]').classList.add('active');

    voiceName.innerHTML = VoiceName[voiceId];
    voiceIcon.className = 'icon voice-type-'+VoiceName[voiceId].toLowerCase();

    updateAudioSource();
    syncVoiceEnvelope();

    renderNotes();
  }
  setActiveVoice(data.editor.activeVoiceId);

  function bindEnvelope(input, key, max) {
    // TODO: mid-typing validation can mess with caret position...

    bind(input, 'focus', function(event) {
      // note starting value so we can fallback if we encounter invalid input
      var envelope = getVoiceEnvelope(audioSource.voice);
      input.dataset.defaultValue = envelope[key];
    })
    bind(input, 'keyup', blurOnReturn); // validing while typing was moving the caret, bad!
    bind(input, 'blur', function(event) {
      var rawValue = input.value;
      var oldValue = parseFloat(input.dataset.defaultValue);
      var newValue = parseFloat(rawValue);

      if (isNaN(newValue) || newValue<0 || !rawValue.match(/^([0-9]+)?\.?[0-9]+$/)) {
        input.value = oldValue;
        return;
      }

      if (isset(max) && newValue>max) {
        newValue = max;
        input.value = newValue;
      }

      if (oldValue!=newValue) {
        var voiceId = audioSource.voice;
        pushHistory('change voice '+key, function() {
          setVoiceEnvelope(voiceId, key, newValue);
          input.value = newValue;
        },function() {
          setVoiceEnvelope(voiceId, key, oldValue);
          input.value = oldValue;
        });
      }
    });
  }

  bindEnvelope(voiceAttack, 'attack');
  bindEnvelope(voiceDecay, 'decay');
  bindEnvelope(voiceSustain, 'sustain', 1);
  bindEnvelope(voiceRelease, 'release');
  bindEnvelope(voiceVolume, 'volume', 1);
  bind(resetVoiceEnvelope, 'click', function(event) {
    confirmAction('Are you sure you want to reset this voice envelope?', 'Reset', function(confirmed) {
      if (!confirmed) return;

      if (audioSource.type==AudioSource.Song) {
        var song = data.songs[data.editor.activeSongId];
        var voiceId = data.editor.activeVoiceId
        if (song.voices && song.voices[voiceId]) {
          var oldVoices = clone(song.voices);

          function cleanup() {
            applyEnvelope(voiceId);
            syncVoiceEnvelope();
          }

          pushHistory('reset voice envelope', function() {
            delete song.voices[voiceId]; // delete envelope
            if (isEmpty(song.voices)) delete song.voices; // delete array
            cleanup();
          },function() {
            song.voices = clone(oldVoices);
            cleanup();
          });
        }
      }
      else {
        var sound = data.sounds[data.editor.activeSoundId];
        var voiceId = sound.type;
        if (sound.envelope) {
          var oldEnvelope = clone(sound.envelope);

          function cleanup() {
            applyEnvelope(voiceId);
            syncVoiceEnvelope();
          }

          pushHistory('reset voice envelope', function() {
            delete sound.envelope; // delete envelope
            cleanup();
          },function() {
            sound.envelope = clone(oldEnvelope);
            cleanup();
          });
        }
      }
    });
  });

  function setScrollNote(noteId) {
    scrollNoteId = noteId;
    songNotes.style.left = (noteId * 2) + 'px';
    renderNotes();
    updatePlayheads();
  }

  function preventDeletingLastSong() {
    var total = 0;
    for (var i=0; i<data.songs.length; i++) {
      if (data.songs[i]) total += 1;
      if (total>1) break;
    }
    if (total>1) {
      each('#song-actions .delete', function(i,node) {
        node.style.visibility = 'visible';
      });
    }
    else {
      each('#song-actions .delete', function(i,node) {
        node.style.visibility = 'hidden';
      });
    }
  }
  function setActiveSong(songId) {
    if (!keyVoices) return;

    data.editor.activeSongId = songId;
    updateAudioSource();

    var song = data.songs[songId];
    songName.value = song.name;
    songName.title = '(song '+songId+')';
    songBpm.value = song.bpm;
    setSelectValue(songSelect, songId);
    setBpm(song.bpm);

    syncVoiceEnvelope();
    for (var i=0; i<VoiceName.length; i++) {
      applyEnvelope(i);
    }

    updateIntro();

    stopPlayback();

    resetPlayheads();
    preventDeletingLastSong();

    renderSong();
    setScrollNote(0);
  }
  setActiveSong(data.editor.activeSongId);

  function getNoteAt(x,y) {
    var noteId = -1;
    var notes = audioSource.notes;
    for (var i=0; i<=x; i++) {
      var j = i * 3;
      var note = notes[j];
      if (!note) continue;
      note -= 1;
      var noteY = 11 - note;
      if (noteY!=y) continue;
      var hold = notes[j+2];
      if (i<=x && i+hold>x) {
        noteId = i;
        break;
      }
    }
    return noteId;
  }
  // TODO: use audioSource.notes instead of data.songs[data.editor.activeSongId].notes[data.editor.activeVoiceId];
  function setNoteAt(x,note,octave,hold,voice) {
    var notes;
    if (isset(voice) && audioSource.type==AudioSource.Song) {
      notes = data.songs[data.editor.activeSongId].notes[voice];
    }
    else {
      notes = audioSource.notes;
    }

    // fill null with zeros
    for (var i=x-1; i>=0; i--) {
      var j = i * 3;
      if (isset(notes[j])) break;
      notes[j] = 0;
      notes[j+1] = 0;
      notes[j+2] = 0;
    }

    // write zeros beneath too
    for (var i=1; i<hold; i++) {
      var j = (x + i) * 3;
      if (isset(notes[j])) continue;
      notes[j] = 0;
      notes[j+1] = 0;
      notes[j+2] = 0;
    }

    // finally write the actual note
    var j = x * 3;
    notes[j] = note;
    notes[j+1] = octave;
    notes[j+2] = hold;

    var notesTicks = notes.length / 3;
    var source = audioSource.source;
    if (notesTicks>source.ticks) source.ticks = notesTicks;
  }
  function trimNoteTail(x) {
    var notes = audioSource.notes;
    for (var i=0; i<x; i++) {
      var j = i * 3;
      var note = notes[j];
      if (!note) continue;
      var hold = notes[j+2];
      if (i<x && i+hold>x) {
        setNoteAt(i,note,notes[j+1],x-i);
        break;
      }
    }
  }
  function trimNoteHead(x,hold) {
    var notes = audioSource.notes;
    var x2 = x + hold;
    for (var i=x+1; i<x2; i++) {
      var j = i * 3;
      var note = notes[j];
      if (!note) continue;
      var octave = notes[j+1];
      var hold = notes[j+2];
      hold += i - (x2);

      var k = selectedNotes.indexOf(i);
      if (k>-1) selectedNotes.splice(k,1);

      setNoteAt(i,0,0,0);

      if (hold>0) {
        setNoteAt(x2,note,octave,hold);

        if (k>-1) pushSelectedNote(x2);
      }
      break;
    }
  }
  function moveNote(noteId,dx,dy,copy) {
    if (dx==0 && dy==0) return;

    var notes = audioSource.notes;

    var j = noteId * 3;
    var note = notes[j];
    if (note==0) return; // TODO: yay or nay?
    var octave = notes[j+1];
    var hold = notes[j+2];

    if (dx!=0) {
      var newId = noteId + dx;
      if (newId+hold>0 && newId<maxSongLength) {
        if (newId<0) {
          hold += newId;
          newId = 0;
        }
        else if (newId+hold>=maxSongLength) {
          hold -= maxSongLength-newId;
        }

        if (!copy) setNoteAt(noteId,0,0,0);

        if (selectedNoteId==noteId) setSelectedNote(newId);
        var k = selectedNotes.indexOf(noteId);
        if (k>-1) selectedNotes[k] = newId;

        setNoteAt(newId,note,octave,hold);

        noteId = newId;

        if (copy) {
          var i = selectedNotes.indexOf(noteId);
          selectedNotes[i] = newId;
        }
      }
    }

    if (dy!=0) {
      note -= 1;
      var y = 11 - note;
      y += dy;

      while (y<0) {
        y += 12;
        octave += 1;
      }
      while (y>11) {
        y -= 12;
        octave -= 1;
      }

      if (octave<0) octave = 0;
      else if (octave>8) octave = 8;

      note = 11 - y;
      note += 1;
      setNoteAt(noteId, note, octave, hold);
    }
  }
  function moveSelectedNotes(dx,dy,copy) {
    selectedNotes.sort(sortNumeric);
    if (dx>0) selectedNotes.reverse();
    for (var i=0; i<selectedNotes.length; i++) {
      var noteId = selectedNotes[i];
      moveNote(noteId,dx,dy,copy);
    }

    var notes = audioSource.notes;
    for (var i=0; i<selectedNotes.length; i++) {
      var noteId = selectedNotes[i];
      var j = noteId * 3;
      var hold = notes[j+2];
      if (dx<0) trimNoteTail(noteId);
      else if (dx>0) trimNoteHead(noteId,hold)
    }

    if (dx>0) selectedNotes.reverse(); // TODO: is this necessary?
  }
  function tweakNote(noteId, od,hd) {
    var notes = audioSource.notes;
    var j = noteId * 3;
    var note = notes[j];
    var octave = notes[j+1];
    var hold = notes[j+2];
    if (od!=0) {
      octave += od;
      if (octave<0) octave = 0;
      else if (octave>8) octave = 8;
      setNoteAt(noteId,note,octave,hold);
    }
    if (hd!=0) {
      hold += hd;
      if (hold<1) hold = 1;
      if (noteId+hold>maxSongLength) hold = maxSongLength - noteId;
      setNoteAt(noteId,note,octave,hold);
    }
  }
  function tweakSelectedNotes(od,hd) {
    selectedNotes.sort(sortNumeric);
    for (var i=0; i<selectedNotes.length; i++) {
      var noteId = selectedNotes[i];
      tweakNote(noteId,od,hd);
    }

    if (hd!=0) {
      var notes = audioSource.notes;
      for (var i=0; i<selectedNotes.length; i++) {
        var noteId = selectedNotes[i];
        var j = noteId * 3;
        var hold = notes[j+2];
        if (hd<0) trimNoteTail(noteId);
        else if (hd>0) trimNoteHead(noteId,hold)
      }
    }
  }

  function bindStepper(id, action, x, y) {
    function updateStepper(dir) {
      if (audioSource.type==AudioSource.Song) {

      }
      else {

      }

      // TODO: branch on audioSource.type
      var songId = data.editor.activeSongId;
      var voiceId = data.editor.activeVoiceId;
      var oldNotes = clone(data.songs[songId].notes[voiceId]);

      action(dir*x,dir*y);

      function cleanup() {
        updateAudioSource();
        renderSong();
        renderNotes();
        syncSelectedNote();
      }
      cleanup();

      var newNotes = clone(data.songs[songId].notes[voiceId]);

      pushHistory('note editing', function() {
        data.songs[songId].notes[voiceId] = clone(newNotes);
        cleanup();
      },function() {
        data.songs[songId].notes[voiceId] = clone(oldNotes);
        cleanup();
      }, true);
    }

    bind(one(id+' button.step-left'), 'click', function(event) {
      updateStepper(-1);
    });
    bind(one(id+' button.step-right'), 'click', function(event) {
      updateStepper(1);
    });
  }

  bindStepper('#note-pitch-stepper', moveSelectedNotes, 0,-1);
  bindStepper('#note-octave-stepper', tweakSelectedNotes, 1,0);
  bindStepper('#note-hold-stepper', tweakSelectedNotes, 0,1);

  //////////////////////////////////////////////////////////
  function renderSoundSelect() {
    var sounds = [];
    for (var i=0; i<data.sounds.length; i++) {
      var sound = data.sounds[i];
      if (!sound) continue;
      sounds.push({id:sound.id,name:sound.name});
    }
    sounds.sort(sortByName);

    var optionsHTML = '';
    for (var i=0; i<sounds.length; i++) {
      var sound = sounds[i];
      if (!sound) continue;
      optionsHTML += '<li data-value="'+sound.id+'">'+sound.name+'</li>';
    }
    soundSelect.innerHTML = optionsHTML;
    syncSelect(soundSelect);
    setSelectValue(soundSelect, data.editor.activeSoundId);

    optionsHTML = '<li data-value="-1">Nothing</li><li class="label">Sound</li>' + optionsHTML;
    behaviorSoundSelect.innerHTML = optionsHTML;
    syncSelect(behaviorSoundSelect);
  }
  renderSoundSelect();
  function syncSoundProperties() {
    var sound = data.sounds[data.editor.activeSoundId];

    one('input[name="voice-type-radio"][value="'+sound.type+'"]').checked = true;
    updateAudioSource();
  }

  function preventDeletingLastSound() {
    var total = 0;
    for (var i=0; i<data.sounds.length; i++) {
      if (data.sounds[i]) total += 1;
      if (total>1) break;
    }
    if (total>1) {
      each('#sound-actions .delete', function(i,node) {
        node.style.visibility = 'visible';
      });
    }
    else {
      each('#sound-actions .delete', function(i,node) {
        node.style.visibility = 'hidden';
      });
    }
  }
  function setActiveSound(soundId) {
    if (!keyVoices) return;

    data.editor.activeSoundId = soundId;
    updateAudioSource();

    var sound = data.sounds[soundId];
    soundName.value = sound.name;
    soundName.title = '(sound '+soundId+')';
    soundBpm.value = sound.bpm;
    setSelectValue(soundSelect, soundId);

    syncVoiceEnvelope();
    for (var i=0; i<VoiceName.length; i++) {
      applyEnvelope(i);
    }

    preventDeletingLastSound();
    syncSoundProperties();

    setScrollNote(0);
  }
  setActiveSound(data.editor.activeSoundId);

  function UI_changeVoiceId(newVoiceId) {
    var sound = data.sounds[data.editor.activeSoundId];
    var oldVoiceId = sound.type;
    if (oldVoiceId!=newVoiceId) {
      pushHistory('change sound voice', function() {
        allOff();
        sound.type = newVoiceId;
        syncSoundProperties();
      },function() {
        sound.type = oldVoiceId;
        syncSoundProperties();
      });
    }
  }
  each('input[name="voice-type-radio"]', function(i,node) {
    bind(node, 'change', function(event) {
      UI_changeVoiceId(parseInt(node.value));
    });
  });

  //////////////////////////////////////////////////////////

  function UI_changeRoom() {
    var oldRoomId = data.editor.activeRoomId;
    var newRoomId = parseInt(getSelectValue(roomSelect));
    pushHistory('set active room', function() {
      setActiveRoom(newRoomId);
    },function() {
      setActiveRoom(oldRoomId);
    }, false, true);
  }
  function UI_changeScript() {
    var oldScriptId = data.editor.activeScriptId;
    var newScriptId = parseInt(getSelectValue(scriptSelect));
    if (oldScriptId!=newScriptId) {
      pushHistory('set active script', function() {
        setActiveScript(newScriptId);
      },function() {
        setActiveScript(oldScriptId);
      }, false, true);
    }
  }
  function UI_changeSong() {
    var oldSongId = data.editor.activeSongId;
    var newSongId = parseInt(getSelectValue(songSelect));
    if (oldSongId!=newSongId) {
      pushHistory('set active song', function() {
        setActiveSong(newSongId);
      },function() {
        setActiveSong(oldSongId);
      }, false, true);
    }
  }
  function UI_changeSound() {
    var oldSoundId = data.editor.activeSoundId;
    var newSoundId = parseInt(getSelectValue(soundSelect));
    if (oldSoundId!=newSoundId) {
      pushHistory('set active sound', function() {
        setActiveSound(newSoundId);
      },function() {
        setActiveSound(oldSoundId);
      }, false, true);
    }
  }

  bindSelect(gameCardSelect, 'select', function() {
    var oldId = data.card;
    var newId = parseInt(getSelectValue(gameCardSelect));
    if (newId!=oldId) {
      function tidy() {
        document.body.classList[data.editor.activeRoomId==data.card?'add':'remove']('is-card');
        setSelectValue(gameCardSelect, data.card);
        renderCard();
      }
      pushHistory('set game card', function() {
        data.card = newId;
        tidy();
      },function() {
        data.card = oldId;
        tidy();
      });
    }
  });
  bindSelect(roomSelect, 'select', UI_changeRoom);
  bindSelect(exitSelect, 'select', function onSelectExit(event) {
    var exit = getExit();
    var oldRoomId = exit.room;
    var newRoomId = parseInt(getSelectValue(exitSelect));
    if (oldRoomId!=newRoomId) {
      var activeRoomId = data.editor.activeRoomId;
      var activeExitId = data.editor.activeExitId;

      var oldExit = clone(exit);
      var newExit = clone(exit);

      newExit.room = newRoomId;
      if (newExit.room==-1) {
        delete newExit.tx;
        delete newExit.ty;
      }
      else {
        newExit.tx = -1;
        newExit.ty = -1;
      }

      var oldExitType = getExitType(exit);
      var deletePair = oldExitType==ExitType.Edge && exit.room!=-1 && exit.tx!=-1 && exit.ty!=-1;
      var oldPairExits,newPairExits,pairRoomId;
      if (deletePair) {
        pairRoomId = oldExit.room;
        var pair = getExitAt(oldExit.tx,oldExit.ty,oldExit.room);
        oldPairExits = clone(data.rooms[pairRoomId].exits);
        newPairExits = clone(oldPairExits);

        newPairExits.splice(pair.id,1);
        for (var j=pair.id; j<newPairExits.length; j++) {
          newPairExits[j].id = j;
        }
      }

      pushHistory('set exit room', function() {
        data.rooms[activeRoomId].exits[activeExitId] = newExit;
        if (deletePair) data.rooms[pairRoomId].exits = clone(newPairExits);
        syncExitProperties();
        renderRoom();
      },function() {
        data.rooms[activeRoomId].exits[activeExitId] = oldExit;
        if (deletePair) data.rooms[pairRoomId].exits = clone(oldPairExits);
        syncExitProperties();
        renderRoom();
      });
    }
  });
  bindSelect(scriptSelect, 'select', UI_changeScript);
  bindSelect(songSelect, 'select', UI_changeSong);
  bindSelect(soundSelect, 'select', UI_changeSound);
  bindSelect(behaviorSoundSelect, 'select', function(event) {
    var tile = data.tiles[data.editor.activeTileId];
    var oldId = isset(tile.sound) ? tile.sound : -1;
    var newId = parseInt(getSelectValue(behaviorSoundSelect));

    if (newId!=-1) {
      stopPlayback();
      resetPlayheads();
      setSoundAudioSource(newId);
      setActiveSound(newId);
      playPause();
    }

    pushHistory('set game song', function() {
      if (newId!=-1) tile.sound = newId;
      else delete tile.sound;
      setSelectValue(behaviorSoundSelect, newId);
    },function() {
      if (oldId!=-1) tile.sound = oldId;
      else delete tile.sound;
      setSelectValue(behaviorSoundSelect, oldId);
    });
  });
  bindSelect(roomSongSelect, 'select', function(event) {
    var room = data.rooms[data.editor.activeRoomId];
    var oldId = room.song;
    var newId = parseInt(getSelectValue(roomSongSelect));
    pushHistory('set room song', function() {
      room.song = newId;
      setSelectValue(roomSongSelect, newId);
    },function() {
      room.song = oldId;
      setSelectValue(roomSongSelect, oldId);
    });
  });
  bindSelect(gameSongSelect, 'select', function(event) {
    var oldId = data.song;
    var newId = parseInt(getSelectValue(gameSongSelect));
    pushHistory('set game song', function() {
      data.song = newId;
      setSelectValue(gameSongSelect, newId);
    },function() {
      data.song = oldId;
      setSelectValue(gameSongSelect, oldId);
    });
  });
  bindSelect(exitSongSelect, 'select', function(event) {
    var exit = data.rooms[data.editor.activeRoomId].exits[data.editor.activeExitId];
    var oldId = exit.song;
    var newId = parseInt(getSelectValue(exitSongSelect));
    pushHistory('set exit song', function() {
      exit.song = newId;
      setSelectValue(exitSongSelect, newId);
    },function() {
      exit.song = oldId;
      setSelectValue(exitSongSelect, oldId);
    });
  });


  //////////////////////////////////////////////////////////
  bind(one('#script-actions .delete'), 'click', function(event) {
    confirmAction('Delete this script?', 'Delete', function(confirmed) {
      if (!confirmed) return;

      // TODO: history overkill?
      var oldData = clone(data);
      var activeScriptId = data.editor.activeScriptId;
      function cleanup() {
        setActiveScript(data.editor.activeScriptId);
        renderScriptSelect();
        renderRecentScripts();
      }

      pushHistory('delete script', function() {
        deleteScript(activeScriptId);
        cleanup();
      },function() {
        data = clone(oldData);
        cleanup();
      });
    });
  });

  //////////////////////////////////////////////////////////
  // font actions
  function UI_invertCharOrPipe() {
    var activePipeId = data.editor.activePipeId;
    if (activePipeId>-1) {
      var oldData = clone(data.font.pipe[activePipeId]);
      var newData = clone(oldData);
      invertFrameData(newData);

      pushHistory('invert pipe tile', function() {
        data.font.pipe[activePipeId] = clone(newData);
        cachePipeImageData(activePipeId);
        renderFont();
      },function() {
        data.font.pipe[activePipeId] = clone(oldData);
        cachePipeImageData(activePipeId);
        renderFont();
      });
    }
    else {
      var activeCharId = data.editor.activeCharId;
      var oldData = clone(data.font.chars[activeCharId]);
      var newData = clone(oldData);
      invertFrameData(newData);

      pushHistory('invert char tile', function() {
        data.font.chars[activeCharId] = clone(newData);
        cacheCharImageData(activeCharId);
        renderFont();
      },function() {
        data.font.chars[activeCharId] = clone(oldData);
        cacheCharImageData(activeCharId);
        renderFont();
      });
    }
  }
  function UI_invertFont() {
    var oldFont = clone(data.font);
    var newFont = clone(data.font);

    for (var i=0; i<newFont.pipe.length; i++) {
      invertFrameData(newFont.pipe[i]);
    }
    for (var i=0; i<newFont.chars.length; i++) {
      invertFrameData(newFont.chars[i]);
    }

    function cleanup() {
      for (var i=0; i<data.font.pipe.length; i++) {
        cachePipeImageData(i);
      }
      for (var i=0; i<data.font.chars.length; i++) {
        cacheCharImageData(i);
      }
      renderFont();
    }

    pushHistory('invert entire font', function() {
      data.font = clone(newFont);
      cleanup();
    },function() {
      data.font = clone(oldFont);
      cleanup();
    });
  }
  bind(customText, 'keyup', function(event) {
    var oldText = data.editor.sampleText;
    var newText = customText.value;
    if (oldText!=newText) {
      pushHistory('set custom text', function() {
        data.editor.sampleText = newText;
        renderText();
      },function() {
        data.editor.sampleText = oldText;
        renderText();
      });
    }
  });
  each('input[name="font-text-radio"]', function(i,node) {
    bind(node, 'change', function(event) {
      var oldTextId = data.editor.activeTextId;
      var newTextId = parseInt(node.value);
      if (oldTextId!=newTextId) {
        pushHistory('set active text id', function() {
          setActiveText(newTextId);
          renderText();
        },function() {
          setActiveText(oldTextId);
          renderText();
        }, false, true);
      }
    });
  });
  each('input[name="font-type-radio"]', function(i,node) {
    bind(node, 'change', function(event) {
      var oldFont = clone(data.font);
      var newFont = clone(data.font);

      var oldType = oldFont.type;
      var newType = parseInt(node.value);

      function abort() {
        one('input[name="font-type-radio"][value="'+oldType+'"]').checked = true;
      }
      function proceed() {
        newFont.type = newType;
        function cleanup() {
          // recache font
          for (var i=0; i<data.font.pipe.length; i++) {
            cachePipeImageData(i);
          }
          for (var i=0; i<data.font.chars.length; i++) {
            cacheCharImageData(i);
          }
          renderFont();
        }
        pushHistory('set new font', function() {
          data.font = clone(newFont);
          cleanup();
        },function() {
          data.font = clone(oldFont);
          cleanup();
        });
      }

      if (newType==FontType.FullWidth) {
        confirmAction(['Are you sure you want to change to a full-width font?', 'Any changes to the default half-width font will be discarded.'], 'Change', function(confirmed) {
          if (confirmed) {
            newFont = clone(default8x8Font);
            proceed();
          }
          else {
            abort();
          }
        });
      }
      else {
        confirmAction(['Are you sure you want to change to a half-width font?', 'Any changes to the default full-width font will be discarded.'], 'Change', function(confirmed) {
          if (confirmed) {
            newFont = clone(default4x8Font);
            proceed();
          }
          else {
            abort();
          }
        });
      }
    });
  });
  bind(one('#char-modifiers .clear'), 'click', function(event) {
    confirmAction('Are you sure you want to erase this tile?', 'Erase', function(confirmed) {
      if (!confirmed) return;

      var clearColor = data.font.chars[0][0];
      var activePipeId = data.editor.activePipeId;
      if (activePipeId>-1) {
        var oldData = clone(data.font.pipe[activePipeId]);
        var newData = newFrameData(clearColor);

        pushHistory('erase pipe tile', function() {
          data.font.pipe[activePipeId] = clone(newData);
          cachePipeImageData(activePipeId);
          renderFont();
        },function() {
          data.font.pipe[activePipeId] = clone(oldData);
          cachePipeImageData(activePipeId);
          renderFont();
        });
      }
      else {
        var activeCharId = data.editor.activeCharId;
        var oldData = clone(data.font.chars[activeCharId]);
        var newData = newFrameData(clearColor);

        pushHistory('erase char tile', function() {
          data.font.chars[activeCharId] = clone(newData);
          cacheCharImageData(activeCharId);
          renderFont();
        },function() {
          data.font.chars[activeCharId] = clone(oldData);
          cacheCharImageData(activeCharId);
          renderFont();
        });
      }
    });
  });
  bind(one('#char-modifiers .invert'), 'click', UI_invertCharOrPipe);
  bind(one('#font-modifiers .clear'), 'click', function(event) {
    confirmAction('Are you sure you want to erase this entire font?', 'Erase', function(confirmed) {
      if (!confirmed) return;

      var oldFont = clone(data.font);
      var newFont = clone(data.font);

      var clearColor = newFont.chars[0][0];
      for (var i=0; i<newFont.pipe.length; i++) {
        newFont.pipe[i] = newFrameData(clearColor);
      }
      for (var i=0; i<newFont.chars.length; i++) {
        newFont.chars[i] = newFrameData(clearColor);
      }

      function cleanup() {
        for (var i=0; i<data.font.pipe.length; i++) {
          cachePipeImageData(i);
        }
        for (var i=0; i<data.font.chars.length; i++) {
          cacheCharImageData(i);
        }
        renderFont();
      }

      pushHistory('erase entire font', function() {
        data.font = clone(newFont);
        cleanup();
      },function() {
        data.font = clone(oldFont);
        cleanup();
      });
    });
  });
  bind(one('#font-modifiers .invert'), 'click', UI_invertFont);


  //////////////////////////////////////////////////////////
  // export/import font
  var fontCanvas = document.createElement('canvas');
  var fontContext = fontCanvas.getContext('2d');
  fontCanvas.width = 20 * tileWidth;
  fontCanvas.height = 8 * tileHeight;
  function exportFont() {
    fontContext.clearRect(0,0,fontCanvas.width,fontCanvas.height);

    var charWidth = tileWidth;
    if (data.font.type==FontType.HalfWidth) {
      charWidth /= 2;
    }

    function exportFrameData(frameData, cx,cy,dataWidth) {
      frameContext.fillStyle = 'black';
      frameContext.fillRect(0,0,dataWidth,tileHeight);
      frameContext.fillStyle = 'white';

      for (var y=0; y<tileHeight; y++) {
        for (var x=0; x<dataWidth; x++) {
          var i = y * tileWidth + x;
          if (frameData[i]==0) {
            frameContext.fillRect(x,y,1,1);
          }
        }
      }
      fontContext.putImageData(frameContext.getImageData(0,0,tileWidth,tileHeight), cx*tileWidth,cy*tileHeight);
    }

    var cols = 20;
    var rows = 8;

    // chars
    for (var row=0; row<5; row++) {
      for (var col=0; col<cols; col++) {
        var frameData = data.font.chars[(row * cols) + col];
        if (!frameData) break;

        frameContext.clearRect(0,0,tileWidth,tileHeight);
        exportFrameData(frameData,col,row,charWidth);
      }
    }
    // pipe
    for (var row=0;row<3;row++) {
      for (var col=0;col<3;col++) {
        var frameData = data.font.pipe[(row * 3) + col];
        exportFrameData(frameData,col,row+5,tileWidth);
      }
    }

    // arrows
    for (var col=0;col<5;col++) {
      var frameData = data.font.pipe[9 + col];
      exportFrameData(frameData,col+3,5,tileWidth);
    }

    var a = document.createElement('a');
    a.href = fontCanvas.toDataURL('image/png');
    a.download = 'pulp-font-'+(data.font.type==FontType.HalfWidth?'half':'full')+'-width-table-8-8.png';
    a.click();
  }
  function importFont(event) {
    var files = event.target.files;
    if (files.length==1) {
      var file = files[0];
      var reader = new FileReader;
      reader.onload = function(e) {
        var image = new Image;
        image.onload = function() {
          if (image.width!=fontCanvas.width || image.height!=fontCanvas.height) {
            return showAlert('Invalid font image data.'); // TODO: document or explain this better
          }

          var oldFont = clone(data.font);

          data.font.type = file.name.match(/\bhalf-width\b/) ? FontType.HalfWidth : FontType.FullWidth;

          fontContext.clearRect(0,0,fontCanvas.width,fontCanvas.height);
          fontContext.drawImage(image, 0,0);

          function importPixels(cx,cy) {
            var imageData = fontContext.getImageData(cx*tileWidth,cy*tileHeight,tileWidth,tileHeight).data;
            var pixels = [];
            for (var j=0; j<imageData.length; j+=4) {
              pixels[j/4] = imageData[j]==0?1:0;
            }
            return pixels;
          }

          // chars
          var cols = 20;
          for (var i=0; i<data.font.chars.length; i++) {
            var row = Math.floor(i / cols);
            var col = i - (row * cols);
            data.font.chars[i] = importPixels(col,row);
          }

          // pipes
          for (var row=0;row<3;row++) {
            for (var col=0;col<3;col++) {
              var i = (row * 3) + col;
              data.font.pipe[i] = importPixels(col,row+5);
            }
          }

          // arrows
          for (var col=0;col<5;col++) {
            var i = 9+col;
            data.font.pipe[i] = importPixels(col+3,5);
          }

          var newFont = clone(data.font);

          function cleanup() {
            for (var i=0; i<data.font.chars.length; i++) {
              cacheCharImageData(i);
            }
            for (var i=0; i<data.font.pipe.length; i++) {
              cachePipeImageData(i);
            }

            markDirty();
            renderFont();
          }

          pushHistory('import font', function() {
            data.font = clone(newFont);
            cleanup();
          },function() {
            data.font = clone(oldFont);
            cleanup();
          });
        };
        image.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
    event.target.value = null;
  }
  var importFontOverride = false;
  bind(one('#import-font input'), 'click', function(event) {
    if (!importFontOverride) {
      event.preventDefault();
      confirmAction('Are you sure you want to replace this entire font?', 'Import', function(confirmed) {
        if (!confirmed) return;
        importFontOverride = true;
        one('#import-font input').click();
      });
    }
    else {
      importFontOverride = false;
    }
  });
  bind(one('#import-font input'), 'change', importFont);
  bind(one('#export-font'), 'click', exportFont);

  //////////////////////////////////////////////////////////
  // export/import tiles
  var exportTilesType = 'all';
  var exportTilesSelect = one('#export-tiles-select');
  bindSelect(exportTilesSelect, 'select', function(event) {
    exportTilesType = getSelectValue(exportTilesSelect);
  });
  bind(one('#export-tiles'), 'click', function(event) {
    showOverlay('export');
  });
  one('#overlay-content-export').show = function() {
    // reset select default
    exportTilesType = 'all';
    setSelectValue(exportTilesSelect, exportTilesType);
  };
  bind(one('#button-export-tiles'), 'click', function(event) {
    exportTiles();
    hideOverlay();
  });

  function exportTiles() {
    // ready bulk exporting object
    var layers = [{id:data.editor.activeLayerId}];
    if (exportTilesType=='all') {
      layers = [{id:1},{id:2},{id:3},{id:4}];
    }

    // populate export object
    if (exportTilesType=='tile') {
      layers[0].tiles = [data.editor.activeTileId];
    }
    else {
      for (var i=0; i<layers.length; i++) {
        var layer = layers[i];
        var tileType = LayerToTileType[layer.id];
        layer.tiles = data.editor.sortedTiles[tileType];
      }
    }

    // now group by type (single frames, multiple frames)
    var exportSets = [];
    for (var i=0; i<layers.length; i++) {
      var layer = layers[i];
      var layerName = LayerToName[layer.id];
      var layerSet = {type:'layer',layer:layerName,frames:[],};
      for (var j=0; j<layer.tiles.length; j++) {
        var tileId = layer.tiles[j];
        var tile = data.tiles[tileId];
        if (tile.frames.length>1) {
          var tileSet = {type:'tile',layer:layerName,fps:tile.fps,frames:tile.frames,};
          exportSets.push(tileSet);
        }
        else {
          layerSet.frames.push(tile.frames[0]);
        }
      }
      if (layerSet.frames.length>0) {
        exportSets.push(layerSet);
      }
    }

    function exportFrameData(ctx, frameData, cx,cy) {
      frameContext.fillStyle = 'black';
      frameContext.fillRect(0,0,tileWidth,tileHeight);
      frameContext.fillStyle = 'white';

      for (var y=0; y<tileHeight; y++) {
        for (var x=0; x<tileWidth; x++) {
          var i = y * tileWidth + x;
          if (frameData[i]==0) {
            frameContext.fillRect(x,y,1,1);
          }
        }
      }
      ctx.putImageData(frameContext.getImageData(0,0,tileWidth,tileHeight), cx*tileWidth,cy*tileHeight);
    }

    var files = [];
    var tile = 0;
    for (var i=0; i<exportSets.length; i++) {
      var tileSet = exportSets[i];
      var filename = 'pulp-';

      // filenames are slightly different between bu
      if (tileSet.type=='tile') {
        filename += `tile-${tile++}-`;
        filename += `layer-${tileSet.layer}-`;
        filename += `fps-${tileSet.fps}-`;
      }
      else {
        filename += 'tiles-';
        filename += `layer-${tileSet.layer}-`;
      }

      filename += `count-${tileSet.frames.length}-`;
      filename += 'table-8-8.png';

      var cols = Math.min(tileSet.frames.length, 20);
      var rows = Math.ceil(tileSet.frames.length / 20);

      var width = cols * tileWidth;
      var height = rows * tileHeight;

      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      canvas.width = width;
      canvas.height = height;

      for (var row=0; row<rows; row++) {
        for (var col=0; col<cols; col++) {
          var j = row * cols + col;
          if (j>=tileSet.frames.length) break;
          var frameData = data.frames[tileSet.frames[j]].data;
          exportFrameData(ctx,frameData,col,row);
        }
      }

      files.push({name:filename, data:canvas.toDataURL('image/png')});
    }

    if (files.length>1) { // zip multiple
      var zip = new JSZip;
      for (var i=0; i<files.length; i++) {
        var file = files[i];
        var pngData = file.data.replace(/^data:image\/png;base64,/,'');
        zip.file(file.name, pngData, {base64:true});
      }
      zip.generateAsync({type:"base64"}).then(function(content) {
        var a = document.createElement('a');
        a.type = 'application/zip';
        a.href = 'data:' + a.type + ';base64,' + content;
        a.download = 'pulp-tiles.zip';
        a.click();
      });
    }
    else { // direct download single
      var file = files[0];
      var a = document.createElement('a');
      a.href = file.data;
      a.download = file.name;
      a.click();
    }
  }
  function importTiles(event) {
    var files = event.target.files;
    var images = [];
    var totalImages = 0;
    var loadedImages = 0;
    function importImages() {
      var oldData = clone(data);
      var oldTileId = data.editor.activeTileId;
      var oldFrameId = data.editor.activeFrameId;

      function importPixels(ctx,cx,cy) {
        var imageData = ctx.getImageData(cx*tileWidth,cy*tileHeight,tileWidth,tileHeight).data;
        var pixels = [];
        for (var j=0; j<imageData.length; j+=4) {
          if (imageData[j+3]==0) return null; // transparent pixel, empty tile
          pixels[j/4] = imageData[j]==0?1:0;
        }
        return pixels;
      }

      var newFrameIds = [];
      for (var i=0; i<images.length; i++) {
        var image = images[i];
        var cols = image.data.width / tileWidth;
        var rows = image.data.height / tileHeight;

        var matches = image.name.match(/^pulp-(tiles?)-(?:[0-9]+-)?layer-([^-]+)-(?:fps-([0-9]+)-)?count-([0-9]+)/)||[];
        var type = matches[1] || 'tiles';
        var layer = matches[2] || 'World';
        var fps = parseInt(matches[3]||'0');
        var count = parseInt(matches[4]||'0')||(cols * rows);

        var layerId = Layer[layer];
        var tileType = LayerToTileType[layerId];

        // load the image into a tmp canvas
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = image.data.width;
        canvas.height = image.data.height;
        ctx.drawImage(image.data,0,0);

        addFrameTimer(fps);

        var newTile = null;
        for (var row=0; row<rows; row++) {
          for (var col=0; col<cols; col++) {
            var j = row * cols + col;
            if (j>=count) break;
            var frameData = importPixels(ctx,col,row);
            if (!frameData) continue;

            if (type=='tile' && newTile) {
              // add frame, update its data
              var newFrameId = addFrame();
              var newFrame = data.frames[newFrameId];
              newFrame.data = frameData;
              cacheFrameImageData(newFrameId);
              newTile.frames.push(newFrameId);
              newFrameIds.push(newFrameId);
            }
            else {
              // add tile, update its frame data;
              var newTileId = addTile(tileType);
              data.editor.sortedTiles[tileType].push(newTileId);
              newTile = data.tiles[newTileId];
              newTile.fps = fps;
              var newFrameId = newTile.frames[0];
              var newFrame = data.frames[newFrameId];
              newFrame.data = frameData;
              cacheFrameImageData(newFrameId);
              newFrameIds.push(newFrameId);
            }
          }
        }
      }

      newFrameIds.sort(sortNumeric);
      var newData = clone(data);

      pushHistory('import tiles', function() {
        data = clone(newData);
        for (var i=0; i<newFrameIds.length; i++) {
          cacheFrameImageData(newFrameIds[i]);
        }
        markDirty();
        renderTiles();
        setActiveTile(oldTileId,oldFrameId);
      },function() {
        data = clone(oldData);
        for (var i=newFrameIds.length-1; i>=0; i--) {
          deleteImageData(newFrameIds[i]);
        }
        markDirty();
        renderTiles();
        setActiveTile(oldTileId,oldFrameId);
      });
    }
    function addImage(name,img) {
      images.push({name:name, data:img});

      loadedImages += 1;
      if (loadedImages==totalImages) {
        importImages();
      }
    }
    for (var i=0; i<files.length; i++) {
      var file = files[i];
      if (file.type=='image/png') { // png
        if (file.name.match(/table-8-8\.png$/)) {
          totalImages += 1;
          var reader = new FileReader;
          reader.onload = function(e) {
            var image = new Image;
            image.onload = function() {
              addImage(file.name,image);
            };
            image.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }
      }
      else { // zip
        JSZip.loadAsync(file).then(function(zip) {
          zip.forEach(function(_,entry) {
            if (entry.name.match(/table-8-8\.png$/)) {
              totalImages += 1;
              entry.async('base64').then(function(base64) {
                var image = new Image;
                image.onload = function() {
                  addImage(entry.name,image);
                };
                image.src = 'data:image/png;base64,'+base64;
              });
            }
          });
        });
      }
    }
    event.target.value = null;
  }
  bind(one('#import-tiles input'), 'change', importTiles);

  //////////////////////////////////////////////////////////
  // download pulp audio runtime bundle
  var pulpAudioLua;
  var pulpAudioHTML = '';
  var doBundle = false;
  var seq = new Sequence();
  seq.get('/static/pulp/lua/pulp-audio.lua', function(lua) {
    pulpAudioLua = lua;
  });
  seq.get('/static/pulp/lua/readme.html', function(html) {
    pulpAudioHTML = html;
  });
  seq.run(function() {
    if (doBundle) {
      // tried to download before we were ready, do it now
      doBundle = false;
      bundleAudio();
    }
  });

  function bundleAudio() {
    if (!pulpAudioLua) {
      // hasn't loaded yet
      doBundle = true;
      return;
    }

    var zip = new JSZip;
    zip.file('pulp-audio.lua', pulpAudioLua);
    zip.file('Pulp Audio Runtime.html', pulpAudioHTML);
    zip.file('pulp-songs.json', JSON.stringify(data.songs));
    zip.file('pulp-sounds.json', JSON.stringify(data.sounds));
    zip.generateAsync({type:"base64"}).then(function(content) {
      var a = document.createElement('a');
      a.type = 'application/zip';
      a.href = 'data:' + a.type + ';base64,' + content;
      a.download = 'pulp-audio.zip';
      a.click();
    });
  }
  bind(one('#download-audio-runtime'), 'click', bundleAudio);

  // export/import songs
  function exportSongs() {
    var json = JSON.stringify(data.songs);
    var a = document.createElement('a');
    var blob = new Blob([json], {'type':'application/octet-stream'});
    a.href = window.URL.createObjectURL(blob);
    a.download = 'pulp-songs.json';
    a.click();
  }
  function importSongs(event) {
    var files = event.target.files;
    if (files.length==1) {
      var reader = new FileReader;
      reader.onload = function(e) {
        var json = e.target.result;
        var songs = JSON.parse(json);

        var oldSongs = clone(data.songs);
        for (var i=0; i<songs.length; i++) {
          var song = songs[i];
          var j = data.songs.findIndex(s => s.name==song.name);
          if (j==-1) j = addSong();
          song.id = j;
          data.songs[j] = song;
        }
        var newSongs = clone(data.songs);

        var songId = data.editor.activeSongId;
        function cleanup() {
          updateAudioSource();
          setActiveSong(songId);
          renderSongSelect();
        }

        pushHistory('import songs', function() {
          data.songs = clone(newSongs);
          cleanup();
        },function() {
          data.songs = clone(oldSongs);
          cleanup();
        });
      };
      reader.readAsText(files[0]);
    }
    event.target.value = null;
  }
  bind(one('#export-songs'), 'click', exportSongs);
  var importSongsOverride = false;
  bind(one('#import-songs input'), 'click', function(event) {
    if (!importSongsOverride) {
      event.preventDefault();
      confirmAction('Imported songs will replace any songs with the same name', 'Import', function(confirmed) {
        if (!confirmed) return;
        importSongsOverride = true;
        one('#import-songs input').click();
      });
    }
    else {
      importSongsOverride = false;
    }
  });
  bind(one('#import-songs input'), 'change', importSongs);

  //////////////////////////////////////////////////////////
  // export/import sounds
  function exportSounds() {
    var json = JSON.stringify(data.sounds);
    var a = document.createElement('a');
    var blob = new Blob([json], {'type':'application/octet-stream'});
    a.href = window.URL.createObjectURL(blob);
    a.download = 'pulp-sounds.json';
    a.click();
  }
  function importSounds(event) {
    var files = event.target.files;
    if (files.length==1) {
      var reader = new FileReader;
      reader.onload = function(e) {
        var json = e.target.result;
        var sounds = JSON.parse(json);

        var oldSounds = clone(data.sounds);
        for (var i=0; i<sounds.length; i++) {
          var sound = sounds[i];
          var j = data.sounds.findIndex(s => s.name==sound.name);
          if (j==-1) j = addSound();
          sound.id = j;
          data.sounds[j] = sound;
        }
        var newSounds = clone(data.sounds);

        var soundId = data.editor.activeSoundId;
        function cleanup() {
          updateAudioSource();
          setActiveSound(soundId);
          renderSoundSelect();
        }

        pushHistory('import sounds', function() {
          data.sounds = clone(newSounds);
          cleanup();
        },function() {
          data.sounds = clone(oldSounds);
          cleanup();
        });
      };
      reader.readAsText(files[0]);
    }
    event.target.value = null;
  }
  bind(one('#export-sounds'), 'click', exportSounds);
  var importSoundsOverride = false;
  bind(one('#import-sounds input'), 'click', function(event) {
    if (!importSoundsOverride) {
      event.preventDefault();
      confirmAction('Imported sounds will replace any sounds with the same name', 'Import', function(confirmed) {
        if (!confirmed) return;
        importSoundsOverride = true;
        one('#import-sounds input').click();
      });
    }
    else {
      importSoundsOverride = false;
    }
  });
  bind(one('#import-sounds input'), 'change', importSounds);

  //////////////////////////////////////////////////////////
  // editor actions
  bind(saveButton, 'click', function(event) {
    saveData();
  });
  bind(playButton, 'click', function(event) {
    stopPlayback();
    function openPlayer() {
      window.open(urls.root + currentGameId + '/play/', 'player');
    }
    if (isDirty) saveData(openPlayer);
    else openPlayer();
  });
  // TODO: disable when out of steps
  bind(undoButton, 'click', function(event) {
    undo();
  });
  bind(redoButton, 'click', function(event) {
    redo();
  });
  bind(one('#toggle-grid'), 'click', function(event) {
    var oldValue = data.editor.showGrid;
    var newValue = !oldValue;

    function toggle() {
      if (data.editor.showGrid) {
        document.body.classList.add('show-grid');
      }
      else {
        document.body.classList.remove('show-grid');
      }
    }

    pushHistory('toggle grid', function() {
      data.editor.showGrid = newValue;
      toggle();
    },function() {
      data.editor.showGrid = oldValue;
      toggle();
    }, false, true);
  });
  bind(one('#toggle-walls'), 'click', function(event) {
    var oldValue = data.editor.showWalls;
    var newValue = !oldValue;

    function cleanup() {
      if (data.editor.showWalls) {
        document.body.classList.add('show-walls');
      }
      else {
        document.body.classList.remove('show-walls');
      }
      fullRoomRedraw();
    }

    pushHistory('toggle walls', function() {
      data.editor.showWalls = newValue;
      cleanup();
    },function() {
      data.editor.showWalls = oldValue;
      cleanup();
    }, false, true);
  });
  bind(one('#toggle-card'), 'click', function(event) {
    var oldValue = data.editor.showCard;
    var newValue = !oldValue;

    function cleanup() {
      if (data.editor.showCard) {
        document.body.classList.add('show-card');
      }
      else {
        document.body.classList.remove('show-card');
      }
    }

    pushHistory('toggle card mask', function() {
      data.editor.showCard = newValue;
      cleanup();
    },function() {
      data.editor.showCard = oldValue;
      cleanup();
    }, false, true);
  });
  function UI_changeMode(modeId) {
    var oldModeId = data.editor.activeModeId;
    var newModeId = modeId;

    if (oldModeId!=newModeId) {
      pushHistory('set active mode', function() {
        setActiveMode(newModeId);
      },function() {
        setActiveMode(oldModeId);
      }, false, true);
      // TODO: state switches like this should auto undo when undoing the thing that preceeded it? Or something like that...
    }
  }
  each('#modes li', function(i,node) {
    bind(node, 'click', function(event) {
      UI_changeMode(i);
    });
  });

  //////////////////////////////////////////////////////////
  // game actions
  function renderGames() {
    renderTitle();
    var listHTML = '<ul class="icon-list">';
    // TODO: ensure persistent sort order, either newest first or alpha?
    for (var i=0; i<games.length; i++) {
      var game = games[i];
      var className = game.id==currentGameId ? ' class="active"':'';
      listHTML += `<li${className}><span class="icon icon-game"></span>${game.title}</li>`;
    }
    listHTML += '</ul>';
    one('#games-list').innerHTML = listHTML;

    each('#games-list li', function(i, node) {
      bind(node, 'click', function(event) {
        window.location.href = urls.root + games[i].id + '/edit/';
      });
    });

    var listHTML = '';
    for (var i=0; i<deletedGames.length; i++) {
      var game = deletedGames[i];
      var matches = game.title.match(/^(.+)\s+\(deleted ([^\)]+)\)$/);
      var originalName = matches[1];
      var deletedDate = matches[2];
      listHTML += `<li title="Deleted ${deletedDate}" aria-label="Deleted ${deletedDate}"><span class="icon restore"></span>${originalName}</li>`;
    }
    one('#deleted-games').innerHTML = listHTML;

    each('#deleted-games li', function(i, node) {
      bind(node, 'click', function(event) {
        window.location.href = urls.root + 'games/' + deletedGames[i].id + '/restore/';
      });
    });

    // hide show actions
    one('#game-actions .delete').style.display = games.length==1 ? 'none' : 'inline-block';
    one('#game-modifiers .restore').style.display = deletedGames.length==0 ? 'none' : 'inline-block';
  }
  renderGames();

  bind(one('#game-actions .new'), 'click', function(event) {
    showPrompt(['New game', 'Choose a name'], '', 'Create', function(value) {
      if (value==null) return;

      var gameName = value.trim();
      if (gameName.length==0) {
        return showAlert('Please choose a name.');
      }
      if (indexOfGameName(gameName)!=-1) {
        return showAlert('A file named "'+gameName+'" already exists. Please choose a different name.');
      }

      Local.put(urls.root + 'create/', JSON.stringify({title:gameName}), function(text, status) {
        if (status==500) return showAlert('Unabled to create game.');

        var newGame = JSON.parse(text);
        window.location.href = urls.root + newGame.id + '/edit/';
      });
    });
  });
  bind(one('#game-actions .dupe'), 'click', function(event) {
    var currentGame = games[indexOfGameId(currentGameId)];
    showPrompt(['Duplicate game', 'Choose a name'], currentGame.title+' copy', 'Duplicate', function(value) {
      if (value==null) return;

      var gameName = value.trim();
      if (gameName.length==0) {
        return showAlert('Please choose a name.');
      }
      if (indexOfGameName(gameName)!=-1) {
        return showAlert('A file named "'+gameName+'" already exists. Please choose a different name.');
      }

      Local.put(urls.root + 'dupe/'+currentGameId+'/', JSON.stringify({title:gameName}), function(text, status) {
        if (status==500) return showAlert('Unabled to duplicate game.');

        var newGame = JSON.parse(text);
        window.location.href = urls.root + newGame.id + '/edit/';
      });
    });
  });
  bind(one('#game-actions .delete'), 'click', function(event) {
    confirmAction(['Delete this game?', 'Deleted games can be restored within 30 days of deletion.'], 'Delete', function(confirmed) {
      if (!confirmed) return;

      Local.delete(urls.root + 'games/' + currentGameId + '/data/', function(status) {
        if (status!=202) return showAlert('Could not delete game.');
        window.location.href = urls.root; // reload most recently edited game
      });
    });
  });
  bind(one('#game-modifiers .restore'), 'click', function(event) {
    showOverlay('restore');
  });

  bind('#button-restore-cancel', 'click', function(event) {
    hideOverlay();
  });

  //////////////////////////////////////////////////////////
  // room actions
  bind(one('#room-actions .new'), 'click', function(event) {
    var defaultName = getRoomName();
    showPrompt(['New room', 'Choose a name'], defaultName, 'Create', function(value) {
      if (value==null) return;

      var roomName = value;
      var oldRooms = clone(data.rooms);

      var oldRoomId = data.editor.activeRoomId;
      var newRoomId = addRoom();
      var newRoom = data.rooms[newRoomId];
      newRoom.name = roomName;

      var newRooms = clone(data.rooms);

      pushHistory('create new room', function() {
        data.rooms = clone(newRooms);
        setActiveRoom(newRoomId);
        renderRoomSelect();
      },function() {
        data.rooms = clone(oldRooms);
        setActiveRoom(oldRoomId);
        renderRoomSelect();
      });
    });
  });
  bind(one('#room-actions .dupe'), 'click', function(event) {
    var oldRoomId = data.editor.activeRoomId;
    var defaultName = dupeRoomName(oldRoomId);

    showPrompt(['Duplicate room', 'Choose a name'], defaultName, 'Duplicate', function(value) {
      if (value==null) return;

      var roomName = value;
      var oldData = clone(data);
      var newRoomId = dupeRoom(oldRoomId);
      var newRoom = data.rooms[newRoomId];
      newRoom.name = roomName;

      var newData = clone(data);

      // TODO: history overkill?
      pushHistory('dupe room', function() {
        data = clone(newData);
        setActiveRoom(newRoomId);
        renderRoomSelect();
      },function() {
        data = clone(oldData);
        setActiveRoom(oldRoomId);
        renderRoomSelect();
      });
    });
  });
  bind(one('#room-actions .delete'), 'click', function(event) {
    confirmAction('Delete this room?', 'Delete', function(confirmed) {
      if (!confirmed) return;

      var oldData = clone(data);

      var oldRoomId = data.editor.activeRoomId;
      var newRoomId = getFallbackIndex(data.rooms, data.rooms[data.editor.activeRoomId]);
      deleteRoom(oldRoomId);

      if (oldRoomId==data.card) {
        var cardRoomId = getCardFallback();
        data.card = cardRoomId;
        newRoomId = cardRoomId;
      }

      var newData = clone(data);

      // TODO: history overkill?
      pushHistory('delete room', function() {
        data = clone(newData);
        setActiveRoom(newRoomId);
        renderRoomSelect();
      },function() {
        data = clone(oldData);
        setActiveRoom(oldRoomId);
        renderRoomSelect();
      });
    });

  });
  bind(one('#edit-room-script'), 'click', function(event) {
    var room = data.rooms[data.editor.activeRoomId];

    // TODO: history overkill?
    var oldData = clone(data);
    var oldScriptId = data.editor.activeScriptId;
    var oldModeId = data.editor.activeModeId;

    // TODO: history overkill?
    pushHistory('edit room script', function() {
      if (!isset(room.script)) {
        room.script = addScript(ScriptType.Room,room.id);
      }
      setActiveScript(room.script);
      setActiveMode(EditorMode.Script);
    },function() {
      data = clone(oldData);
      setActiveScript(oldScriptId);
      setActiveMode(oldModeId);
    });
  });
  bind(one('#edit-game-script'), 'click', function(event) {
    var oldScriptId = data.editor.activeScriptId;
    var newScriptId = data.script
    var oldModeId = data.editor.activeModeId;
    var newModeId = EditorMode.Script;

    pushHistory('edit game script', function() {
      setActiveScript(newScriptId);
      setActiveMode(newModeId);
    },function() {
      setActiveScript(oldScriptId);
      setActiveMode(oldModeId);
    });
  });
  bind(one('#edit-card-room'), 'click', function(event) {
    var oldRoomId = data.editor.activeRoomId;
    var newRoomId = data.card;
    var oldModeId = EditorMode.Script;
    var newModeId = EditorMode.Room;
    pushHistory('goto room', function() {
      setActiveRoom(newRoomId);
      setActiveMode(newModeId);
    },function() {
      setActiveRoom(oldRoomId);
      setActiveMode(oldModeId);
    }, false, true);
  });

  //////////////////////////////////////////////////////////
  // tile actions/modifiers
  function deleteSelectedTile() {
    confirmAction('Delete the selected tile?', 'Delete', function(confirmed) {
      if (!confirmed) return;

      // TODO: history overkill?
      var oldData = clone(data);
      var oldTileId = data.editor.activeTileId;
      var oldFrameId = data.editor.activeFrameId;

      var tileType = LayerToTileType[data.editor.activeLayerId];
      var sortedTiles = data.editor.sortedTiles[tileType];
      var fallbackIndex = getFallbackIndex(sortedTiles, oldTileId);
      var fallbackId = fallbackIndex>-1 ? sortedTiles[fallbackIndex] : 0;

      // delete caches
      var deletedFrames = clone(data.tiles[oldTileId].frames);

      // delete from all rooms
      for (var i=0; i<data.rooms.length; i++) {
        var room = data.rooms[i];
        if (!room) continue;
        var roomTiles = room.tiles;
        for (var j=0; j<roomTiles.length; j++) {
          if (roomTiles[j]==oldTileId) {
            roomTiles[j] = data.background;
          }
        }
      }

      // actually delete the tile
      deleteTile(oldTileId);
      var i = sortedTiles.indexOf(oldTileId);
      sortedTiles.splice(i,1);

      if (sortedTiles.length==0) fallbackId = 0;

      var newTileId = fallbackId;
      var newData = clone(data);

      pushHistory('delete tile', function() {
        data = clone(newData);
        for (var i=0; i<deletedFrames; i++) {
          deleteImageData(deletedFrames[i]);
        }
        tidyImageDatas();

        renderTiles();
        setActiveTile(newTileId);
      },function() {
        data = clone(oldData);
        var oldFrames = data.tiles[oldTileId].frames;
        for (var i=0; i<oldFrames.length; i++) {
          cacheFrameImageData(oldFrames[i]);
        }

        renderTiles();
        setActiveTile(oldTileId,oldFrameId);
      });
    });
  }
  bind(one('#tile-actions .new'), 'click', function(event) {
    var oldData = clone(data);
    var oldTileId = data.editor.activeTileId;
    var oldFrameId = data.editor.activeFrameId;

    var tileType = LayerToTileType[data.editor.activeLayerId];
    var newTileId = addTile(tileType);
    var newFrames = data.tiles[newTileId].frames;
    data.editor.sortedTiles[tileType].push(newTileId);
    var newFrameId = newFrames[0];

    var newData = clone(data);

    pushHistory('new tile', function() {
      data = clone(newData);
      cacheFrameImageData(newFrameId);
      renderTiles();
      setActiveTile(newTileId,newFrameId);
    },function() {
      data = clone(oldData);
      deleteImageData(newFrameId);
      renderTiles();
      setActiveTile(oldTileId,oldFrameId);
    });

  });

  function UI_duplicateTile() {
    // TODO: history overkill
    var oldData = clone(data);
    var oldTileId = data.editor.activeTileId;
    var oldFrameId = data.editor.activeFrameId;

    var newTileId = dupeTile(data.editor.activeTileId);
    var newFrames = data.tiles[newTileId].frames;
    var newFrameId = newFrames[0];

    var tileType = LayerToTileType[data.editor.activeLayerId];
    var sortedTiles = data.editor.sortedTiles[tileType];
    var i = sortedTiles.indexOf(oldTileId);
    sortedTiles.splice(i+1,0,newTileId);

    var newData = clone(data);

    pushHistory('dupe tile', function() {
      data = clone(newData);
      for (var i=0; i<newFrames.length; i++) {
        cacheFrameImageData(newFrames[i]);
      }
      renderTiles();
      setActiveTile(newTileId,newFrameId);
    },function() {
      data = clone(oldData);
      for (var i=0; i<newFrames.length; i++) {
        deleteImageData(newFrames[i]);
      }
      renderTiles();
      setActiveTile(oldTileId,oldFrameId);
    });
  }
  function UI_duplicateAndRotateTiles() {
    var oldData = clone(data);
    var oldTileId = data.editor.activeTileId;
    var oldFrameId = data.editor.activeFrameId;
    var oldFrames = data.tiles[oldTileId].frames;

    var frameIndex = 0;
    for (var i=0; i<oldFrames.length; i++) {
      if (oldFrameId==oldFrames[i]) {
        frameIndex = i;
        break;
      }
    }


    var newTileId = oldTileId;
    var newFrameId;
    var allNewFrames = [];
    var tileType = LayerToTileType[data.editor.activeLayerId];
    var sortedTiles = data.editor.sortedTiles[tileType];

    for (var i=0; i<3; i++) {
      var t = sortedTiles.indexOf(newTileId);
      newTileId = dupeTile(newTileId);
      print(i, newTileId);
      sortedTiles.splice(t+1,0,newTileId);
      var newFrames = data.tiles[newTileId].frames;
      newFrameId = newFrames[frameIndex];
      for (var j=0; j<newFrames.length; j++) {
        var frameId = newFrames[j]
        print('',j,frameId);
        allNewFrames.push(frameId);
        rotateFrameData(data.frames[frameId].data);
      }
    }

    var newData = clone(data);
    pushHistory('dupe and rotate tile', function() {
      data = clone(newData);
      for (var i=0; i<allNewFrames.length; i++) {
        cacheFrameImageData(allNewFrames[i]);
      }
      renderTiles();
      setActiveTile(newTileId,newFrameId);
    },function() {
      data = clone(oldData);
      for (var i=0; i<allNewFrames.length; i++) {
        deleteImageData(allNewFrames [i]);
      }
      renderTiles();
      setActiveTile(oldTileId,oldFrameId);
    });
  }

  bind(one('#tile-actions .dupe'), 'click', UI_duplicateTile);
  bind(one('#tile-actions .delete'), 'click', deleteSelectedTile);

  function UI_invertTile() {
    var activeFrameId = data.editor.activeFrameId;
    var oldFrameData = clone(data.frames[activeFrameId].data);
    var newFrameData = clone(oldFrameData);
    invertFrameData(newFrameData);

    function cleanup() {
      cacheFrameImageData(activeFrameId);
      fullRoomRedraw();
    }
    pushHistory('invert frame', function() {
      data.frames[activeFrameId].data = clone(newFrameData);
      cleanup();
    },function() {
      data.frames[activeFrameId].data = clone(oldFrameData);
      cleanup();
    });
  }
  function UI_flipTileH() {
    var activeFrameId = data.editor.activeFrameId;
    var oldFrameData = clone(data.frames[activeFrameId].data);
    var newFrameData = clone(oldFrameData);
    flipFrameDataH(newFrameData);

    function cleanup() {
      cacheFrameImageData(activeFrameId);
      fullRoomRedraw();
    }
    pushHistory('flip frame horizontally', function() {
      data.frames[activeFrameId].data = clone(newFrameData);
      cleanup();
    },function() {
      data.frames[activeFrameId].data = clone(oldFrameData);
      cleanup();
    });
  }
  function UI_flipTileV() {
    var activeFrameId = data.editor.activeFrameId;
    var oldFrameData = clone(data.frames[activeFrameId].data);
    var newFrameData = clone(oldFrameData);
    flipFrameDataV(newFrameData);

    function cleanup() {
      cacheFrameImageData(activeFrameId);
      fullRoomRedraw();
    }
    pushHistory('flip frame vertically', function() {
      data.frames[activeFrameId].data = clone(newFrameData);
      cleanup();
    },function() {
      data.frames[activeFrameId].data = clone(oldFrameData);
      cleanup();
    });
  }
  function UI_rotateTile() {
    var activeFrameId = data.editor.activeFrameId;
    var oldFrameData = clone(data.frames[activeFrameId].data);
    var newFrameData = clone(oldFrameData);
    rotateFrameData(newFrameData, isShiftPressed);

    function cleanup() {
      cacheFrameImageData(activeFrameId);
      fullRoomRedraw();
    }
    pushHistory('rotate frame', function() {
      data.frames[activeFrameId].data = clone(newFrameData);
      cleanup();
    },function() {
      data.frames[activeFrameId].data = clone(oldFrameData);
      cleanup();
    });
  }

  bind(one('#tile-modifiers .invert'), 'click', UI_invertTile);
  bind(one('#tile-modifiers .flip-h'), 'click', UI_flipTileH);
  bind(one('#tile-modifiers .flip-v'), 'click', UI_flipTileV);
  bind(one('#tile-modifiers .rotate'), 'click', function(event) {
    if (isOptionPressed) UI_duplicateAndRotateTiles();
    else UI_rotateTile();
  });

  if (data.editor.highlightTiles) document.body.classList.add('highlighting');
  function UI_toggleHighlightTiles() {
    var oldValue = data.editor.highlightTiles;
    var newValue = !oldValue;

    function cleanup() {
      if (data.editor.highlightTiles) {
        document.body.classList.add('highlighting');
      }
      else {
        document.body.classList.remove('highlighting');
      }
      renderRoomSelect();
    }

    pushHistory('highlight tiles', function() {
      data.editor.highlightTiles = newValue;
      cleanup();
    },function() {
      data.editor.highlightTiles = oldValue;
      cleanup();
    }, false, true);
  }
  bind(one('#highlight-tile'), 'click', UI_toggleHighlightTiles);

  //////////////////////////////////////////////////////////
  // tile frame actions
  bind(one('#frame-actions .new'), 'click', function(event) {
    // TODO: history overkill
    var oldData = clone(data);
    var oldTileId = data.editor.activeTileId;
    var oldFrameId = data.editor.activeFrameId;

    var newFrameId = addFrame();
    var tileFrames = data.tiles[oldTileId].frames;
    tileFrames.push(newFrameId);

    var newData = clone(data);

    pushHistory('new frame', function() {
      data = clone(newData);
      cacheFrameImageData(newFrameId);
      renderTiles();
      setActiveTile(oldTileId, newFrameId);
    },function() {
      data = clone(oldData);
      deleteImageData(newFrameId);
      tidyImageDatas();
      renderTiles();
      setActiveTile(oldTileId, oldFrameId);
    });
  });
  function UI_duplicateFrame() {
    // TODO: history overkill
    var oldData = clone(data);
    var oldTileId = data.editor.activeTileId;
    var oldFrameId = data.editor.activeFrameId;

    var newFrameId = dupeFrame(oldFrameId);
    cacheFrameImageData(newFrameId);
    var tileFrames = data.tiles[oldTileId].frames;

    var i = tileFrames.indexOf(oldFrameId);
    tileFrames.splice(i+1,0,newFrameId);

    var newData = clone(data);

    pushHistory('dupe frame', function() {
      data = clone(newData);
      cacheFrameImageData(newFrameId);
      renderTiles();
      setActiveTile(oldTileId, newFrameId);
    },function() {
      data = clone(oldData);
      deleteImageData(newFrameId);
      tidyImageDatas();
      renderTiles();
      setActiveTile(oldTileId, oldFrameId);
    });
  }
  bind(one('#frame-actions .dupe'), 'click', UI_duplicateFrame);
  bind(one('#frame-actions .delete'), 'click', function(event) {
    // TODO: history overkill
    var oldData = clone(data);
    var oldTileId = data.editor.activeTileId;
    var oldFrameId = data.editor.activeFrameId;

    var tileFrames = data.tiles[oldTileId].frames;
    if (tileFrames.length==1) return deleteSelectedTile(); // TODO: delete button is no longer shown for last frame

    confirmAction('Delete selected frame?', 'Delete', function(confirmed) {
      if (!confirmed) return;

      var fallbackId = getFallbackIndex(tileFrames, oldFrameId);
      var newFrameId = tileFrames[fallbackId];

      // delete cache
      deleteImageData(oldFrameId);
      tidyImageDatas();

      // actually delete frame
      var i = tileFrames.indexOf(oldFrameId);
      tileFrames.splice(i,1);
      deleteFrame(oldFrameId);

      // TODO: I don't think we've deleted the cached imagedata...

      var newData = clone(data);

      pushHistory('delete frame', function() {
        data = clone(newData);
        deleteImageData(oldFrameId);
        tidyImageDatas();
        renderTiles();
        setActiveTile(oldTileId, newFrameId);
      },function() {
        data = clone(oldData);
        cacheFrameImageData(oldFrameId);
        renderTiles();
        setActiveTile(oldTileId, oldFrameId);
      });
    });
  });

  //////////////////////////////////////////////////////////
  // tile/frame reordering
  bind(document, 'mousemove', function(event) {
    if (!dragClone) return;
    dragClone.style.left = (event.x - dragOffsetX + window.pageXOffset) + 'px';
    dragClone.style.top  = (event.y - dragOffsetY + window.pageYOffset) + 'px';
  });
  bind(document, 'mouseup', function(event) {
    if (dragNode) {
      if (dragNode.parentNode==tileFrames) {

        var tileId = data.editor.activeTileId;
        var frameId = data.editor.activeFrameId;
        var oldFrames = clone(data.tiles[tileId].frames);
        var newFrames = clone(oldFrames);

        each('#tile-frames i', function(i,node) {
          newFrames[i] = parseInt(node.dataset.frameId);
        });

        if (JSON.stringify(oldFrames)!=JSON.stringify(newFrames)) {
          function cleanup() {
            renderFrames();
            setActiveTile(tileId, frameId);
          }
          pushHistory('reorder frames', function() {
            data.tiles[tileId].frames = clone(newFrames);
            cleanup();
          },function() {
            data.tiles[tileId].frames = clone(oldFrames);
            cleanup();
          });
        }
      }
      else if (dragNode.parentNode==roomTiles) {
        var tileType = LayerToTileType[data.editor.activeLayerId];
        var tileId = data.editor.activeTileId;
        var frameId = data.editor.activeFrameId;
        var oldTiles = clone(data.editor.sortedTiles[tileType]);
        var newTiles = clone(oldTiles);

        each('#room-tiles i[data-tile-type="'+tileType+'"]', function(i,node) {
          newTiles[i] = parseInt(node.dataset.tileId);
        });
        if (JSON.stringify(oldTiles)!=JSON.stringify(newTiles)) {
          function cleanup() {
            renderTiles();
            setActiveTile(tileId, frameId);
          }
          pushHistory('reorder tiles '+tileType, function() {
            data.editor.sortedTiles[tileType] = clone(newTiles);
            cleanup();
          },function() {
            data.editor.sortedTiles[tileType] = clone(oldTiles);
            cleanup();
          });
        }
      }
      dragNode.style.opacity = 1;
      dragNode = null;
      if (dragClone) {
        document.body.removeChild(dragClone);
        dragClone = null;
      }
    }
  });

  //////////////////////////////////////////////////////////
  // song actions
  bind(one('#song-actions .new'), 'click', function(event) {
    var defaultName = getSongName();

    showPrompt(['New song', 'Choose a name'], defaultName, 'Create', function(value) {
      if (value==null) return;

      var songName = value;

      var oldSongs = clone(data.songs);

      var oldSongId = data.editor.activeSongId;
      var newSongId = addSong();
      var newSong = data.songs[newSongId];
      newSong.name = songName;

      var newSongs = clone(data.songs);

      pushHistory('create new song', function() {
        data.songs = clone(newSongs);
        updateAudioSource();
        setActiveSong(newSongId);
        renderSongSelect();
      },function() {
        data.songs = clone(oldSongs);
        updateAudioSource();
        setActiveSong(oldSongId);
        renderSongSelect();
      });
    });
  });
  bind(one('#song-actions .dupe'), 'click', function(event) {
    var oldSongId = data.editor.activeSongId;
    var defaultName = dupeSongName(oldSongId);

    showPrompt(['Duplicate song', 'Choose a name'], defaultName, 'Duplicate', function(value) {
      if (value==null) return;

      var songName = value;
      var oldSongs = clone(data.songs);
      var newSongId = dupeSong(oldSongId);
      var newSong = data.songs[newSongId];
      newSong.name = songName;

      var newSongs = clone(data.songs);

      pushHistory('dupe song', function() {
        data.songs = clone(newSongs);
        updateAudioSource();
        setActiveSong(newSongId);
        renderSongSelect();
      },function() {
        data.songs = clone(oldSongs);
        updateAudioSource();
        setActiveSong(oldSongId);
        renderSongSelect();
      });
    });
  });
  bind(one('#song-actions .delete'), 'click', function(event) {
    confirmAction('Delete this song?', 'Delete', function(confirmed) {
      if (!confirmed) return;

      var oldSongs = clone(data.songs);

      var oldSongId = data.editor.activeSongId;
      var newSongId = getFallbackIndex(data.songs, data.songs[data.editor.activeSongId]);
      deleteSong(oldSongId);

      var newSongs = clone(data.songs);

      pushHistory('delete song', function() {
        data.songs = clone(newSongs);
        setActiveSong(newSongId);
        updateAudioSource();
        renderSongSelect();
      },function() {
        data.songs = clone(oldSongs);
        setActiveSong(oldSongId);
        updateAudioSource();
        renderSongSelect();
      });
    });
  });

  bind(one('#toggle-play'), 'click', function(event) {
    playPause();
  });

  // part actions
  bind(songLoopFrom, 'click', function(event) {
    setLoopFrom();
  });
  bind(one('#split-part'), 'click', function(event) {
    splitPart();
  });
  bind(one('#join-parts'), 'click', function(event) {
    joinParts();
  });

  if (data.editor.loopSong) document.body.classList.add('loop-song');
  if (data.editor.loopNotes) document.body.classList.add('loop-notes');

  function UI_toggleLoopSong() {
    var oldValue = data.editor.loopSong;
    var newValue = !oldValue;

    function cleanup() {
      if (data.editor.loopSong) {
        document.body.classList.add('loop-song');
      }
      else {
        document.body.classList.remove('loop-song');
      }
    }

    pushHistory('toggle loop song', function() {
      data.editor.loopSong = newValue;
      cleanup();
    },function() {
      data.editor.loopSong = oldValue;
      cleanup();
    }, false, true);
  }

  function UI_toggleLoopNotes() {
    var oldValue = data.editor.loopNotes;
    var newValue = !oldValue;

    function cleanup() {
      if (data.editor.loopNotes) {
        document.body.classList.add('loop-notes');
      }
      else {
        document.body.classList.remove('loop-notes');
      }
    }

    pushHistory('toggle loop notes', function() {
      data.editor.loopNotes = newValue;
      cleanup();
    },function() {
      data.editor.loopNotes = oldValue;
      cleanup();
    }, false, true);
  }

  bind(one('#toggle-loop'), 'click', UI_toggleLoopSong);
  bind(one('#toggle-loop-notes'), 'click', UI_toggleLoopNotes);

  bind(one('#playhead-return'), 'click', function(event) {
    resetPlayheads();
  });

  //////////////////////////////////////////////////////////
  // sound actions
  bind(one('#sound-actions .new'), 'click', function(event) {
    var defaultName = getSoundName();

    showPrompt(['New sound', 'Choose a name'], defaultName, 'Create', function(value) {
      if (value==null) return;

      var soundName = value;

      var oldSounds = clone(data.sounds);

      var oldSoundId = data.editor.activeSoundId;
      var newSoundId = addSound();
      var newSound = data.sounds[newSoundId];
      newSound.name = soundName;

      var newSounds = clone(data.sounds);

      pushHistory('create new sound', function() {
        data.sounds = clone(newSounds);
        updateAudioSource();
        setActiveSound(newSoundId);
        renderSoundSelect();
      },function() {
        data.sounds = clone(oldSounds);
        updateAudioSource();
        setActiveSound(oldSoundId);
        renderSoundSelect();
      });
    });
  });
  bind(one('#sound-actions .dupe'), 'click', function(event) {
    var oldSoundId = data.editor.activeSoundId;
    var defaultName = dupeSoundName(oldSoundId);

    showPrompt(['Duplicate sound', 'Choose a name'], defaultName, 'Duplicate', function(value) {
      if (value==null) return;

      var soundName = value;

      var oldSounds = clone(data.sounds);
      var newSoundId = dupeSound(oldSoundId);
      var newSound = data.sounds[newSoundId];
      newSound.name = soundName;

      var newSounds = clone(data.sounds);

      pushHistory('dupe sound', function() {
        data.sounds = clone(newSounds);
        updateAudioSource();
        setActiveSound(newSoundId);
        renderSoundSelect();
      },function() {
        data.sounds = clone(oldSounds);
        updateAudioSource();
        setActiveSound(oldSoundId);
        renderSoundSelect();
      });
    });
  });
  bind(one('#sound-actions .delete'), 'click', function(event) {
    confirmAction('Delete this sound?', 'Delete', function(confirmed) {
      if (!confirmed) return;

      var oldSounds = clone(data.sounds);

      var oldSoundId = data.editor.activeSoundId;
      var newSoundId = getFallbackIndex(data.sounds, data.sounds[data.editor.activeSoundId]);
      deleteSound(oldSoundId);

      var newSounds = clone(data.sounds);

      pushHistory('delete sound', function() {
        data.sounds = clone(newSounds);
        setActiveSound(newSoundId);
        updateAudioSource();
        renderSoundSelect();
      },function() {
        data.sounds = clone(oldSounds);
        setActiveSound(oldSoundId);
        updateAudioSource();
        renderSoundSelect();
      });
    });
  });

  //////////////////////////////////////////////////////////
  // script actions
  bind(one('#goto-room'), 'click', function(event) {
    var oldRoomId = data.editor.activeRoomId;
    var newRoomId = data.scripts[data.editor.activeScriptId].id;
    var oldModeId = EditorMode.Script;
    var newModeId = EditorMode.Room;
    pushHistory('goto room', function() {
      setActiveRoom(newRoomId);
      setActiveMode(newModeId);
    },function() {
      setActiveRoom(oldRoomId);
      setActiveMode(oldModeId);
    }, false, true);
  });
  bind(one('#goto-game'), 'click', function(event) {
    UI_changeMode(EditorMode.Game);
  });
  bind(one('#goto-tile'), 'click', function(event) {
    var oldTileId = data.editor.activeTileId;
    var newTileId = data.scripts[data.editor.activeScriptId].id;
    var oldModeId = EditorMode.Script;
    var newModeId = EditorMode.Room;
    pushHistory('goto tile', function() {
      setActiveTile(newTileId);
      setActiveMode(newModeId);
    },function() {
      setActiveTile(oldTileId);
      setActiveMode(oldModeId);
    }, false, true);
  });

  //////////////////////////////////////////////////////////
  // property editing
  function blurOnReturn(event) {
    if (event.keyCode == 13) {
      event.stopPropagation();
      return event.target.blur();
    }
  }
  bind(gameName, 'keyup', blurOnReturn);
  bind(gameName, 'blur', function(event) {
    var oldName = data.name;
    var newName = gameName.value;

    if (newName.trim().length==0) {
      gameName.value = oldName;
      gameFile.innerHTML = oldName;
      return;
    }

    if (oldName!=newName) {
      var gameIndex = indexOfGameId(currentGameId);

      if (indexOfGameName(newName)!=-1) {
        gameName.value = oldName;
        gameFile.innerHTML = oldName;
        return showAlert('A file named "'+newName+'" already exists. Please choose a different name.');
      }

      pushHistory('change game name', function() {
        data.name = newName;
        gameName.value = newName;
        gameFile.innerHTML = newName;
        games[gameIndex].title = newName;
        renderGames();
      },function() {
        data.name = oldName;
        gameName.value = oldName;
        gameFile.innerHTML = oldName;
        games[gameIndex].title = oldName;
        renderGames();
      });
    }
  });

  bind(gameAuthor, 'keyup', blurOnReturn);
  bind(gameAuthor, 'blur', function(event) {
    var oldAuthor = data.author;
    var newAuthor = gameAuthor.value;
    if (oldAuthor!=newAuthor) {
      pushHistory('change game author', function() {
        data.author = newAuthor;
        gameAuthor.value = newAuthor;
      },function() {
        data.author = oldAuthor;
        gameAuthor.value = oldAuthor;
      });
    }
  });

  bind(gameIntro, 'keyup', blurOnReturn);
  bind(gameIntro, 'blur', function(event) {
    var oldIntro = data.intro;
    var newIntro = gameIntro.value;

    if (oldIntro!=newIntro) {
      pushHistory('change game intro', function() {
        data.intro = newIntro;
        gameIntro.value = newIntro;
      },function() {
        data.intro = oldIntro;
        gameIntro.value = oldIntro;
      });
    }
  });

  bind(roomName, 'keyup', blurOnReturn);
  bind(roomName, 'blur', function(event) {
    var roomId = data.editor.activeRoomId;
    var room = data.rooms[roomId];
    var oldName = room.name;
    var newName = roomName.value;
    if (oldName!=newName) {
      function cleanup() {
        var roomName = room.name;
        if (data.player.room==roomId) {
          roomName += '*';
        }
        renderRoomSelect();
      }
      pushHistory('change room name', function() {
        room.name = newName;
        roomName.value = newName;
        cleanup();
      },function() {
        room.name = oldName;
        roomName.value = oldName;
        cleanup();
      });
    }
  });

  bind(tileName, 'keyup', blurOnReturn);
  bind(tileName, 'blur', function(event) {
    var tile = data.tiles[data.editor.activeTileId];
    var oldName = tile.name;
    var newName = tileName.value;
    if (oldName!=newName) {
      function cleanup() {
        renderRecentScripts()
        renderScriptSelect();
        var roomTile = one('#room-tiles i[data-tile-id="'+tile.id+'"]');
        if (roomTile) roomTile.title = `${tile.name} (tile ${tile.id})`;
      }
      pushHistory('change tile name', function() {
        tile.name = newName;
        tileName.value = newName;
        cleanup();
      },function() {
        tile.name = oldName;
        tileName.value = oldName;
        cleanup();
      });
    }
  });

  bind(songName, 'keyup', blurOnReturn);
  bind(songName, 'blur', function(event) {
    var song = data.songs[data.editor.activeSongId];
    var oldName = song.name;
    var newName = songName.value;
    if (oldName!=newName) {
      function cleanup() {
        songName.value = song.name;
        renderSongSelect();
      }
      pushHistory('change song name', function() {
        song.name = newName;
        cleanup();
      },function() {
        song.name = oldName;
        cleanup();
      });
    }
  });

  bind(soundName, 'keyup', blurOnReturn);
  bind(soundName, 'blur', function(event) {
    var sound = data.sounds[data.editor.activeSoundId];
    var oldName = sound.name;
    var newName = soundName.value;
    if (oldName!=newName) {
      function cleanup() {
        soundName.value = sound.name;
        renderSoundSelect();
      }
      pushHistory('change sound name', function() {
        sound.name = newName;
        cleanup();
      },function() {
        sound.name = oldName;
        cleanup();
      });
    }
  });

  function sanitizeSays(text) {
    return text.normalize('NFKD').replace(/[]/g, '"').replace(/[]/g, "'").replace(/[\u0300-\u036f]/g, ""); // reduce to supported ascii chars
  }

  function previewTileSays() {
    previewText(tileSays.value);
  }
  bind(tileSays, 'focus,click,keyup', previewTileSays);
  bind(tileSays, 'blur', function(event) {
    var tile = data.tiles[data.editor.activeTileId];
    var oldValue = tile.says;
    var oldStringValue = jsonf2says(oldValue);
    var newStringValue = sanitizeSays(tileSays.value);
    var newValue = says2jsonf(newStringValue);
    if (oldStringValue!=newStringValue) {
      pushHistory('change tile says', function() {
        tile.says = newValue;
        tileSays.value = newStringValue;
        previewTileSays();
      },function() {
        tile.says = oldValue;
        tileSays.value = oldStringValue;
        previewTileSays();
      });
    }
  });
  bind(tileSays, 'blur', dismissPreview);

  function previewExitSays() {
    previewText(exitSays.value);
  }
  bind(exitSays, 'focus,click,keyup', previewExitSays);
  bind(exitSays, 'blur', function(event) {
    var exit = getExit();
    var oldValue = exit.fin;
    var oldStringValue = jsonf2says(oldValue);
    var newStringValue = sanitizeSays(exitSays.value);
    var newValue = says2jsonf(newStringValue);
    if (oldStringValue!=newStringValue) {
      pushHistory('change exit fin', function() {
        exit.fin = newValue;
        exitSays.value = newStringValue;
        previewExitSays();
      },function() {
        exit.fin = oldValue;
        exitSays.value = oldStringValue;
        previewExitSays();
      });
    }
  });
  bind(exitSays, 'blur', dismissPreview);

  bind(tileFps, 'focus', function(event) {
    var tile = data.tiles[data.editor.activeTileId];
    tileFps.dataset.defaultValue = tile.fps;
  })
  bind(tileFps, 'keyup', function(event) {
    var newValue = parseFloat(tileFps.value);
    if (isNaN(newValue) || newValue<0) return;

    if (newValue>20) {
      newValue = 20;
      tileFps.value = newValue;
    }

    var tile = data.tiles[data.editor.activeTileId];
    var oldValue = tile.fps;

    if (oldValue!=newValue) {
      addFrameTimer(newValue);
      tile.fps = newValue;
    }

    blurOnReturn(event);
  });
  bind(tileFps, 'blur', function(event) {
    var tile = data.tiles[data.editor.activeTileId];
    var oldValue = parseFloat(tileFps.dataset.defaultValue);
    var newValue = parseFloat(tile.fps);

    if (oldValue!=newValue) {
      pushHistory('change tile fps', function() {
        tile.fps = newValue;
        tileFps.value = newValue;
      },function() {
        tile.fps = oldValue;
        tileFps.value = oldValue;
      });
    }
  });

  bind(songBpm, 'focus', function(event) {
    var song = data.songs[data.editor.activeSongId];
    songBpm.dataset.defaultValue = song.bpm;
  })
  bind(songBpm, 'keyup', function(event) {
    var newValue = parseFloat(songBpm.value);
    if (isNaN(newValue) || newValue<0) return;

    var song = data.songs[data.editor.activeSongId];
    var oldValue = song.bpm;

    if (oldValue!=newValue) {
      song.bpm = newValue;
    }

    blurOnReturn(event);
  });
  bind(songBpm, 'blur', function(event) {
    var song = data.songs[data.editor.activeSongId];
    var oldValue = parseFloat(songBpm.dataset.defaultValue);
    var newValue = parseFloat(song.bpm);

    if (oldValue!=newValue) {
      pushHistory('change song bpm', function() {
        song.bpm = newValue;
        songBpm.value = newValue;
        setBpm(newValue);
      },function() {
        song.bpm = oldValue;
        songBpm.value = oldValue;
        setBpm(oldValue);
      });
    }
  });

  bind(soundBpm, 'focus', function(event) {
    var sound = data.sounds[data.editor.activeSoundId];
    soundBpm.dataset.defaultValue = sound.bpm;
  })
  bind(soundBpm, 'keyup', function(event) {
    var newValue = parseFloat(soundBpm.value);
    if (isNaN(newValue) || newValue<0) return;

    var sound = data.sounds[data.editor.activeSoundId];
    var oldValue = sound.bpm;

    if (oldValue!=newValue) {
      sound.bpm = newValue;
    }

    blurOnReturn(event);
  });
  bind(soundBpm, 'blur', function(event) {
    var sound = data.sounds[data.editor.activeSoundId];
    var oldValue = parseFloat(soundBpm.dataset.defaultValue);
    var newValue = parseFloat(sound.bpm);

    if (oldValue!=newValue) {
      function cleanup() {
        soundBpm.value = sound.bpm;
        setBpm(sound.bpm);
      }
      pushHistory('change sound bpm', function() {
        sound.bpm = newValue;
        cleanup();
      },function() {
        sound.bpm = oldValue;
        cleanup();
      });
    }
  });

  bind(tileIsSolid, 'change', function(event) {
    var tile = data.tiles[data.editor.activeTileId];
    var oldValue = tile.solid;
    var newValue = tileIsSolid.checked;
    if (oldValue!=newValue) {
      pushHistory('change tile solid', function() {
        tile.solid = newValue;
        tileIsSolid.checked = newValue;
        if (data.editor.showWalls) fullRoomRedraw();
      },function() {
        tile.solid = oldValue;
        tileIsSolid.checked = oldValue;
        if (data.editor.showWalls) fullRoomRedraw();
      });
    }
  });

  each('input[name="tile-type-radio"]', function(i,node) {
    bind(node, 'change', function(event) {
      var tile = data.tiles[data.editor.activeTileId]

      var oldType = tile.type;
      var newType = parseInt(node.value);

      function abort() {
        one('input[name="tile-type-radio"][value="'+oldType+'"]').checked = true;
      }
      function proceed() {
        // TODO: history overkill
        var oldData = clone(data);
        var oldLayerId = data.editor.activeLayerId;
        var newLayerId = TileTypeToLayer[newType];

        tile.type = newType;
        validateTileProperties(tile);

        var oldSortedTiles = data.editor.sortedTiles[oldType];
        var newSortedTiles = data.editor.sortedTiles[newType];

        var i = oldSortedTiles.indexOf(tile.id);
        oldSortedTiles.splice(i,1);
        newSortedTiles.push(tile.id);

        var newData = clone(data);

        pushHistory('change tile type', function() {
          data = clone(newData);
          setActiveLayer(newLayerId);
          syncTileProperties();
        },function() {
          data = clone(oldData);
          setActiveLayer(oldLayerId);
          syncTileProperties();
        });
      }

      if (oldType!=newType) {
        if (tile.id==data.player.id) { // TODO: unnecssary, this control is disabled for primary player
          return abort();
        }
        // change will discard behavior
        else if (
          (newType==TileType.World && (hasSays(tile) || hasScript(tile))) ||
          (newType==TileType.Player && hasSays(tile))
        ) {
          return confirmAction(['Are you sure you want to change the type of this Tile?', 'Its existing behavior will be discarded.'], 'Change', function(confirmed) {
            if (confirmed) proceed();
            else abort();
          });
        }

        proceed();
      }
    });
  });
  each('input[name="behavior-type-radio"]', function(i,node) {
    bind(node, 'change', function(event) {
      // print('changed behaviorType');

      // TODO: history overkill
      var oldData = clone(data);

      var tile = data.tiles[data.editor.activeTileId];
      var oldType = tile.btype;
      var newType = parseInt(node.value);

      function abort() {
        one('input[name="behavior-type-radio"][value="'+oldType+'"]').checked = true;
      }
      function proceed() {
        tile.btype = newType;
        var newData = clone(data);

        pushHistory('change tile behavior', function() {
          data = clone(newData);
          syncTileProperties();
        },function() {
          data = clone(oldData);
          syncTileProperties();
        });
      }

      if (tile.type==TileType.Player) { // TODO: this radio isn't enabled for Player types, shouldn't be necessary
        return abort();
      }
      else if (oldType==BehaviorType.Simple) {
        if (hasSays(tile)) {
          return confirmAction(['Are you sure you want to change the Behavior of this Tile?', 'Its existing dialog text will be discarded.'], 'Change', function(confirmed) {
            if (confirmed) {
              delete tile.says;
              tile.script = addScript(ScriptType.Tile, tile.id);
              // print('added script to', tile.name, tile.script);
              proceed();
            }
            else abort();
          });
        }
        else {
          tile.script = addScript(ScriptType.Tile, tile.id);
        }
      }
      else {
        if (hasScript(tile)) {
          return confirmAction(['Are you sure you want to change the Behavior of this Tile?', 'Its existing script will be discarded.'], 'Change', function(confirmed) {
            if (confirmed) {
              if (isset(tile.script)) {
                deleteScript(tile.script);
                // print('deleted script from ', tile.name);
              }
              tile.says = '';
              proceed();
            }
            else abort();
          });
        }
        else {
          tile.says = '';
        }
      }

      proceed();
    });
  });

  //////////////////////////////////////////////////////////
  // layers
  each('#layers .toggle-visibility', function(i,node) {
    if (data.editor.showLayer[i]) {
      node.classList.add('visible');
    }
    else {
      node.classList.add('invisible');
    }

    bind(node, 'click', function(event) {
      var oldValue = data.editor.showLayer[i];
      var newValue = !oldValue;

      function cleanup() {
        if (data.editor.showLayer[i]) {
          document.body.classList.remove('hide-layer-'+i);
          node.classList.remove('invisible');
          node.classList.add('visible');
        }
        else {
          document.body.classList.add('hide-layer-'+i);
          node.classList.remove('visible');
          node.classList.add('invisible');
        }
        syncExitProperties();
        renderRoom();
      }
      pushHistory('toggle layer visibility', function() {
        data.editor.showLayer[i] = newValue;
        cleanup();
      },function() {
        data.editor.showLayer[i] = oldValue;
        cleanup();
      }, false, true);

      // print('stopping propagation');
      event.stopPropagation();
    });
  })
  function UI_changeLayer(layerId) {
    var oldLayerId = data.editor.activeLayerId;
    var newLayerId = layerId;

    if (oldLayerId!=newLayerId) {
      pushHistory('set active layer', function() {
        setActiveLayer(newLayerId);
      },function() {
        setActiveLayer(oldLayerId);
      }, false, true);
    }
  }
  each('#layers li', function(i,node) {
    bind(node, 'click', function(event) {
      UI_changeLayer(i);
    });
  });

  // exits
  each('input[name="exit-type-radio"]', function(i,node) {
    bind(node, 'change', function onChangeExitType(event) {
      var roomId = data.editor.activeRoomId;
      var exitId = data.editor.activeExitId;

      var oldExit = clone(data.rooms[roomId].exits[exitId]);
      var newExit = clone(oldExit);

      var oldType = getExitType(oldExit);
      var newType = parseInt(node.value);

      var deletePair = oldType==ExitType.Edge && oldExit.room!=-1 && oldExit.tx!=-1 && oldExit.ty!=-1;
      var oldPairExits,newPairExits,pairRoomId;
      if (deletePair) {
        pairRoomId = oldExit.room;
        var pair = getExitAt(oldExit.tx,oldExit.ty,oldExit.room);
        oldPairExits = clone(data.rooms[pairRoomId].exits);
        newPairExits = clone(oldPairExits);

        newPairExits.splice(pair.id,1);
        for (var j=pair.id; j<newPairExits.length; j++) {
          newPairExits[j].id = j;
        }
      }

      function makeConnection() {
        if (newType==ExitType.Connection) makeExitConnection(newExit); // TODO: may make changes to another room if changing from ExitType.Edge
        else makeExitEdge(newExit);
      }
      function abort() {
        one('input[name="exit-type-radio"][value="'+oldType+'"]').checked = true;
      }
      function proceed() {
        pushHistory('set active layer', function() {
          data.rooms[roomId].exits[exitId] = clone(newExit);
          if (deletePair) data.rooms[pairRoomId].exits = clone(newPairExits);
          syncExitProperties();
          renderRoom();
        },function() {
          data.rooms[roomId].exits[exitId] = clone(oldExit);
          if (deletePair) data.rooms[pairRoomId].exits = clone(oldPairExits);
          syncExitProperties();
          renderRoom();
        });
      }

      // Connection <=> Edge has no dataloss of consequence
      if (oldType==ExitType.Ending) {
        if (isset(newExit.fin) && (Array.isArray(newExit.fin) || newExit.fin.trim().length>0)) {
          return confirmAction(['Are you sure you want to change the type of this exit?', 'Its existing ending text will be discarded.'], 'Change', function(confirmed) {
            if (confirmed) {
              makeConnection();
              proceed();
            }
            else abort();
          });
        }
        else {
          makeConnection();
        }
      }
      else if (newType==ExitType.Ending) {
        if (isset(newExit.room) && newExit.room>-1) {
          return confirmAction(['Are you sure you want to change the type of this exit?', 'Its existing connection will be discarded.'], 'Change', function(confirmed) {
            if (confirmed) {
              makeExitEnding(newExit);
              proceed();
            }
            else abort();
          });
        }
        else {
          makeExitEnding(newExit);
        }
      }
      else {
        makeConnection();
      }
      proceed();
    });
  });
  function UI_deleteExit() {
    var exit = getExit();
    var exitType = getExitType(exit);
    var deletePair = exitType==ExitType.Edge && exit.room!=-1 && exit.tx!=-1 && exit.ty!=-1;

    function proceed() {
      var roomId = data.editor.activeRoomId;
      var oldExitId = data.editor.activeExitId;
      var newExitId = oldExitId>0 ? oldExitId-1 : oldExitId;

      var oldExits = clone(data.rooms[roomId].exits);
      var newExits = clone(oldExits);

      newExits.splice(exit.id,1);
      for (var j=exit.id; j<newExits.length; j++) {
        newExits[j].id = j;
      }

      var oldPairExits,newPairExits,pairRoomId;
      if (deletePair) {
        pairRoomId = exit.room;
        var pair = getExitAt(exit.tx,exit.ty,exit.room);
        oldPairExits = clone(data.rooms[pairRoomId].exits);
        newPairExits = clone(oldPairExits);

        newPairExits.splice(pair.id,1);
        for (var j=pair.id; j<newPairExits.length; j++) {
          newPairExits[j].id = j;
        }
      }

      pushHistory('delete exit', function() {
        data.rooms[roomId].exits = clone(newExits);
        if (deletePair) data.rooms[pairRoomId].exits = clone(newPairExits);
        setActiveExit(newExitId);
        syncExitProperties();
        renderRoom();
      },function() {
        data.rooms[roomId].exits = clone(oldExits);
        if (deletePair) data.rooms[pairRoomId].exits = clone(oldPairExits);
        setActiveExit(oldExitId);
        syncExitProperties();
        renderRoom();
      });
    }

    if (!isExitConfigured(exit)) {
      proceed();
    }
    else {
      confirmAction('Delete this exit?'+(deletePair?" (It's connecting exit will also be deleted.)":''), 'Delete', function(confirmed) {
        if (confirmed) proceed();
      });
    }
  }
  bind(one('#exit-actions .delete'), 'click', UI_deleteExit);
  bind(editRoom, 'click', function(event) {
    var oldRoomId = data.editor.activeRoomId;
    var oldExitId = data.editor.activeExitId;
    var newRoomId = parseInt(exitImage.dataset.roomId);
    var newExitId;

    var exit = data.rooms[oldRoomId].exits[oldExitId];
    var exitType = getExitType(exit);
    var updateExit = exitType==ExitType.Edge && exit.edge!=-1 && exit.tx!=-1 && exit.ty!=-1;
    if (updateExit) {
      var pair = getExitAt(exit.tx,exit.ty,exit.room);
      newExitId = pair.id;
    }

    pushHistory('set active room and exit', function() {
      setActiveRoom(newRoomId);
      if (updateExit) setActiveExit(newExitId);
      renderRoom();
    },function() {
      setActiveRoom(oldRoomId);
      if (updateExit) setActiveExit(oldExitId);
      renderRoom();
    }); // TODO: is this UI-only? NO! setActiveExit modifies exit by calling syncExitProperties! :cold_sweat:
  });

  function inAudioMode() {
    return (data.editor.activeModeId==EditorMode.Song || data.editor.activeModeId==EditorMode.Sound);
  }
  function inTextInput() {
    return !!((window.event.target instanceof HTMLInputElement && window.event.target.type.match(/^text$/)) || window.event.target instanceof HTMLTextAreaElement);
  }
  function defocus() {
    if (document.activeElement && document.activeElement!=document.body) {
      // prevents focus/blur/focus weirdness when clicking on script editor
      var sameElement = (event && document.activeElement.className.match(/\bace_/) && event.target.className.match(/\bace_/));
      if (sameElement) return;
      else document.activeElement.blur();
    }
    dismissPreview();
  }

  //////////////////////////////////////////////////////////
  // drawing
  var isDown = false;
  var isJustDown = false;
  var origin = null;
  var startX,startY;
  var lastX,lastY,lastX2;
  var cursorX,cursorY,cursorX2;
  var moveX,moveY;
  var offsetX,offsetY;
  var isSelecting = false;
  var isMoving = false;
  var isResizing = false;
  var isCopying = false;
  var color = 0; // 0=white, 1=black

  // TODO: branch on audioSource.type
  var drawHistory = {
    startData:null,

    dirtyPlayer:false,
    dirtyStartRoom:false,

    dirtyFrames:null,
    dirtyRooms:null,
    dirtyPipes:null,
    dirtyChars:null,
    dirtyExits:null,

    startTileId:null,
    dirtyTileId:null,

    startExitId:null,
    dirtyExitId:null,

    startLayerId:null,
    dirtyLayerId:null,

    startNoteId:null,
    dirtyNoteId:null,

    dirtyNotes:false,
    dirtyParts:false,
    startVoiceId:null,
    dirtyVoiceId:null,
    startSelectedNotes:null,
    startSelectedParts:null,
  }
  function initializeDrawHistory() {
    drawHistory.startData = clone(data);

    drawHistory.dirtyFrames = [];
    drawHistory.dirtyRooms = [];
    drawHistory.dirtyPipes = [];
    drawHistory.dirtyChars = [];
    drawHistory.dirtyExits = [];
    drawHistory.dirtyPlayer = false;
    drawHistory.dirtyStartRoom = false;

    drawHistory.startTileId = drawHistory.dirtyTileId = data.editor.activeTileId;
    drawHistory.startExitId = drawHistory.dirtyExitId = data.editor.activeExitId;
    drawHistory.startLayerId = drawHistory.dirtyLayerId = data.editor.activeLayerId;

    drawHistory.dirtyNotes = false;
    drawHistory.dirtyParts = false;
    drawHistory.startVoiceId = drawHistory.dirtyVoiceId = data.editor.activeVoiceId;
    drawHistory.startNoteId = drawHistory.dirtyNoteId = scrollNoteId;
    drawHistory.startSelectedNotes = clone(selectedNotes);
    drawHistory.startSelectedParts = clone(selectedParts);
  }
  function finalizeDrawHistory() {
    if (!drawHistory.startData) return; // this shouldn't be possible but just in case...

    var oldData = clone(drawHistory.startData);

    var modFrames = drawHistory.dirtyFrames.filter(filterUnique);
    var modPipes = drawHistory.dirtyPipes.filter(filterUnique);
    var modChars = drawHistory.dirtyChars.filter(filterUnique);
    var modExits = drawHistory.dirtyExits.filter(filterUnique);
    var modRooms = drawHistory.dirtyRooms.filter(filterUnique);

    var modPlayer = drawHistory.dirtyPlayer;
    var modStartRoom = drawHistory.dirtyStartRoom;

    var oldTileId = drawHistory.startTileId;
    var newTileId = drawHistory.dirtyTileId;

    var oldExitId = drawHistory.startExitId;
    var newExitId = drawHistory.dirtyExitId;

    var oldLayerId = drawHistory.startLayerId;
    var newLayerId = drawHistory.dirtyLayerId;

    var oldVoiceId = drawHistory.startVoiceId;
    var newVoiceId = drawHistory.dirtyVoiceId;

    var oldNoteId = drawHistory.startNoteId;
    var newNoteId = drawHistory.dirtyNoteId;

    var modNotes = drawHistory.dirtyNotes;
    var oldSelectedNotes = drawHistory.startSelectedNotes;
    var newSelectedNotes = clone(selectedNotes);
    var modSelectedNotes = false;
    if (oldSelectedNotes.length!=newSelectedNotes.length) {
      modSelectedNotes = true;
    }
    else {
      for (var i=0; i<oldSelectedNotes.length; i++) {
        if (oldSelectedNotes[i]!=newSelectedNotes[i]) {
          modSelectedNotes = true;
          break;
        }
      }
    }

    var modParts = drawHistory.dirtyParts;
    var oldSelectedParts = drawHistory.startSelectedParts;
    var newSelectedParts = clone(selectedParts);
    var modSelectedParts = false;
    if (oldSelectedParts.length!=newSelectedParts.length) {
      modSelectedParts = true;
    }
    else {
      for (var i=0; i<oldSelectedParts.length; i++) {
        if (oldSelectedParts[i]!=newSelectedParts[i]) {
          modSelectedParts = true;
          break;
        }
      }
    }

    var modified = (modPlayer || modStartRoom || modFrames.length>0 || modPipes.length>0 || modChars.length>0 || modExits.length>0 || modRooms.length>0 || oldTileId!=newTileId || oldExitId!=newExitId || oldLayerId!=newLayerId || modSelectedParts || modSelectedNotes || modNotes || modParts || oldVoiceId!=newVoiceId || oldNoteId!=newNoteId);

    if (modified) {
      if (modRooms.length>0) renderRoomSelect();

      var newData = clone(data);

      function cleanup() {
        if (modFrames.length>0) {
          for (var i=0; i<modFrames.length; i++) {
            var frameId = modFrames[i];
            cacheFrameImageData(frameId);

            var dataURL = getFrameDataURL(frameId, data.editor.activeTileId);
            each('i[data-frame-id="'+frameId+'"] img,img[data-frame-id="'+frameId+'"]', function(i,node) {
              node.src = dataURL;
            });
          }
          renderRoom();
        }

        if (modPipes.length>0) {
          for (var i=0; i<modPipes.length; i++) {
            var pipeId = modPipes[i];
            cachePipeImageData(pipeId);

            var dataURL = getPipeDataURL(pipeId);
            each('i[data-pipe-id="'+pipeId+'"] img,img[data-pipe-id="'+pipeId+'"]', function(i,node) {
              node.src = dataURL;
            });
          }
          renderText();
        }

        if (modChars.length>0) {
          for (var i=0; i<modChars.length; i++) {
            var charId = modChars[i];
            cacheCharImageData(charId);

            var dataURL = getCharDataURL(charId);
            each('i[data-char-id="'+charId+'"] img,img[data-char-id="'+charId+'"]', function(i,node) {
              node.src = dataURL;
            });
          }
          renderText();
        }

        if (modExits.length>0) {
          syncExitProperties();
        }

        if (modStartRoom) {
          modifiedStartRoom = true;
          preventDeletingStartRoom();
        }

        if (modSelectedParts || modParts) {
          renderParts();
          renderSong();
        }
        if (modSelectedNotes || modNotes) {
          updateAudioSource();
          renderNotes();
          renderSong();
        }

        renderRoomSelect();
      }

      // NOTE: because we're directly manipulating data before pushing to
      // history cleanup() isn't called except when undoing and redoing!

      pushHistory('draw', function() {
        data = clone(newData);
        if (oldTileId!=newTileId) setActiveTile(newTileId);
        if (oldExitId!=newExitId) setActiveExit(newExitId);
        if (oldLayerId!=newLayerId) setActiveLayer(newLayerId);

        if (oldVoiceId!=newVoiceId) setActiveVoice(newVoiceId);
        if (oldNoteId!=newNoteId) setScrollNote(newNoteId);
        if (modSelectedParts) selectedParts = clone(newSelectedParts);
        if (modSelectedNotes) selectedNotes = clone(newSelectedNotes);
        cleanup();
      },function() {
        data = clone(oldData);
        if (oldTileId!=newTileId) setActiveTile(oldTileId);
        if (oldExitId!=newExitId) setActiveExit(oldExitId);
        if (oldLayerId!=newLayerId) setActiveLayer(oldLayerId);

        if (oldVoiceId!=newVoiceId) setActiveVoice(oldVoiceId);
        if (oldNoteId!=newNoteId) setScrollNote(oldNoteId);
        if (modSelectedParts) selectedParts = clone(oldSelectedParts);
        if (modSelectedNotes) selectedNotes = clone(oldSelectedNotes);
        cleanup();
      }, true);
    }

    drawHistory.startData = null;
    drawHistory.dirtyFrames = null;
    drawHistory.dirtyRooms = null;
    drawHistory.dirtyPipes = null;
    drawHistory.dirtyChars = null;
    drawHistory.dirtyExits = null;

    drawHistory.startSelectedNotes = null;
    drawHistory.startSelectedParts = null;
  }

  var startingNotes = [];
  function cancelDraw(event) {
    if (origin==roomImage) {
      if (data.editor.activeLayerId==Layer.Exits) {
        document.body.classList.remove('exit-dragging');
      }
    }
    else if (origin==notesImage) {
      if (isSelecting) {
        notesSelect.style.display = 'none';
      }

      if (isCopying || isMoving) {
        var dx = moveX-startX;
        var dy = moveY-startY;

        if (dx!=0 || dy!=0) drawHistory.dirtyNotes = true;
        moveSelectedNotes(dx,dy,isCopying);

        isMoving = false;
        isCopying = false;

        renderNotes();
        renderSong();
      }
    }
    else if (origin==songImage) {
      if (isCopying || isMoving) {

        var dx = moveX-startX;
        var dy = moveY-startY;

        if (dx!=0 || dy!=0) drawHistory.dirtyParts = true;
        moveSelectedParts(dx,dy,isCopying);

        isMoving = false;
        isCopying = false;

        renderNotes();
        renderSong();
      }
    }

    isDown = false;
    isJustDown = false;
    lastX = null;
    lastY = null;
    lastX2 = null;
    startX = null;
    startY = null;
    moveX = null;
    moveY = null;
    offsetX = null;
    offsetY = null;
    isSelecting = false;
    isMoving = false;
    isResizing = false;
    isCopying = false;
    origin = null;
    roomCursor.style.top = '-1000px';
    roomCursor.style.left = '-1000px';
    finalizeDrawHistory();
  }
  function draw(event) {
    var x,y,i;

    if (isPreviewingText && data.editor.activeModeId!=EditorMode.Font) cancelDraw();


    if (!isDown) {
      exitCursor.style.display = event.target==exitImage ? 'block' : 'none';

      if (event.target==roomImage) {
        // TODO: clamp
        x = Math.floor(event.offsetX/tileWidth/roomEditorScale);
        y = Math.floor(event.offsetY/tileHeight/roomEditorScale);
        if (x!=cursorX || y!=cursorY) {
          if (data.editor.activeLayerId==Layer.Exits && data.editor.showLayer[Layer.Exits] && getExitAt(x,y)) {
            // print('hide room cursor on Exit layer');
            roomCursor.style.top = '-1000px';
            roomCursor.style.left = '-1000px';
          }
          else {
            roomCursor.style.top = (4 + y*tileHeight*roomEditorScale) + 'px';
            roomCursor.style.left = (4 + x*tileWidth*roomEditorScale) + 'px';
          }
          roomImage.title = x+','+y;
        }
        cursorX = x;
        cursorY = y;
      }
      else if (event.target==exitImage) {
        // TODO: clamp
        x = Math.floor(event.offsetX/tileWidth/exitEditorScale);
        y = Math.floor(event.offsetY/tileHeight/exitEditorScale);
        if (x!=cursorX || y!=cursorY) {
          // print('update exit cursor position');
          exitCursor.style.top = (4 + y*tileHeight*exitEditorScale) + 'px';
          exitCursor.style.left = (4 + x*tileWidth*exitEditorScale) + 'px';
          exitImage.title = x+','+y;

          var exit = getExit();
          var exitType = getExitType(exit);
          if (exit && exitType==ExitType.Edge && exit.room>-1) {
            exitCursor.style.display = getExitAt(x,y,exit.room) ? 'none' : 'block';
          }

        }
        cursorX = x;
        cursorY = y;
      }

      if (inAudioMode()) {
        if (event.target==notesImage) {
          // TODO: clamp
          x = Math.floor(event.offsetX/notesScale);
          y = Math.floor(event.offsetY/notesScale);

          var noteId = getNoteAt(x,y);
          // TODO: clamp
          var x2 = Math.floor(event.offsetX/(notesScale/2));
          if (getToolMode('notes')=='clone' && selectedNotes.length>0) {
            notesImage.style.cursor = 'grab';
          }
          else {
            if (noteId!=-1) {
              var notes = audioSource.notes;
              var hold = notes[(noteId * 3) + 2];
              if (x2!=cursorX2 || y!=cursorY) {
                notesImage.style.cursor = (x*2!=x2 && x==noteId+hold-1) ? 'ew-resize' : 'move';
              }
            }
            else {
              notesImage.style.cursor = 'auto';
            }
          }
          cursorX2 = x2;

          if (getToolMode('notes')=='lasso' || selectedNotes.length>0 || noteId!=-1) {
            x = -1;
            y = -1;
          }

          if (x!=cursorX || y!=cursorY) {
            notesCursor.style.top = (y*notesScale) + 'px';
            notesCursor.style.left = (x*notesScale) + 'px';
          }

          cursorX = x;
          cursorY = y;
        }
        else {
          // TODO: move to reset cursor function?
          notesCursor.style.top = -notesScale+'px';
          notesCursor.style.left = -notesScale+'px';
          cursorX = null;
          cursorY = null;
        }
      }
    }

    if (isJustDown) {
      // create new exit if necessary
      if (origin==roomImage && getToolMode('room')=='draw') {
        if (data.editor.activeLayerId==Layer.Exits) {
          // print('clicked exit layer');
          var roomExits = data.rooms[data.editor.activeRoomId].exits;
          var x = clamp(Math.floor(event.offsetX/tileWidth/roomEditorScale), 0,roomTilesWide-1);
          var y = clamp(Math.floor(event.offsetY/tileHeight/roomEditorScale), 0,roomTilesHigh-1);
          var exit = getExitAt(x,y);

          if (!exit) {
            // print('create new exit');
            exit = {
              id:roomExits.length,
              x:x,
              y:y,
            };
            roomExits[exit.id] = exit;
            setActiveExit(exit.id);
            drawHistory.dirtyExits.push(exit.id);
            renderRoom();
          }
          else if (exit.id!=data.editor.activeExitId) {
            // print('select existing exit');
            setActiveExit(exit.id);
            drawHistory.dirtyExits.push(exit.id);
            renderRoom();
          }
          document.body.classList.add('exit-dragging');
        }
      }

      if (inAudioMode()) {
        if (origin==songNotesTrack) {
          offsetX = (event.offsetX/2) - scrollNoteId;
          isSelecting = true;
        }
        else if (origin==songPlayheadTrack) {
          isSelecting = true;
        }
        else if (origin==notesImage) {
          // TODO: why don't just use
          isSelecting = getToolMode('notes')=='lasso';
          isCopying = getToolMode('notes')=='clone';
          // TODO: clamp
          startX = Math.floor(event.offsetX/notesScale);
          startY = Math.floor(event.offsetY/notesScale);

          var noteX = scrollNoteId;
          startX += noteX;

          if (isSelecting) {
            startingNotes = clone(selectedNotes);
          }

          var noteId = getNoteAt(startX,startY);
          var notes = audioSource.notes;
          if (noteId>-1) {
            setSelectedNote(noteId);
            if (selectedNotes.indexOf(noteId)==-1) {
              if (!isSelecting) deselectNotes();
              pushSelectedNote(noteId);
            }

            var j = noteId * 3;
            var note = notes[j];
            var octave = notes[j+1];
            var hold = notes[j + 2];

            noteOnOff(note-1,octave,1,audioSource.voice);

            // TODO: clamp
            var startX2 = Math.floor(event.offsetX/(notesScale/2));
            startX2 += noteX * 2;

            if (startX==noteId+hold-1 && startX*2!=startX2) {
              isResizing = true;
            }
            else {
              isMoving = !isCopying;
              moveX = startX;
              moveY = startY;
            }
          }
          else if (!isSelecting) {
            var len = selectedNotes.length;
            deselectNotes();
            if (len>1) {
              // buh
            }
            else {
              var octave = 4;
              for (var i=startX; i>0; i--) {
                var j = i * 3;
                if (!notes[j]) continue;
                octave = notes[j+1];
                break;
              }

              var j = startX * 3;
              var note = 11 - startY;
              note += 1;

              setNoteAt(startX, note,octave,1);
              var voiceId = data.editor.activeVoiceId;
              if (audioSource.type==AudioSource.Sound) {
                voiceId = data.sounds[data.editor.activeSoundId].type;
              }
              noteOnOff(note-1,octave,1,voiceId);

              noteId = startX;
              setSelectedNote(noteId);
              if (selectedNotes.indexOf(noteId)==-1) {
                pushSelectedNote(noteId);
                isResizing = true;
              }

              trimNoteTail(startX);
            }
          }
          renderNotes();
        }
        else if (origin==songImage) {
          isSelecting = getToolMode('song')=='lasso';
          isCopying = getToolMode('song')=='clone';
          // TODO: clamp
          startX = Math.floor(event.offsetX/8);
          startY = Math.floor(event.offsetY/32);

          if (startY!=data.editor.activeVoiceId) {
            setActiveVoice(startY);
            deselectParts();
          }

          // TODO: revisit to allow dragging/moving/copying selected parts
          var partId = getPartAt(startX,startY); // NOTE: actual return value is splitX value, kinda weird
          moveX = startX;
          moveY = startY;
          if (partId>-1) {
            isMoving = !isCopying;
            if (selectedParts.indexOf(partId)==-1) {
              if (!isSelecting) deselectParts();
              selectedParts.push(partId);
            }
            highlightSelectedParts();
          }
          else if (!isSelecting) {
            deselectParts();
          }
        }

        if (origin!=notesImage) {
          if (!origin.classList.contains('stepper-button') && !origin.classList.contains('stepper-value')) {
            deselectNotes();
            startingNotes.length = 0;
            renderNotes();
          }
        }
        if (origin!=songImage && origin!=songPlayheadTrack && origin!=songNotesTrack && !(origin instanceof HTMLButtonElement)) {
          deselectParts();
        }
      }
    }

    if (isDown && (event.target==origin || isSelecting)) {
      if (origin==frameImage) {
        if (data.editor.activeTileId==0 || data.editor.activeTileId==1) return;

        x = clamp(Math.floor(event.offsetX/tileEditorScale), 0,tileWidth-1);
        y = clamp(Math.floor(event.offsetY/tileEditorScale), 0,tileHeight-1);
        i = y * tileWidth + x;

        if (x!=lastX || y!=lastY) {
          // update tile
          var frameId = data.editor.activeFrameId;
          var frameData = data.frames[frameId].data;
          var modified = false;
          if (getToolMode('tile')=='move') {
            if (lastX!=null && lastY!=null) {
              shiftData(frameData,x-lastX,y-lastY);
              cacheFrameImageData(frameId);
              modified = true;
            }
          }
          else {
            if (event.type=='mousedown') {
              var px = frameData[i];
              color = px==0 || px==2 ? 1 : 0;
            }

            if (data.editor.activeLayerId==Layer.Player && getToolMode('tile')=='erase') {
              color = 2;
            }

            if (frameData[i]!=color) {
              if (getToolMode('tile')=='fill') {
                floodFillData(frameData,x,y,color);
                cacheFrameImageData(frameId);
              }
              else {
                frameData[i] = color; // update data
                frameContext.putImageData(frameImageDatas[frameId],0,0); // reload the active tile
                frameContext.putImageData(color==0?whitePixel:(color==1?blackPixel:clearPixel),x,y); // update preview
                frameImageDatas[frameId] = frameContext.getImageData(0,0,tileWidth,tileHeight); // update cache

                frameContext.fillStyle = 'rgba(255,0,0,0.5)';
                frameContext.fillRect(x,y,1,1); // add wall overlay to existing image data
                scratchContext.putImageData(wallImageDatas[frameId],0,0); // reload existing wall image data
                scratchContext.putImageData(frameContext.getImageData(x,y,1,1),x,y); // update just the pixel that changed
                wallImageDatas[frameId] = scratchContext.getImageData(0,0,tileWidth,tileHeight); // update cache
              }
              modified = true;
            }
          }

          if (modified) {
            drawHistory.dirtyFrames.push(frameId);
            var dataURL = getFrameDataURL(frameId, data.editor.activeTileId);
            each('i[data-frame-id="'+frameId+'"] img,img[data-frame-id="'+frameId+'"]', function(i,node) {
              node.src = dataURL;
            });
            renderPreview();
            renderRoom();
          }
        }
      }
      else if (origin==charImage) {
        x = clamp(Math.floor(event.offsetX/tileEditorScale), 0,tileWidth-1);
        y = clamp(Math.floor(event.offsetY/tileEditorScale), 0,tileHeight-1);
        i = y * tileWidth + x;

        if (x!=lastX || y!=lastY) {
          var srcType;
          var srcId;
          var srcData;
          var srcImageDatas;
          var getSrcDataURL;
          var cacheSrcImageData;
          var srcDirty;
          if (data.editor.activePipeId>-1) {
            srcType = 'pipe';
            srcId = data.editor.activePipeId;
            srcData = data.font.pipe;
            srcImageDatas = pipeImageDatas;
            getSrcDataURL = getPipeDataURL;
            cacheSrcImageData = cachePipeImageData;
            srcDirty = drawHistory.dirtyPipes;
          }
          else {
            srcType = 'char';
            srcId = data.editor.activeCharId;
            srcData = data.font.chars;
            srcImageDatas = charImageDatas;
            getSrcDataURL = getCharDataURL;
            cacheSrcImageData = cacheCharImageData;
            srcDirty = drawHistory.dirtyChars;

            if (data.font.type==FontType.HalfWidth && x>=tileWidth/2) {
              return;
            }
          }

          var frameData = srcData[srcId];
          var modified = false;
          if (getToolMode('char')=='move') {
            if (lastX!=null && lastY!=null) {
              if (isShiftPressed) {
                var start,len;
                if (data.editor.activePipeId>=9) { // cursor
                  start = 9;
                  len = srcData.length;
                }
                else if (data.editor.activePipeId>-1) { // window
                  start = 0;
                  len = 9;
                }
                else { // char
                  start = 0;
                  len = srcData.length;
                }

                for (var j=start; j<len; j++) {
                  var srcId = j;
                  var frameData = srcData[srcId];
                  shiftData(frameData,x-lastX,y-lastY);
                  cacheSrcImageData(srcId);
                  srcDirty.push(srcId);
                  var dataURL = getSrcDataURL(srcId);
                  each('i[data-'+srcType+'-id="'+srcId+'"] img,img[data-'+srcType+'-id="'+srcId+'"]', function(i,node) {
                    node.src = dataURL;
                  });
                }
                renderText();
              }
              else {
                shiftData(frameData,x-lastX,y-lastY);
                cacheSrcImageData(srcId);
                modified = true;
              }
            }
          }
          else {

            if (event.type=='mousedown') {
              color = frameData[i]==0 ? 1 : 0;
            }

            if (frameData[i]!=color) {
              if (getToolMode('char')=='fill') {
                floodFillData(frameData,x,y,color);
                cacheSrcImageData(srcId);
              }
              else {
                frameData[i] = color;
                frameContext.putImageData(srcImageDatas[srcId],0,0); // reload the active tile
                frameContext.putImageData(color==0?whitePixel:blackPixel,x,y); // update preview
                srcImageDatas[srcId] = frameContext.getImageData(0,0,tileWidth,tileHeight); // update cache
              }
              modified = true;
            }
          }

          if (modified) {
            srcDirty.push(srcId);
            var dataURL = getSrcDataURL(srcId);
            each('i[data-'+srcType+'-id="'+srcId+'"] img,img[data-'+srcType+'-id="'+srcId+'"]', function(i,node) {
              node.src = dataURL;
            });
            renderText();
          }
        }
      }
      else if (origin==roomImage) {
        x = clamp(Math.floor(event.offsetX/tileWidth/roomEditorScale ), 0,roomTilesWide-1);
        y = clamp(Math.floor(event.offsetY/tileHeight/roomEditorScale), 0,roomTilesHigh-1);
        i = y * roomTilesWide + x;

        if (x!=lastX || y!=lastY) {
          // update room
          var roomId = data.editor.activeRoomId;
          var roomData = data.rooms[roomId];
          var roomTiles = roomData.tiles;
          var tileId = roomTiles[i];

          if (getToolMode('room')=='sample') {
            var exit = getExitAt(x,y, data.editor.activeRoomId);
            var tile = data.tiles[tileId];
            if (!data.editor.showLayer[TileTypeToLayer[tile.type]]) {
              tileId = 0;
            }
            if (data.editor.showLayer[Layer.Player] && data.player.room==data.editor.activeRoomId && data.player.x==x && data.player.y==y) {
              setActiveTile(data.player.id);
              drawHistory.dirtyTileId = data.player.id;
            }
            else if (exit && data.editor.showLayer[Layer.Exits]) {
              if (exit.id!=data.editor.activeExitId || data.editor.activeLayerId!=Layer.Exits) {
                setActiveExit(exit.id);
                setActiveLayer(Layer.Exits);
                drawHistory.dirtyExitId = exit.id;
                drawHistory.dirtyLayerId = Layer.Exits;
                renderRoom();
              }
            }
            else if (tileId!=data.editor.activeTileId || data.editor.activeLayerId==Layer.Exits) {
              setActiveTile(tileId);
              drawHistory.dirtyTileId = tileId;
            }
          }
          else if (getToolMode('room')=='fill') {
            var area = floodFillData(roomTiles,x,y,data.editor.activeTileId);
            if (area>0) {
              renderRoom();
              drawHistory.dirtyRooms.push(roomId);
            }
          }
          else if (getToolMode('room')=='move') {
            if (lastX!=null && lastY!=null) {
              var dx = x-lastX;
              var dy = y-lastY;
              shiftData(roomTiles,dx,dy);
              if (roomId==data.player.room) {
                var px = data.player.x + dx;
                var py = data.player.y + dy;
                if (px<0) px += roomTilesWide;
                if (px>=roomTilesWide) px -= roomTilesWide;
                if (py<0) py += roomTilesHigh;
                if (py>=roomTilesHigh) py -= roomTilesHigh;
                data.player.x = px;
                data.player.y = py;
              }
              var exits = data.rooms[roomId].exits;
              for (var j=0; j<exits.length; j++) {
                var exit = exits[j];
                if (!isset(exit.x) || !isset(exit.y)) continue;

                var ex = exit.x + dx;
                var ey = exit.y + dy;
                if (ex<0) ex += roomTilesWide;
                if (ex>=roomTilesWide) ex -= roomTilesWide;
                if (ey<0) ey += roomTilesHigh;
                if (ey>=roomTilesHigh) ey -= roomTilesHigh;

                exit.x = ex;
                exit.y = ey;

                var exitType = getExitType(exit);
                if (exitType==ExitType.Edge) {
                  if (exit.tx>-1 && exit.ty>-1) { // updating an existing exit
                    var pair = getExitAt(exit.tx,exit.ty,exit.room);
                    pair.tx = exit.x;
                    pair.ty = exit.y;
                    drawHistory.dirtyRooms.push(exit.room);
                  }
                }

                drawHistory.dirtyExits.push(exit.id);
              }
              renderRoom();
              drawHistory.dirtyRooms.push(roomId);
            }
          }
          else if (data.editor.activeLayerId==Layer.Exits) {
            var exit = getExit();
            if (exit) { // move
              // print('move exit');

              var existingExit = getExitAt(x,y,null,exit);
              if (existingExit) {
                // buh, don't move until we're clear of all exits
              }
              else {
                exit.x = x;
                exit.y = y;
                syncExitProperties();

                var exitType = getExitType(exit);
                if (exitType==ExitType.Edge) {
                  // updating an existing exit
                  if (exit.tx>-1 && exit.ty>-1) {
                    var pair = getExitAt(exit.tx,exit.ty,exit.room);
                    pair.tx = exit.x;
                    pair.ty = exit.y;
                    drawHistory.dirtyRooms.push(exit.room);
                  }
                }
                renderRoom();
                drawHistory.dirtyExits.push(exit.id);
              }
            }
          }
          else {  // update data
            var tile = data.tiles[data.editor.activeTileId];
            if (tile.type==TileType.Player) {
              var oldStartRoom = data.player.room;
              data.player = {
                room: data.editor.activeRoomId,
                id: data.player.id,
                x: x,
                y: y
              };

              if (oldStartRoom!=data.player.room) {
                preventDeletingStartRoom();
                renderRoomSelect();
                drawHistory.dirtyStartRoom = true;
              }
              drawHistory.dirtyPlayer = true;
            }
            else {
              if (roomId==data.player.room) {
                drawHistory.dirtyStartRoom = true;
              }
              roomTiles[i] = data.editor.activeTileId;
            }
            renderRoom();
            drawHistory.dirtyRooms.push(roomId);
          }
        }
      }
      else if (origin==exitImage) {
        x = clamp(Math.floor(event.offsetX/tileWidth/exitEditorScale ), 0,roomTilesWide-1);
        y = clamp(Math.floor(event.offsetY/tileHeight/exitEditorScale), 0,roomTilesHigh-1);
        i = y * roomTilesWide + x;

        var exit = getExit();
        var exitType = getExitType(exit);
        if (exit && exitType!=ExitType.Ending && exit.room>-1) { // we are editing a valid exit
          // print('move exit in exit connection preview')
          if (exitType==ExitType.Edge) {

            if (exit.tx>-1 && exit.ty>-1) { // updating an existing exit
              var pair = getExitAt(exit.tx,exit.ty,exit.room);
              pair.x = x;
              pair.y = y;
              drawHistory.dirtyRooms.push(exit.room);
            }
            else {
              var room = data.rooms[exit.room];
              var pair = {
                id: room.exits.length,
                x: x,
                y: y,
                edge: getOppositeEdge(exit),
                room: data.editor.activeRoomId,
                tx: exit.x,
                ty: exit.y,
              };
              room.exits[pair.id] = pair;
              drawHistory.dirtyRooms.push(exit.room);
            }
            exitCursor.style.display = 'none';
          }

          exit.tx = x;
          exit.ty = y;

          syncExitProperties();
          renderRoom();
          drawHistory.dirtyExits.push(exit.id);
        }
      }
      else if (origin==fontImage) {
        x = clamp(Math.floor(event.offsetX/tileWidth/roomEditorScale ), 0,roomTilesWide-1);
        y = clamp(Math.floor(event.offsetY/tileHeight/roomEditorScale), 0,roomTilesHigh-1);
        i = y * roomTilesWide + x;

        var x2 = clamp(Math.floor(event.offsetX/(tileWidth/2)/roomEditorScale), 0,(roomTilesWide*2)-1);
        if (x!=lastX || x2!=lastX2 || y!=lastY) {
          // if (isShiftPressed) {
          var o = 3;
          if (x>=o && y>=o && x<textPreviewMeta.tilesWide+o && y<textPreviewMeta.tilesHigh+o) {
            var j = textPreviewMeta.data[y-o][x-o];
            if (j<0) {
              setActivePipe(-j-1); // yikes!
            }
            else {
              if (textPreviewMeta.isHalfWidth) {
                if (x==x2/2) setActiveChar(textPreviewMeta.decodeA(j));
                else setActiveChar(textPreviewMeta.decodeB(j));
              }
              else {
                setActiveChar(j);
              }
            }
          }
          // }
        }
        lastX2 = x2;
      }

      // TODO: clamp x,y
      if (inAudioMode()) {
        if (origin==songNotesTrack) {
          event.preventDefault();
          var clipRect = songNotesTrack.getBoundingClientRect()
          var eventX = event.clientX - clipRect.left;
          var eventY = event.clientY - clipRect.top;

          x = Math.floor(eventX/2);
          y = Math.floor(eventY/2);

          var noteId = x - offsetX;
          noteId = Math.floor(noteId / 4) * 4;
          if (noteId<0) noteId = 0;
          if (noteId>maxSongLength-notesLength) noteId = maxSongLength-notesLength;

          if (noteId!=scrollNoteId) {
            setScrollNote(noteId);
            drawHistory.dirtyNoteId = noteId;
          }
        }
        else if (origin==songPlayheadTrack) {
          event.preventDefault();
          var clipRect = songNotesTrack.getBoundingClientRect()
          var eventX = event.clientX - clipRect.left;
          var eventY = event.clientY - clipRect.top;

          x = Math.floor(eventX/2);
          y = Math.floor(eventY/2);
          var oldTick = tick;
          tick = Math.floor(x / 4) * 4;
          if (tick<0) tick = 0;
          if (tick>512-2) tick = 512-2;
          if (oldTick!=tick) {
            stopAllVoices();
            updatePlayheads();
          }
        }
        else if (origin==notesImage) {
          // TODO: move to reset cursor function?
          notesCursor.style.top = -notesScale+'px';
          notesCursor.style.left = -notesScale+'px';
          cursorX = null;
          cursorY = null;

          // replacement for event.offsetX/Y so selection can update even when not over notesImage
          var clipRect = notesImage.getBoundingClientRect()
          var eventX = event.clientX - clipRect.left;
          var eventY = event.clientY - clipRect.top;

          x = Math.floor(eventX/notesScale);
          y = Math.floor(eventY/notesScale);

          var noteX = scrollNoteId;
          x += noteX;

          if (x!=lastX || y!=lastY) {
            if (isCopying) {
              notesImage.style.cursor = 'grabbing';
              moveX = x;
              moveY = y;
            }
            else if (isSelecting) {
              var lastNotes = clone(selectedNotes);
              selectedNotes = clone(startingNotes);

              var selectX = startX;
              var width = x-startX;
              if (width<0) {
                selectX += width;
                width *= -1;
              }

              var selectY = startY;
              var height = y-startY;

              if (height<0) {
                selectY += height;
                height *= -1;
              }

              width += 1;
              height += 1;

              if (selectX<0) {
                width += selectX;
                selectX = 0;
              }
              if (selectY<0) {
                height += selectY;
                selectY = 0;
              }
              if (selectX+width-noteX>64) width = 64 - (selectX-noteX);
              if (selectY+height>12) height = 12 - selectY;

              var notes = audioSource.notes;
              for (var i=noteX; i<selectX+width; i++) {
                var j = i * 3;
                var note = notes[j];
                if (!note) continue;
                note -= 1;
                var noteY = 11 - note;
                var octave = notes[j+1];
                var hold = notes[j+2];
                if (i<selectX+width && i+hold>selectX && noteY<selectY+height && noteY+1>selectY) {
                  if (selectedNotes.indexOf(i)==-1) {
                    pushSelectedNote(i);
                    if (lastNotes.indexOf(i)==-1) {
                      noteOnOff(note,octave,1,audioSource.voice);
                    }
                  }
                }
              }

              notesSelect.style.display = 'block';
              notesSelect.style.top = (selectY * notesScale)+'px';
              notesSelect.style.left = ((selectX-noteX) * notesScale)+'px';
              notesSelect.style.width = (width * notesScale)+'px';
              notesSelect.style.height = (height * notesScale)+'px';
            }
            else if (!isJustDown && selectedNoteId>-1) {
              var j = selectedNoteId * 3;

              var notes = audioSource.notes;
              var note = notes[j];
              var octave = notes[j+1];
              var hold = notes[j+2];

              if (isResizing) {
                var diff = x - (selectedNoteId + hold) + 1;
                if (diff!=0) {
                  for (var i=0; i<selectedNotes.length; i++) {
                    var noteId = selectedNotes[i];
                    var j = noteId * 3;
                    var note = notes[j];
                    var octave = notes[j+1];
                    var hold = notes[j+2];
                    hold += diff;
                    if (hold<1) hold = 1;
                    setNoteAt(noteId,note,octave,hold);
                    trimNoteHead(noteId,hold);
                  }
                }
              }
              else if (isMoving) {
                moveX = x;
                moveY = y;
                var dy = startY-moveY;
                noteOnOff((note-1)+dy,octave,1,audioSource.voice);
              }
            }
            renderNotes();
            renderSong();
            syncSelectedNote();
          }
        }
        else if (origin==songImage) {
          // replacement for event.offsetX/Y so selection can update even when not over notesImage
          var clipRect = songImage.getBoundingClientRect()
          var eventX = event.clientX - clipRect.left;
          var eventY = event.clientY - clipRect.top;

          x = Math.floor(eventX/8);
          y = Math.floor(eventY/32);

          if (x!=lastX || y!=lastY) {
            if (isCopying || isMoving) {
              moveX = x;
              moveY = y;
              // print('moveY', moveY);
              renderSong(); // TODO: yay or nay?
            }
          }
        }
      }

      lastX = x;
      lastY = y;
      isJustDown = false;
    }
  }
  bind(document, 'mousedown', function(event) {
    defocus();

    if (event.target.dataset && event.target.dataset.toolName) return; // ignore clicks on palette to preserve selection

    initializeDrawHistory();

    isDown = true;
    isJustDown = true;
    origin = event.target;
    draw(event);
  });
  bind(document, 'mousemove', draw);
  bind(document, 'mouseup', cancelDraw);

  // improve Firefox compatibility (it doesn't honor draggable=false)
  bind(document, 'dragstart', function(event) {
    event.preventDefault();
    return false;
  });

  bind(all('button.doppelganger'), 'click', function(event) {
    var id = event.target.dataset.doppelganger;
    var doppelganger = one(`#${id}`);
    if (doppelganger) {
      var mode = event.target.dataset.doppelgangerMode;
      if (mode=='room') UI_changeMode(EditorMode.Room);
      var doppelinput = one(`#${id} input`);
      if (doppelinput) doppelinput.click();
      else doppelganger.click();
    }
  });

  bind(window, 'keydown', function onEditorKeyDown(event) {
    if (event.keyCode==13 && event.target.nodeName=='BUTTON') {
      var fileInput = event.target.id ? one(`#${event.target.id} input`) : null;
      if (fileInput) fileInput.click();
      else event.target.click();
      event.preventDefault();
      event.stopPropagation();
      return;
    }

    if (event.target.nodeName=='OL' && event.target.classList.contains('select')) {
      if (event.keyCode==13) {
        event.target.dispatchEvent(new MouseEvent('mousedown'));
      }
      else if (event.keyCode==38 || event.keyCode==40 || event.key.match(/^[a-z0-9]$/)) {
        event.target.dispatchEvent(new MouseEvent('mousedown'));
        document.dispatchEvent(new KeyboardEvent('keydown', {key:event.key, keyCode:event.keyCode}));
        event.preventDefault();
      }

      if (event.keyCode!=27) return;
    }

    if (activeOverlay) {
      if (event.keyCode==27 || (event[cmdKey] && event.keyCode==190)) { // esc or cmd+.
        hideOverlay();
        event.preventDefault();
      }
      else if (event.keyCode==13) { // return
        if (inTextInput()) window.event.target.blur();
        one('#overlay-content-'+activeOverlay+' .button-overlay-confirm').click();
        event.preventDefault();
      }
      return;
    }

    // commands
    if (event[cmdKey]) {
      if (event.keyCode==83) { // save
        flash(saveButton);
        defocus(); // ensures we commit any uncommited changes
        event.preventDefault();
        saveData();
        return false;
      }
      else if (event.keyCode==90) { // undo/redo
        event.preventDefault();
        if (isShiftPressed) {
          flash(redoButton);
          redo();
        }
        else {
          flash(undoButton);
          undo();
        }
        return false;
      }
      else if (event.keyCode==89) { // Windows-style redo
        flash(redoButton);
        redo();
      }
      else if (event.keyCode==66) { // build & run
        // save first
        flash(playButton);
        defocus(); // ensures we commit any uncommited changes
        event.preventDefault();
        window.open('about:blank','player'); // NOTE: required for the async open call below
        saveData(function() {
          window.open(urls.root + currentGameId + '/play/', 'player');
        });
        return false;
      }
      else if (event.keyCode==70) { // f find
        defocus(); // ensures we commit any uncommited changes
        focusSearchInput();
        event.preventDefault();
        return false;
      }
      else if (event.keyCode==71) { // g find again
        if (lastSearch!='' && lastSearch!=null && searchResults.length) {
          defocus(); // ensures we commit any uncommited changes
          setActiveResult(activeResultId,isShiftPressed?-1:1);
          event.preventDefault();
          return false;
        }
      }
    }

    // className-based state control, primarily non-audio mode
    if (event.keyCode==91 || event.keyCode==93 || event.keyCode==224) { // command
      isCommandPressed = true;
      updateToolOverrides();
    }
    else if (event.keyCode==16) { // shift
      isShiftPressed = true;
      updateToolOverrides();
    }
    else if (event.keyCode==18) { // opt/alt
      isOptionPressed = true;
      updateToolOverrides();
    }

    if (inTextInput()) return;

    // mode changing
    if (event.keyCode==49) { // 1
      UI_changeMode(EditorMode.Game);
    }
    else if (event.keyCode==50) { // 2
      UI_changeMode(EditorMode.Font);
    }
    else if (event.keyCode==51) { // 3
      UI_changeMode(EditorMode.Room);
    }
    else if (event.keyCode==52) { // 4
      UI_changeMode(EditorMode.Song);
    }
    else if (event.keyCode==53) { // 5
      UI_changeMode(EditorMode.Sound);
    }
    else if (event.keyCode==54) { // 6
      UI_changeMode(EditorMode.Script);
    }
    else if (event.keyCode==191) { // ?
      focusSearchInput();
      return event.preventDefault();
    }

    if (data.editor.activeModeId==EditorMode.Font) {
      if (event.keyCode==37) { // left
        if (data.editor.activePipeId!=-1) {
          if (data.editor.activePipeId>9 || (data.editor.activePipeId<9 && data.editor.activePipeId>0)) {
            UI_changePipe(data.editor.activePipeId-1);
            event.preventDefault();
          }
        }
        else {
          if (data.editor.activeCharId>0) {
            UI_changeChar(data.editor.activeCharId-1);
            event.preventDefault();
          }
        }
      }
      else if (event.keyCode==39) { // right
        if (data.editor.activePipeId!=-1) {
          if ((data.editor.activePipeId>=9 && data.editor.activePipeId<data.font.pipe.length-1) || (data.editor.activePipeId<8)) {
            UI_changePipe(data.editor.activePipeId+1);
            event.preventDefault();
          }
        }
        else {
          if (data.editor.activeCharId<data.font.chars.length-1) {
            UI_changeChar(data.editor.activeCharId+1);
            event.preventDefault();
          }
        }
      }
      else if (event.keyCode==38) { // up
        if (data.editor.activePipeId==-1 || data.editor.activePipeId>=9) {
          if (data.editor.activePipeId>0) UI_changePipe(0);
          else UI_changePipe(9);
          event.preventDefault();
        }
      }
      else if (event.keyCode==40) { // down
        if (data.editor.activeCharId==-1) {
          if (data.editor.activePipeId<9) UI_changePipe(9);
          else UI_changeChar(0);
          event.preventDefault();
        }
      }
      else if (event.keyCode==73) { // i
        if (isShiftPressed) UI_invertFont();
        else UI_invertCharOrPipe();
        event.preventDefault();
      }
    }
    else if (data.editor.activeModeId==EditorMode.Room) {
      // print(event.keyCode);
      if (event.keyCode==189) { // -
        var i = getSelectedIndex(roomSelect) - 1;
        if (i<0) return;

        setSelectedIndex(roomSelect,i);
        UI_changeRoom();
      }
      else if (event.keyCode==187) { // =
        var i = getSelectedIndex(roomSelect) + 1;
        if (i>=getSelectLength(roomSelect)) return;

        setSelectedIndex(roomSelect,i);
        UI_changeRoom();
      }
      else if (event.keyCode==38) { // up
        var layers = all('#layers li');
        var layerId = -1;
        for (var i=1; i<layers.length; i++) {
          if (layers[i].classList.contains('active')) {
            layerId = i-1;
            break;
          }
        }
        if (layerId>-1) {
          UI_changeLayer(layerId);
          event.preventDefault();
          // return false;
        }
      }
      else if (event.keyCode==40) { // down
        var layers = all('#layers li');
        var layerId = -1;
        for (var i=0; i<layers.length-1; i++) {
          if (layers[i].classList.contains('active')) {
            layerId = i+1;
            break;
          }
        }
        if (layerId>-1) {
          UI_changeLayer(layerId);
          event.preventDefault();
          // return false;
        }
      }
      if (data.editor.activeLayerId==Layer.Exits) {
        if (event.keyCode==8 || event.keyCode==46) { // delete
          UI_deleteExit();
        }
      }
      else {
        if (event.keyCode==37) { // left
          var tileNodes = all('#room-tiles i[data-tile-type="'+LayerToTileType[data.editor.activeLayerId]+'"]');
          var tileId = -1;
          for (var i=1; i<tileNodes.length; i++) {
            var tileNode = tileNodes[i];
            if (tileNode.classList.contains('active')) {
              tileId = parseInt(tileNodes[i-1].dataset.tileId);
              break;
            }
          }
          if (tileId>-1) {
            UI_changeTile(tileId);
            event.preventDefault();
            // return false;
          }
        }
        else if (event.keyCode==39) { // right
          var tileNodes = all('#room-tiles i[data-tile-type="'+LayerToTileType[data.editor.activeLayerId]+'"]');
          var tileId = -1;
          for (var i=0; i<tileNodes.length-1; i++) {
            var tileNode = tileNodes[i];
            if (tileNode.classList.contains('active')) {
              tileId = parseInt(tileNodes[i+1].dataset.tileId);
              break;
            }
          }
          if (tileId>-1) {
            UI_changeTile(tileId);
            event.preventDefault();
            // return false;
          }
        }
        else if (event.keyCode==219) { // [
          var frameNodes = all('#tile-frames i');
          var frameId = -1;
          for (var i=1; i<frameNodes.length; i++) {
            var frameNode = frameNodes[i];
            if (frameNode.classList.contains('active')) {
              frameId = parseInt(frameNodes[i-1].dataset.frameId);
              break;
            }
          }
          if (frameId>-1) {
            UI_changeFrame(frameId);
            event.preventDefault();
            // return false;
          }
        }
        else if (event.keyCode==221) { // ]
          var frameNodes = all('#tile-frames i');
          var frameId = -1;
          for (var i=0; i<frameNodes.length-1; i++) {
            var frameNode = frameNodes[i];
            if (frameNode.classList.contains('active')) {
              frameId = parseInt(frameNodes[i+1].dataset.frameId);
              break;
            }
          }
          if (frameId>-1) {
            UI_changeFrame(frameId);
            event.preventDefault();
            // return false;
          }
        }
        else if (event.keyCode==73) { // i
          UI_invertTile();
        }
        else if (event.keyCode==72) { // h
          UI_flipTileH();
        }
        else if (event.keyCode==86) { // v
          UI_flipTileV();
        }
        else if (event.keyCode==82) { // r
          if (isOptionPressed) UI_duplicateAndRotateTiles();
          else  UI_rotateTile();
        }
        else if (event.keyCode==68) { // d
          if (isShiftPressed) UI_duplicateFrame();
          else UI_duplicateTile();
        }
      }
    }
    else if (inAudioMode()) {
      if (data.editor.activeModeId==EditorMode.Song) {
        if (event.keyCode==189) { // -
          var i = getSelectedIndex(songSelect) - 1;
          if (i>=0) {
            setSelectedIndex(songSelect, i);
            UI_changeSong();
          }
        }
        else if (event.keyCode==187) { // =
          var i = getSelectedIndex(songSelect) + 1;
          if (i<getSelectLength(songSelect)) {
            setSelectedIndex(songSelect, i);
            UI_changeSong();
          }
        }

        if (event.keyCode==86) { // V (split)
          splitPart();
        }
        else if (event.keyCode==66) { // B (bind?)
          joinParts();
        }
        else if (event.keyCode==8 || event.keyCode==46) { // delete
          deleteParts();
        }
        else if (event.keyCode==77) { // M (loopFrom)
          setLoopFrom();
        }

        if (selectedNotes.length==0) {
          if (event.keyCode==38) { // up
            var voices = all('#song-voices li');
            var voiceId = -1;
            for (var i=1; i<voices.length; i++) {
              if (voices[i].classList.contains('active')) {
                voiceId = i-1;
                break;
              }
            }
            if (voiceId>-1) {
              UI_changeVoice(voiceId);
              event.preventDefault();
            }
          }
          else if (event.keyCode==40) { // down
            var voices = all('#song-voices li');
            var voiceId = -1;
            for (var i=0; i<voices.length-1; i++) {
              if (voices[i].classList.contains('active')) {
                voiceId = i+1;
                break;
              }
            }
            if (voiceId>-1) {
              UI_changeVoice(voiceId);
              event.preventDefault();
            }
          }
        }
      }
      else if (data.editor.activeModeId==EditorMode.Sound) {
        if (event.keyCode==189) { // -
          var i = getSelectedIndex(soundSelect) - 1;
          if (i>=0) {
            setSelectedIndex(soundSelect, i);
            UI_changeSound();
          }
        }
        else if (event.keyCode==187) { // =
          var i = getSelectedIndex(soundSelect) + 1;
          if (i<getSelectLength(soundSelect)) {
            setSelectedIndex(soundSelect, i);
            UI_changeSound();
          }
        }

        if (selectedNotes.length==0) {
          if (event.keyCode==37) { // left
            var sound = data.sounds[data.editor.activeSoundId];
            var voiceId = sound.type-1;
            if (voiceId>-1) {
              UI_changeVoiceId(voiceId);
              event.preventDefault();
              // return false;
            }
          }
          else if (event.keyCode==39) { // right
            var sound = data.sounds[data.editor.activeSoundId];
            var voiceId = sound.type+1;
            if (voiceId<=VoiceType.Noise) {
              UI_changeVoiceId(voiceId);
              event.preventDefault();
              // return false;
            }
          }
        }
      }

      if (event.keyCode==82) { // R (loop )
        if (isShiftPressed) UI_toggleLoopNotes();
        else UI_toggleLoopSong();
      }

      if (selectedNotes.length>0) {
        // note editing
        var updateHistory = false;
        var songId = data.editor.activeSongId;
        var soundId = data.editor.activeSoundId;
        var voiceId = data.editor.activeVoiceId;

        var oldNotes = clone(audioSource.notes);

        if (event.keyCode==8 || event.keyCode==46) { // delete
          // TODO: move to a deleteSelectedNotes() function?
          for (var i=0; i<selectedNotes.length; i++) {
            var noteId = selectedNotes[i];
            setNoteAt(noteId,0,0,0);
          }
          deselectNotes();

          updateHistory = true;
        }
        // TODO: if no notes or parts are selected up/down should change voice
        else if (event.keyCode==38) { // up
          if (isShiftPressed) {
            tweakSelectedNotes(1,0); // octave
          }
          else {
            moveSelectedNotes(0,-1);
          }
          updateHistory = true;
        }
        else if (event.keyCode==40) { // down
          if (isShiftPressed) {
            tweakSelectedNotes(-1,0); // octave
          }
          else {
            moveSelectedNotes(0,1);
          }
          updateHistory = true;
        }
        else if (event.keyCode==37) { // left
          if (isShiftPressed) {
            tweakSelectedNotes(0,-1);
          }
          else {
            moveSelectedNotes(-1,0);
          }
          updateHistory = true;
        }
        else if (event.keyCode==39) { // right
          if (isShiftPressed) {
            tweakSelectedNotes(0,1);
          }
          else {
            moveSelectedNotes(1,0);
          }
          updateHistory = true;
        }

        if (updateHistory) {
          event.preventDefault();

          function cleanup() {
            updateAudioSource();
            renderNotes();
            renderSong();
          }
          cleanup();

          var newNotes = clone(audioSource.notes);

          pushHistory('note editing', function() {
            if (audioSource.type==AudioSource.Song) data.songs[songId].notes[voiceId] = clone(newNotes);
            else data.sounds[soundId].notes = clone(newNotes);
            cleanup();
          },function() {
            if (audioSource.type==AudioSource.Song) data.songs[songId].notes[voiceId] = clone(oldNotes);
            else data.sounds[soundId].notes = clone(oldNotes);
            cleanup();
          }, true);
        }
      }
    }
    else if (data.editor.activeModeId==EditorMode.Script) {
      if (event.keyCode==189) { // -
        var i = getSelectedIndex(scriptSelect) - 1;
        if (i>=0) {
          setSelectedIndex(scriptSelect, i);
          UI_changeScript();
        }
      }
      else if (event.keyCode==187) { // =
        var i = getSelectedIndex(scriptSelect) + 1;
        if (i<getSelectLength(scriptSelect)) {
          setSelectedIndex(scriptSelect, i);
          UI_changeScript();
        }
      }
    }
  });
  bind(window, 'keyup', function onEditorKeyUp(event) {
    // if (inTextInput()) return;

    if (event.keyCode==91 || event.keyCode==93) { // command, was space
      isCommandPressed = false;
      updateToolOverrides();
    }
    else if (event.keyCode==16) { // shift
      isShiftPressed = false;
      updateToolOverrides();
    }
    else if (event.keyCode==18) { // opt/alt
      isOptionPressed = false;
      updateToolOverrides();
    }
  });
  // reset modifiers if we cmd+tab away
  bind(window, 'pagehide,blur', function onEditorBlur(event) {
    if (isCommandPressed || isShiftPressed || isOptionPressed) {
      isCommandPressed = false;
      isShiftPressed = false;
      isOptionPressed = false;
      updateToolOverrides();
    }
  });
  bind(document, 'mousemove', function onEditorMouseMove(event) {
    var requiresUpdate = false;
    if (isCommandPressed && !event[cmdKey]) {
      isCommandPressed = false;
      requiresUpdate = true;
    }
    if (isShiftPressed && !event.shiftKey) {
      isShiftPressed = false;
      requiresUpdate = true;
    }
    if (isOptionPressed && !event.altKey) {
      isOptionPressed = false;
      requiresUpdate = true;
    }
    if (requiresUpdate) updateToolOverrides();
  });

  function sanityCheck() {
    // reset
    var footer = one('footer');
    var style = footer.style;
    style.position = 'fixed';
    style.top = 'auto';
    style.bottom = 0;
    var editor = one('#script-editor').parentNode;
    editor.style.height = '';

    var docsBottom = one('#docs-links').getBoundingClientRect().bottom;
    var footerTop = footer.getBoundingClientRect().top;
    if (footerTop<docsBottom) {
      style.top = docsBottom+'px';
      style.bottom = 'auto';
    }

    if (data.editor.activeModeId==EditorMode.Script) {
      editor.style.height = window.innerHeight - (editor.getBoundingClientRect().top + 32) + 'px';
    }
    scriptEditor.resize();

    if (document.body.classList.contains('searching')) {
      resultsList.style.top = 0;
      var bounds = resultsList.getBoundingClientRect();
      var oy = -24;
      if (bounds.top+bounds.height>window.innerHeight) {
        oy -= (bounds.top+bounds.height)-window.innerHeight;
      }
      resultsList.style.top = oy + 'px';
    }
  }
  sanityCheck();
  bind(window, 'resize', function onEditorResize(event) { sanityCheck(); });

  //////////////////////////////////////////////////////////
  function UI_changeVoice(newType) {
    var oldType = data.editor.activeVoiceId;

    if (oldType!=newType) {
      // TODO: do I need to integrate selectedParts here?
      pushHistory('set voice', function() {
        setActiveVoice(newType);
      }, function() {
        setActiveVoice(oldType);
      }, false, true);
    }
  }
  each('.voice-list li', function(i,node) {
    bind(node, 'click', function(event) {
      UI_changeVoice(parseInt(node.dataset.voiceType));
    });
  });

  //////////////////////////////////////////////////////////
  // update
  function update() {
    if (data.editor.activeModeId!=EditorMode.Room || isPreviewingText) return;

    elapsed += 0.05;
    var frameAdvanced = false;
    for (var i in frameTimers) {
      var timer = frameTimers[i];
      timer.elapsed += 0.05;
      if (timer.elapsed>=timer.duration) {
        timer.elapsed -= timer.duration;
        timer.frame += 1;
        frameAdvanced = true;
      }
    }
    if (frameAdvanced) {
      renderRoom();
      renderPreview();
    }
  }
  if (updateId!=null) window.clearInterval(updateId);
  updateId = window.setInterval(update, 50); // 20fps
}

ready(function() {
  document.body.appendChild(one('#overlay'));
  detectUnsavedData();
  onDataReady();
  saveRecoveredData();
});

